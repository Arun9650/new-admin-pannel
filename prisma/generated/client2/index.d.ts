
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AchievementCategory
 * 
 */
export type AchievementCategory = $Result.DefaultSelection<Prisma.$AchievementCategoryPayload>
/**
 * Model AchievementMilestone
 * 
 */
export type AchievementMilestone = $Result.DefaultSelection<Prisma.$AchievementMilestonePayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model DailyReward
 * 
 */
export type DailyReward = $Result.DefaultSelection<Prisma.$DailyRewardPayload>
/**
 * Model Card
 * 
 */
export type Card = $Result.DefaultSelection<Prisma.$CardPayload>
/**
 * Model UserCard
 * 
 */
export type UserCard = $Result.DefaultSelection<Prisma.$UserCardPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Authenticator
 * 
 */
export type Authenticator = $Result.DefaultSelection<Prisma.$AuthenticatorPayload>
/**
 * Model Leagues
 * 
 */
export type Leagues = $Result.DefaultSelection<Prisma.$LeaguesPayload>
/**
 * Model Points
 * 
 */
export type Points = $Result.DefaultSelection<Prisma.$PointsPayload>
/**
 * Model Bonuster
 * 
 */
export type Bonuster = $Result.DefaultSelection<Prisma.$BonusterPayload>
/**
 * Model DailyBoosters
 * 
 */
export type DailyBoosters = $Result.DefaultSelection<Prisma.$DailyBoostersPayload>
/**
 * Model TaskCategories
 * 
 */
export type TaskCategories = $Result.DefaultSelection<Prisma.$TaskCategoriesPayload>
/**
 * Model Tasks
 * 
 */
export type Tasks = $Result.DefaultSelection<Prisma.$TasksPayload>
/**
 * Model TasksCompletion
 * 
 */
export type TasksCompletion = $Result.DefaultSelection<Prisma.$TasksCompletionPayload>
/**
 * Model YouTube
 * 
 */
export type YouTube = $Result.DefaultSelection<Prisma.$YouTubePayload>
/**
 * Model YouTubeCompletion
 * 
 */
export type YouTubeCompletion = $Result.DefaultSelection<Prisma.$YouTubeCompletionPayload>
/**
 * Model Skins
 * 
 */
export type Skins = $Result.DefaultSelection<Prisma.$SkinsPayload>
/**
 * Model UserSkin
 * 
 */
export type UserSkin = $Result.DefaultSelection<Prisma.$UserSkinPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.achievementCategory`: Exposes CRUD operations for the **AchievementCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AchievementCategories
    * const achievementCategories = await prisma.achievementCategory.findMany()
    * ```
    */
  get achievementCategory(): Prisma.AchievementCategoryDelegate<ExtArgs>;

  /**
   * `prisma.achievementMilestone`: Exposes CRUD operations for the **AchievementMilestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AchievementMilestones
    * const achievementMilestones = await prisma.achievementMilestone.findMany()
    * ```
    */
  get achievementMilestone(): Prisma.AchievementMilestoneDelegate<ExtArgs>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs>;

  /**
   * `prisma.dailyReward`: Exposes CRUD operations for the **DailyReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyRewards
    * const dailyRewards = await prisma.dailyReward.findMany()
    * ```
    */
  get dailyReward(): Prisma.DailyRewardDelegate<ExtArgs>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.CardDelegate<ExtArgs>;

  /**
   * `prisma.userCard`: Exposes CRUD operations for the **UserCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCards
    * const userCards = await prisma.userCard.findMany()
    * ```
    */
  get userCard(): Prisma.UserCardDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.authenticator`: Exposes CRUD operations for the **Authenticator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authenticators
    * const authenticators = await prisma.authenticator.findMany()
    * ```
    */
  get authenticator(): Prisma.AuthenticatorDelegate<ExtArgs>;

  /**
   * `prisma.leagues`: Exposes CRUD operations for the **Leagues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leagues
    * const leagues = await prisma.leagues.findMany()
    * ```
    */
  get leagues(): Prisma.LeaguesDelegate<ExtArgs>;

  /**
   * `prisma.points`: Exposes CRUD operations for the **Points** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Points
    * const points = await prisma.points.findMany()
    * ```
    */
  get points(): Prisma.PointsDelegate<ExtArgs>;

  /**
   * `prisma.bonuster`: Exposes CRUD operations for the **Bonuster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bonusters
    * const bonusters = await prisma.bonuster.findMany()
    * ```
    */
  get bonuster(): Prisma.BonusterDelegate<ExtArgs>;

  /**
   * `prisma.dailyBoosters`: Exposes CRUD operations for the **DailyBoosters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyBoosters
    * const dailyBoosters = await prisma.dailyBoosters.findMany()
    * ```
    */
  get dailyBoosters(): Prisma.DailyBoostersDelegate<ExtArgs>;

  /**
   * `prisma.taskCategories`: Exposes CRUD operations for the **TaskCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskCategories
    * const taskCategories = await prisma.taskCategories.findMany()
    * ```
    */
  get taskCategories(): Prisma.TaskCategoriesDelegate<ExtArgs>;

  /**
   * `prisma.tasks`: Exposes CRUD operations for the **Tasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.tasks.findMany()
    * ```
    */
  get tasks(): Prisma.TasksDelegate<ExtArgs>;

  /**
   * `prisma.tasksCompletion`: Exposes CRUD operations for the **TasksCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TasksCompletions
    * const tasksCompletions = await prisma.tasksCompletion.findMany()
    * ```
    */
  get tasksCompletion(): Prisma.TasksCompletionDelegate<ExtArgs>;

  /**
   * `prisma.youTube`: Exposes CRUD operations for the **YouTube** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YouTubes
    * const youTubes = await prisma.youTube.findMany()
    * ```
    */
  get youTube(): Prisma.YouTubeDelegate<ExtArgs>;

  /**
   * `prisma.youTubeCompletion`: Exposes CRUD operations for the **YouTubeCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YouTubeCompletions
    * const youTubeCompletions = await prisma.youTubeCompletion.findMany()
    * ```
    */
  get youTubeCompletion(): Prisma.YouTubeCompletionDelegate<ExtArgs>;

  /**
   * `prisma.skins`: Exposes CRUD operations for the **Skins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skins
    * const skins = await prisma.skins.findMany()
    * ```
    */
  get skins(): Prisma.SkinsDelegate<ExtArgs>;

  /**
   * `prisma.userSkin`: Exposes CRUD operations for the **UserSkin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSkins
    * const userSkins = await prisma.userSkin.findMany()
    * ```
    */
  get userSkin(): Prisma.UserSkinDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AchievementCategory: 'AchievementCategory',
    AchievementMilestone: 'AchievementMilestone',
    UserAchievement: 'UserAchievement',
    DailyReward: 'DailyReward',
    Card: 'Card',
    UserCard: 'UserCard',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Authenticator: 'Authenticator',
    Leagues: 'Leagues',
    Points: 'Points',
    Bonuster: 'Bonuster',
    DailyBoosters: 'DailyBoosters',
    TaskCategories: 'TaskCategories',
    Tasks: 'Tasks',
    TasksCompletion: 'TasksCompletion',
    YouTube: 'YouTube',
    YouTubeCompletion: 'YouTubeCompletion',
    Skins: 'Skins',
    UserSkin: 'UserSkin'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "achievementCategory" | "achievementMilestone" | "userAchievement" | "dailyReward" | "card" | "userCard" | "account" | "session" | "verificationToken" | "authenticator" | "leagues" | "points" | "bonuster" | "dailyBoosters" | "taskCategories" | "tasks" | "tasksCompletion" | "youTube" | "youTubeCompletion" | "skins" | "userSkin"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AchievementCategory: {
        payload: Prisma.$AchievementCategoryPayload<ExtArgs>
        fields: Prisma.AchievementCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload>
          }
          findFirst: {
            args: Prisma.AchievementCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload>
          }
          findMany: {
            args: Prisma.AchievementCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload>[]
          }
          create: {
            args: Prisma.AchievementCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload>
          }
          createMany: {
            args: Prisma.AchievementCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AchievementCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload>
          }
          update: {
            args: Prisma.AchievementCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload>
          }
          deleteMany: {
            args: Prisma.AchievementCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementCategoryPayload>
          }
          aggregate: {
            args: Prisma.AchievementCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievementCategory>
          }
          groupBy: {
            args: Prisma.AchievementCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementCategoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AchievementCategoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AchievementCategoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AchievementCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCategoryCountAggregateOutputType> | number
          }
        }
      }
      AchievementMilestone: {
        payload: Prisma.$AchievementMilestonePayload<ExtArgs>
        fields: Prisma.AchievementMilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementMilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementMilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload>
          }
          findFirst: {
            args: Prisma.AchievementMilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementMilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload>
          }
          findMany: {
            args: Prisma.AchievementMilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload>[]
          }
          create: {
            args: Prisma.AchievementMilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload>
          }
          createMany: {
            args: Prisma.AchievementMilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AchievementMilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload>
          }
          update: {
            args: Prisma.AchievementMilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload>
          }
          deleteMany: {
            args: Prisma.AchievementMilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementMilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementMilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementMilestonePayload>
          }
          aggregate: {
            args: Prisma.AchievementMilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievementMilestone>
          }
          groupBy: {
            args: Prisma.AchievementMilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementMilestoneGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AchievementMilestoneFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AchievementMilestoneAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AchievementMilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementMilestoneCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserAchievementFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAchievementAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      DailyReward: {
        payload: Prisma.$DailyRewardPayload<ExtArgs>
        fields: Prisma.DailyRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload>
          }
          findFirst: {
            args: Prisma.DailyRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload>
          }
          findMany: {
            args: Prisma.DailyRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload>[]
          }
          create: {
            args: Prisma.DailyRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload>
          }
          createMany: {
            args: Prisma.DailyRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DailyRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload>
          }
          update: {
            args: Prisma.DailyRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload>
          }
          deleteMany: {
            args: Prisma.DailyRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardPayload>
          }
          aggregate: {
            args: Prisma.DailyRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyReward>
          }
          groupBy: {
            args: Prisma.DailyRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyRewardGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DailyRewardFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DailyRewardAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DailyRewardCountArgs<ExtArgs>
            result: $Utils.Optional<DailyRewardCountAggregateOutputType> | number
          }
        }
      }
      Card: {
        payload: Prisma.$CardPayload<ExtArgs>
        fields: Prisma.CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findFirst: {
            args: Prisma.CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findMany: {
            args: Prisma.CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          create: {
            args: Prisma.CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          createMany: {
            args: Prisma.CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          update: {
            args: Prisma.CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          deleteMany: {
            args: Prisma.CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          aggregate: {
            args: Prisma.CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCard>
          }
          groupBy: {
            args: Prisma.CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CardFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CardAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CardCountArgs<ExtArgs>
            result: $Utils.Optional<CardCountAggregateOutputType> | number
          }
        }
      }
      UserCard: {
        payload: Prisma.$UserCardPayload<ExtArgs>
        fields: Prisma.UserCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          findFirst: {
            args: Prisma.UserCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          findMany: {
            args: Prisma.UserCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>[]
          }
          create: {
            args: Prisma.UserCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          createMany: {
            args: Prisma.UserCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          update: {
            args: Prisma.UserCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          deleteMany: {
            args: Prisma.UserCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          aggregate: {
            args: Prisma.UserCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCard>
          }
          groupBy: {
            args: Prisma.UserCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCardGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserCardFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserCardAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCardCountArgs<ExtArgs>
            result: $Utils.Optional<UserCardCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VerificationTokenFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VerificationTokenAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Authenticator: {
        payload: Prisma.$AuthenticatorPayload<ExtArgs>
        fields: Prisma.AuthenticatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthenticatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthenticatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          findFirst: {
            args: Prisma.AuthenticatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthenticatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          findMany: {
            args: Prisma.AuthenticatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
          }
          create: {
            args: Prisma.AuthenticatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          createMany: {
            args: Prisma.AuthenticatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuthenticatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          update: {
            args: Prisma.AuthenticatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          deleteMany: {
            args: Prisma.AuthenticatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthenticatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthenticatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          aggregate: {
            args: Prisma.AuthenticatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthenticator>
          }
          groupBy: {
            args: Prisma.AuthenticatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthenticatorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AuthenticatorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AuthenticatorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AuthenticatorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthenticatorCountAggregateOutputType> | number
          }
        }
      }
      Leagues: {
        payload: Prisma.$LeaguesPayload<ExtArgs>
        fields: Prisma.LeaguesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaguesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaguesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload>
          }
          findFirst: {
            args: Prisma.LeaguesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaguesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload>
          }
          findMany: {
            args: Prisma.LeaguesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload>[]
          }
          create: {
            args: Prisma.LeaguesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload>
          }
          createMany: {
            args: Prisma.LeaguesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeaguesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload>
          }
          update: {
            args: Prisma.LeaguesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload>
          }
          deleteMany: {
            args: Prisma.LeaguesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaguesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaguesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguesPayload>
          }
          aggregate: {
            args: Prisma.LeaguesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeagues>
          }
          groupBy: {
            args: Prisma.LeaguesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaguesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LeaguesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LeaguesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LeaguesCountArgs<ExtArgs>
            result: $Utils.Optional<LeaguesCountAggregateOutputType> | number
          }
        }
      }
      Points: {
        payload: Prisma.$PointsPayload<ExtArgs>
        fields: Prisma.PointsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload>
          }
          findFirst: {
            args: Prisma.PointsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload>
          }
          findMany: {
            args: Prisma.PointsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload>[]
          }
          create: {
            args: Prisma.PointsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload>
          }
          createMany: {
            args: Prisma.PointsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PointsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload>
          }
          update: {
            args: Prisma.PointsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload>
          }
          deleteMany: {
            args: Prisma.PointsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsPayload>
          }
          aggregate: {
            args: Prisma.PointsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoints>
          }
          groupBy: {
            args: Prisma.PointsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PointsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PointsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PointsCountArgs<ExtArgs>
            result: $Utils.Optional<PointsCountAggregateOutputType> | number
          }
        }
      }
      Bonuster: {
        payload: Prisma.$BonusterPayload<ExtArgs>
        fields: Prisma.BonusterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BonusterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BonusterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload>
          }
          findFirst: {
            args: Prisma.BonusterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BonusterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload>
          }
          findMany: {
            args: Prisma.BonusterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload>[]
          }
          create: {
            args: Prisma.BonusterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload>
          }
          createMany: {
            args: Prisma.BonusterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BonusterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload>
          }
          update: {
            args: Prisma.BonusterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload>
          }
          deleteMany: {
            args: Prisma.BonusterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BonusterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BonusterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusterPayload>
          }
          aggregate: {
            args: Prisma.BonusterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBonuster>
          }
          groupBy: {
            args: Prisma.BonusterGroupByArgs<ExtArgs>
            result: $Utils.Optional<BonusterGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BonusterFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BonusterAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BonusterCountArgs<ExtArgs>
            result: $Utils.Optional<BonusterCountAggregateOutputType> | number
          }
        }
      }
      DailyBoosters: {
        payload: Prisma.$DailyBoostersPayload<ExtArgs>
        fields: Prisma.DailyBoostersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyBoostersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyBoostersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload>
          }
          findFirst: {
            args: Prisma.DailyBoostersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyBoostersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload>
          }
          findMany: {
            args: Prisma.DailyBoostersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload>[]
          }
          create: {
            args: Prisma.DailyBoostersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload>
          }
          createMany: {
            args: Prisma.DailyBoostersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DailyBoostersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload>
          }
          update: {
            args: Prisma.DailyBoostersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload>
          }
          deleteMany: {
            args: Prisma.DailyBoostersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyBoostersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyBoostersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyBoostersPayload>
          }
          aggregate: {
            args: Prisma.DailyBoostersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyBoosters>
          }
          groupBy: {
            args: Prisma.DailyBoostersGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyBoostersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DailyBoostersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DailyBoostersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DailyBoostersCountArgs<ExtArgs>
            result: $Utils.Optional<DailyBoostersCountAggregateOutputType> | number
          }
        }
      }
      TaskCategories: {
        payload: Prisma.$TaskCategoriesPayload<ExtArgs>
        fields: Prisma.TaskCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload>
          }
          findFirst: {
            args: Prisma.TaskCategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload>
          }
          findMany: {
            args: Prisma.TaskCategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload>[]
          }
          create: {
            args: Prisma.TaskCategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload>
          }
          createMany: {
            args: Prisma.TaskCategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskCategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload>
          }
          update: {
            args: Prisma.TaskCategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.TaskCategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskCategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCategoriesPayload>
          }
          aggregate: {
            args: Prisma.TaskCategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskCategories>
          }
          groupBy: {
            args: Prisma.TaskCategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCategoriesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TaskCategoriesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TaskCategoriesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TaskCategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCategoriesCountAggregateOutputType> | number
          }
        }
      }
      Tasks: {
        payload: Prisma.$TasksPayload<ExtArgs>
        fields: Prisma.TasksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TasksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TasksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          findFirst: {
            args: Prisma.TasksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TasksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          findMany: {
            args: Prisma.TasksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          create: {
            args: Prisma.TasksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          createMany: {
            args: Prisma.TasksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TasksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          update: {
            args: Prisma.TasksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          deleteMany: {
            args: Prisma.TasksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TasksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TasksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          aggregate: {
            args: Prisma.TasksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTasks>
          }
          groupBy: {
            args: Prisma.TasksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TasksGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TasksFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TasksAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TasksCountArgs<ExtArgs>
            result: $Utils.Optional<TasksCountAggregateOutputType> | number
          }
        }
      }
      TasksCompletion: {
        payload: Prisma.$TasksCompletionPayload<ExtArgs>
        fields: Prisma.TasksCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TasksCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TasksCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload>
          }
          findFirst: {
            args: Prisma.TasksCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TasksCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload>
          }
          findMany: {
            args: Prisma.TasksCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload>[]
          }
          create: {
            args: Prisma.TasksCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload>
          }
          createMany: {
            args: Prisma.TasksCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TasksCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload>
          }
          update: {
            args: Prisma.TasksCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload>
          }
          deleteMany: {
            args: Prisma.TasksCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TasksCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TasksCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksCompletionPayload>
          }
          aggregate: {
            args: Prisma.TasksCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTasksCompletion>
          }
          groupBy: {
            args: Prisma.TasksCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TasksCompletionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TasksCompletionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TasksCompletionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TasksCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<TasksCompletionCountAggregateOutputType> | number
          }
        }
      }
      YouTube: {
        payload: Prisma.$YouTubePayload<ExtArgs>
        fields: Prisma.YouTubeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YouTubeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YouTubeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload>
          }
          findFirst: {
            args: Prisma.YouTubeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YouTubeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload>
          }
          findMany: {
            args: Prisma.YouTubeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload>[]
          }
          create: {
            args: Prisma.YouTubeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload>
          }
          createMany: {
            args: Prisma.YouTubeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.YouTubeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload>
          }
          update: {
            args: Prisma.YouTubeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload>
          }
          deleteMany: {
            args: Prisma.YouTubeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YouTubeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.YouTubeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubePayload>
          }
          aggregate: {
            args: Prisma.YouTubeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYouTube>
          }
          groupBy: {
            args: Prisma.YouTubeGroupByArgs<ExtArgs>
            result: $Utils.Optional<YouTubeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.YouTubeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.YouTubeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.YouTubeCountArgs<ExtArgs>
            result: $Utils.Optional<YouTubeCountAggregateOutputType> | number
          }
        }
      }
      YouTubeCompletion: {
        payload: Prisma.$YouTubeCompletionPayload<ExtArgs>
        fields: Prisma.YouTubeCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YouTubeCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YouTubeCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload>
          }
          findFirst: {
            args: Prisma.YouTubeCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YouTubeCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload>
          }
          findMany: {
            args: Prisma.YouTubeCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload>[]
          }
          create: {
            args: Prisma.YouTubeCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload>
          }
          createMany: {
            args: Prisma.YouTubeCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.YouTubeCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload>
          }
          update: {
            args: Prisma.YouTubeCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload>
          }
          deleteMany: {
            args: Prisma.YouTubeCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YouTubeCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.YouTubeCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCompletionPayload>
          }
          aggregate: {
            args: Prisma.YouTubeCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYouTubeCompletion>
          }
          groupBy: {
            args: Prisma.YouTubeCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<YouTubeCompletionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.YouTubeCompletionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.YouTubeCompletionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.YouTubeCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<YouTubeCompletionCountAggregateOutputType> | number
          }
        }
      }
      Skins: {
        payload: Prisma.$SkinsPayload<ExtArgs>
        fields: Prisma.SkinsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkinsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkinsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload>
          }
          findFirst: {
            args: Prisma.SkinsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkinsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload>
          }
          findMany: {
            args: Prisma.SkinsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload>[]
          }
          create: {
            args: Prisma.SkinsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload>
          }
          createMany: {
            args: Prisma.SkinsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SkinsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload>
          }
          update: {
            args: Prisma.SkinsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload>
          }
          deleteMany: {
            args: Prisma.SkinsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkinsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkinsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkinsPayload>
          }
          aggregate: {
            args: Prisma.SkinsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkins>
          }
          groupBy: {
            args: Prisma.SkinsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkinsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SkinsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SkinsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SkinsCountArgs<ExtArgs>
            result: $Utils.Optional<SkinsCountAggregateOutputType> | number
          }
        }
      }
      UserSkin: {
        payload: Prisma.$UserSkinPayload<ExtArgs>
        fields: Prisma.UserSkinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSkinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSkinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload>
          }
          findFirst: {
            args: Prisma.UserSkinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSkinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload>
          }
          findMany: {
            args: Prisma.UserSkinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload>[]
          }
          create: {
            args: Prisma.UserSkinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload>
          }
          createMany: {
            args: Prisma.UserSkinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSkinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload>
          }
          update: {
            args: Prisma.UserSkinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload>
          }
          deleteMany: {
            args: Prisma.UserSkinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSkinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSkinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkinPayload>
          }
          aggregate: {
            args: Prisma.UserSkinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSkin>
          }
          groupBy: {
            args: Prisma.UserSkinGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSkinGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserSkinFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserSkinAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserSkinCountArgs<ExtArgs>
            result: $Utils.Optional<UserSkinCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    skins: number
    accounts: number
    sessions: number
    authenticators: number
    userCard: number
    Bonuster: number
    dailyRewards: number
    referrals: number
    achievements: number
    userTasks: number
    userYouTube: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skins?: boolean | UserCountOutputTypeCountSkinsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    authenticators?: boolean | UserCountOutputTypeCountAuthenticatorsArgs
    userCard?: boolean | UserCountOutputTypeCountUserCardArgs
    Bonuster?: boolean | UserCountOutputTypeCountBonusterArgs
    dailyRewards?: boolean | UserCountOutputTypeCountDailyRewardsArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    userTasks?: boolean | UserCountOutputTypeCountUserTasksArgs
    userYouTube?: boolean | UserCountOutputTypeCountUserYouTubeArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkinWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthenticatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthenticatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBonusterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRewardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksCompletionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserYouTubeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YouTubeCompletionWhereInput
  }


  /**
   * Count Type AchievementCategoryCountOutputType
   */

  export type AchievementCategoryCountOutputType = {
    milestones: number
  }

  export type AchievementCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestones?: boolean | AchievementCategoryCountOutputTypeCountMilestonesArgs
  }

  // Custom InputTypes
  /**
   * AchievementCategoryCountOutputType without action
   */
  export type AchievementCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategoryCountOutputType
     */
    select?: AchievementCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCategoryCountOutputType without action
   */
  export type AchievementCategoryCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementMilestoneWhereInput
  }


  /**
   * Count Type AchievementMilestoneCountOutputType
   */

  export type AchievementMilestoneCountOutputType = {
    userAchievements: number
  }

  export type AchievementMilestoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | AchievementMilestoneCountOutputTypeCountUserAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementMilestoneCountOutputType without action
   */
  export type AchievementMilestoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestoneCountOutputType
     */
    select?: AchievementMilestoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementMilestoneCountOutputType without action
   */
  export type AchievementMilestoneCountOutputTypeCountUserAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type CardCountOutputType
   */

  export type CardCountOutputType = {
    users: number
  }

  export type CardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CardCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardCountOutputType
     */
    select?: CardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCardWhereInput
  }


  /**
   * Count Type TasksCountOutputType
   */

  export type TasksCountOutputType = {
    user: number
  }

  export type TasksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | TasksCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCountOutputType
     */
    select?: TasksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksCompletionWhereInput
  }


  /**
   * Count Type YouTubeCountOutputType
   */

  export type YouTubeCountOutputType = {
    user: number
  }

  export type YouTubeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | YouTubeCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * YouTubeCountOutputType without action
   */
  export type YouTubeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCountOutputType
     */
    select?: YouTubeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YouTubeCountOutputType without action
   */
  export type YouTubeCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YouTubeCompletionWhereInput
  }


  /**
   * Count Type SkinsCountOutputType
   */

  export type SkinsCountOutputType = {
    users: number
  }

  export type SkinsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SkinsCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SkinsCountOutputType without action
   */
  export type SkinsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkinsCountOutputType
     */
    select?: SkinsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkinsCountOutputType without action
   */
  export type SkinsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkinWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    taps: number | null
    points: number | null
    profit: number | null
    lastProfitDate: number | null
    rechargeLimit: number | null
    pointPerTap: number | null
    profitPerHour: number | null
    refillRate: number | null
    bonus: number | null
    referralCount: number | null
    loginStreak: number | null
  }

  export type UserSumAggregateOutputType = {
    taps: number | null
    points: number | null
    profit: number | null
    lastProfitDate: number | null
    rechargeLimit: number | null
    pointPerTap: number | null
    profitPerHour: number | null
    refillRate: number | null
    bonus: number | null
    referralCount: number | null
    loginStreak: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    chatId: string | null
    taps: number | null
    points: number | null
    profit: number | null
    lastProfitDate: number | null
    rechargeLimit: number | null
    pointPerTap: number | null
    profitPerHour: number | null
    refillRate: number | null
    bonus: number | null
    active: boolean | null
    skin: string | null
    lastLogin: Date | null
    league: string | null
    referralCount: number | null
    loginStreak: number | null
    createdAt: Date | null
    updatedAt: Date | null
    referredById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    chatId: string | null
    taps: number | null
    points: number | null
    profit: number | null
    lastProfitDate: number | null
    rechargeLimit: number | null
    pointPerTap: number | null
    profitPerHour: number | null
    refillRate: number | null
    bonus: number | null
    active: boolean | null
    skin: string | null
    lastLogin: Date | null
    league: string | null
    referralCount: number | null
    loginStreak: number | null
    createdAt: Date | null
    updatedAt: Date | null
    referredById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    chatId: number
    taps: number
    points: number
    profit: number
    lastProfitDate: number
    rechargeLimit: number
    pointPerTap: number
    profitPerHour: number
    refillRate: number
    bonus: number
    active: number
    skin: number
    lastLogin: number
    league: number
    referralCount: number
    loginStreak: number
    createdAt: number
    updatedAt: number
    referredById: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    taps?: true
    points?: true
    profit?: true
    lastProfitDate?: true
    rechargeLimit?: true
    pointPerTap?: true
    profitPerHour?: true
    refillRate?: true
    bonus?: true
    referralCount?: true
    loginStreak?: true
  }

  export type UserSumAggregateInputType = {
    taps?: true
    points?: true
    profit?: true
    lastProfitDate?: true
    rechargeLimit?: true
    pointPerTap?: true
    profitPerHour?: true
    refillRate?: true
    bonus?: true
    referralCount?: true
    loginStreak?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    chatId?: true
    taps?: true
    points?: true
    profit?: true
    lastProfitDate?: true
    rechargeLimit?: true
    pointPerTap?: true
    profitPerHour?: true
    refillRate?: true
    bonus?: true
    active?: true
    skin?: true
    lastLogin?: true
    league?: true
    referralCount?: true
    loginStreak?: true
    createdAt?: true
    updatedAt?: true
    referredById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    chatId?: true
    taps?: true
    points?: true
    profit?: true
    lastProfitDate?: true
    rechargeLimit?: true
    pointPerTap?: true
    profitPerHour?: true
    refillRate?: true
    bonus?: true
    active?: true
    skin?: true
    lastLogin?: true
    league?: true
    referralCount?: true
    loginStreak?: true
    createdAt?: true
    updatedAt?: true
    referredById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    chatId?: true
    taps?: true
    points?: true
    profit?: true
    lastProfitDate?: true
    rechargeLimit?: true
    pointPerTap?: true
    profitPerHour?: true
    refillRate?: true
    bonus?: true
    active?: true
    skin?: true
    lastLogin?: true
    league?: true
    referralCount?: true
    loginStreak?: true
    createdAt?: true
    updatedAt?: true
    referredById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    chatId: string
    taps: number
    points: number
    profit: number
    lastProfitDate: number | null
    rechargeLimit: number
    pointPerTap: number
    profitPerHour: number
    refillRate: number
    bonus: number
    active: boolean
    skin: string
    lastLogin: Date
    league: string | null
    referralCount: number
    loginStreak: number
    createdAt: Date
    updatedAt: Date
    referredById: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    chatId?: boolean
    taps?: boolean
    points?: boolean
    profit?: boolean
    lastProfitDate?: boolean
    rechargeLimit?: boolean
    pointPerTap?: boolean
    profitPerHour?: boolean
    refillRate?: boolean
    bonus?: boolean
    active?: boolean
    skin?: boolean
    lastLogin?: boolean
    league?: boolean
    referralCount?: boolean
    loginStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referredById?: boolean
    skins?: boolean | User$skinsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    authenticators?: boolean | User$authenticatorsArgs<ExtArgs>
    userCard?: boolean | User$userCardArgs<ExtArgs>
    Bonuster?: boolean | User$BonusterArgs<ExtArgs>
    dailyRewards?: boolean | User$dailyRewardsArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    userTasks?: boolean | User$userTasksArgs<ExtArgs>
    userYouTube?: boolean | User$userYouTubeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    chatId?: boolean
    taps?: boolean
    points?: boolean
    profit?: boolean
    lastProfitDate?: boolean
    rechargeLimit?: boolean
    pointPerTap?: boolean
    profitPerHour?: boolean
    refillRate?: boolean
    bonus?: boolean
    active?: boolean
    skin?: boolean
    lastLogin?: boolean
    league?: boolean
    referralCount?: boolean
    loginStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referredById?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skins?: boolean | User$skinsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    authenticators?: boolean | User$authenticatorsArgs<ExtArgs>
    userCard?: boolean | User$userCardArgs<ExtArgs>
    Bonuster?: boolean | User$BonusterArgs<ExtArgs>
    dailyRewards?: boolean | User$dailyRewardsArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    userTasks?: boolean | User$userTasksArgs<ExtArgs>
    userYouTube?: boolean | User$userYouTubeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      skins: Prisma.$UserSkinPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      authenticators: Prisma.$AuthenticatorPayload<ExtArgs>[]
      userCard: Prisma.$UserCardPayload<ExtArgs>[]
      Bonuster: Prisma.$BonusterPayload<ExtArgs>[]
      dailyRewards: Prisma.$DailyRewardPayload<ExtArgs>[]
      referredBy: Prisma.$UserPayload<ExtArgs> | null
      referrals: Prisma.$UserPayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      userTasks: Prisma.$TasksCompletionPayload<ExtArgs>[]
      userYouTube: Prisma.$YouTubeCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      chatId: string
      taps: number
      points: number
      profit: number
      lastProfitDate: number | null
      rechargeLimit: number
      pointPerTap: number
      profitPerHour: number
      refillRate: number
      bonus: number
      active: boolean
      skin: string
      lastLogin: Date
      league: string | null
      referralCount: number
      loginStreak: number
      createdAt: Date
      updatedAt: Date
      referredById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skins<T extends User$skinsArgs<ExtArgs> = {}>(args?: Subset<T, User$skinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    authenticators<T extends User$authenticatorsArgs<ExtArgs> = {}>(args?: Subset<T, User$authenticatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findMany"> | Null>
    userCard<T extends User$userCardArgs<ExtArgs> = {}>(args?: Subset<T, User$userCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findMany"> | Null>
    Bonuster<T extends User$BonusterArgs<ExtArgs> = {}>(args?: Subset<T, User$BonusterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "findMany"> | Null>
    dailyRewards<T extends User$dailyRewardsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyRewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "findMany"> | Null>
    referredBy<T extends User$referredByArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    userTasks<T extends User$userTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$userTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    userYouTube<T extends User$userYouTubeArgs<ExtArgs> = {}>(args?: Subset<T, User$userYouTubeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly chatId: FieldRef<"User", 'String'>
    readonly taps: FieldRef<"User", 'Int'>
    readonly points: FieldRef<"User", 'Int'>
    readonly profit: FieldRef<"User", 'Int'>
    readonly lastProfitDate: FieldRef<"User", 'Int'>
    readonly rechargeLimit: FieldRef<"User", 'Int'>
    readonly pointPerTap: FieldRef<"User", 'Int'>
    readonly profitPerHour: FieldRef<"User", 'Int'>
    readonly refillRate: FieldRef<"User", 'Int'>
    readonly bonus: FieldRef<"User", 'Int'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly skin: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly league: FieldRef<"User", 'String'>
    readonly referralCount: FieldRef<"User", 'Int'>
    readonly loginStreak: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly referredById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.skins
   */
  export type User$skinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    where?: UserSkinWhereInput
    orderBy?: UserSkinOrderByWithRelationInput | UserSkinOrderByWithRelationInput[]
    cursor?: UserSkinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkinScalarFieldEnum | UserSkinScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.authenticators
   */
  export type User$authenticatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    where?: AuthenticatorWhereInput
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    cursor?: AuthenticatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * User.userCard
   */
  export type User$userCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    where?: UserCardWhereInput
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    cursor?: UserCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * User.Bonuster
   */
  export type User$BonusterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    where?: BonusterWhereInput
    orderBy?: BonusterOrderByWithRelationInput | BonusterOrderByWithRelationInput[]
    cursor?: BonusterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BonusterScalarFieldEnum | BonusterScalarFieldEnum[]
  }

  /**
   * User.dailyRewards
   */
  export type User$dailyRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    where?: DailyRewardWhereInput
    orderBy?: DailyRewardOrderByWithRelationInput | DailyRewardOrderByWithRelationInput[]
    cursor?: DailyRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRewardScalarFieldEnum | DailyRewardScalarFieldEnum[]
  }

  /**
   * User.referredBy
   */
  export type User$referredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.userTasks
   */
  export type User$userTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    where?: TasksCompletionWhereInput
    orderBy?: TasksCompletionOrderByWithRelationInput | TasksCompletionOrderByWithRelationInput[]
    cursor?: TasksCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksCompletionScalarFieldEnum | TasksCompletionScalarFieldEnum[]
  }

  /**
   * User.userYouTube
   */
  export type User$userYouTubeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    where?: YouTubeCompletionWhereInput
    orderBy?: YouTubeCompletionOrderByWithRelationInput | YouTubeCompletionOrderByWithRelationInput[]
    cursor?: YouTubeCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YouTubeCompletionScalarFieldEnum | YouTubeCompletionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AchievementCategory
   */

  export type AggregateAchievementCategory = {
    _count: AchievementCategoryCountAggregateOutputType | null
    _min: AchievementCategoryMinAggregateOutputType | null
    _max: AchievementCategoryMaxAggregateOutputType | null
  }

  export type AchievementCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type AchievementCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type AchievementCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type AchievementCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AchievementCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AchievementCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AchievementCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementCategory to aggregate.
     */
    where?: AchievementCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementCategories to fetch.
     */
    orderBy?: AchievementCategoryOrderByWithRelationInput | AchievementCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AchievementCategories
    **/
    _count?: true | AchievementCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementCategoryMaxAggregateInputType
  }

  export type GetAchievementCategoryAggregateType<T extends AchievementCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievementCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievementCategory[P]>
      : GetScalarType<T[P], AggregateAchievementCategory[P]>
  }




  export type AchievementCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementCategoryWhereInput
    orderBy?: AchievementCategoryOrderByWithAggregationInput | AchievementCategoryOrderByWithAggregationInput[]
    by: AchievementCategoryScalarFieldEnum[] | AchievementCategoryScalarFieldEnum
    having?: AchievementCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCategoryCountAggregateInputType | true
    _min?: AchievementCategoryMinAggregateInputType
    _max?: AchievementCategoryMaxAggregateInputType
  }

  export type AchievementCategoryGroupByOutputType = {
    id: string
    name: string
    _count: AchievementCategoryCountAggregateOutputType | null
    _min: AchievementCategoryMinAggregateOutputType | null
    _max: AchievementCategoryMaxAggregateOutputType | null
  }

  type GetAchievementCategoryGroupByPayload<T extends AchievementCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementCategoryGroupByOutputType[P]>
        }
      >
    >


  export type AchievementCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    milestones?: boolean | AchievementCategory$milestonesArgs<ExtArgs>
    _count?: boolean | AchievementCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementCategory"]>


  export type AchievementCategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type AchievementCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestones?: boolean | AchievementCategory$milestonesArgs<ExtArgs>
    _count?: boolean | AchievementCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AchievementCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AchievementCategory"
    objects: {
      milestones: Prisma.$AchievementMilestonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["achievementCategory"]>
    composites: {}
  }

  type AchievementCategoryGetPayload<S extends boolean | null | undefined | AchievementCategoryDefaultArgs> = $Result.GetResult<Prisma.$AchievementCategoryPayload, S>

  type AchievementCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCategoryCountAggregateInputType | true
    }

  export interface AchievementCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AchievementCategory'], meta: { name: 'AchievementCategory' } }
    /**
     * Find zero or one AchievementCategory that matches the filter.
     * @param {AchievementCategoryFindUniqueArgs} args - Arguments to find a AchievementCategory
     * @example
     * // Get one AchievementCategory
     * const achievementCategory = await prisma.achievementCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementCategoryFindUniqueArgs>(args: SelectSubset<T, AchievementCategoryFindUniqueArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AchievementCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementCategoryFindUniqueOrThrowArgs} args - Arguments to find a AchievementCategory
     * @example
     * // Get one AchievementCategory
     * const achievementCategory = await prisma.achievementCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AchievementCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCategoryFindFirstArgs} args - Arguments to find a AchievementCategory
     * @example
     * // Get one AchievementCategory
     * const achievementCategory = await prisma.achievementCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementCategoryFindFirstArgs>(args?: SelectSubset<T, AchievementCategoryFindFirstArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AchievementCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCategoryFindFirstOrThrowArgs} args - Arguments to find a AchievementCategory
     * @example
     * // Get one AchievementCategory
     * const achievementCategory = await prisma.achievementCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AchievementCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AchievementCategories
     * const achievementCategories = await prisma.achievementCategory.findMany()
     * 
     * // Get first 10 AchievementCategories
     * const achievementCategories = await prisma.achievementCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementCategoryWithIdOnly = await prisma.achievementCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementCategoryFindManyArgs>(args?: SelectSubset<T, AchievementCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AchievementCategory.
     * @param {AchievementCategoryCreateArgs} args - Arguments to create a AchievementCategory.
     * @example
     * // Create one AchievementCategory
     * const AchievementCategory = await prisma.achievementCategory.create({
     *   data: {
     *     // ... data to create a AchievementCategory
     *   }
     * })
     * 
     */
    create<T extends AchievementCategoryCreateArgs>(args: SelectSubset<T, AchievementCategoryCreateArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AchievementCategories.
     * @param {AchievementCategoryCreateManyArgs} args - Arguments to create many AchievementCategories.
     * @example
     * // Create many AchievementCategories
     * const achievementCategory = await prisma.achievementCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCategoryCreateManyArgs>(args?: SelectSubset<T, AchievementCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AchievementCategory.
     * @param {AchievementCategoryDeleteArgs} args - Arguments to delete one AchievementCategory.
     * @example
     * // Delete one AchievementCategory
     * const AchievementCategory = await prisma.achievementCategory.delete({
     *   where: {
     *     // ... filter to delete one AchievementCategory
     *   }
     * })
     * 
     */
    delete<T extends AchievementCategoryDeleteArgs>(args: SelectSubset<T, AchievementCategoryDeleteArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AchievementCategory.
     * @param {AchievementCategoryUpdateArgs} args - Arguments to update one AchievementCategory.
     * @example
     * // Update one AchievementCategory
     * const achievementCategory = await prisma.achievementCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementCategoryUpdateArgs>(args: SelectSubset<T, AchievementCategoryUpdateArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AchievementCategories.
     * @param {AchievementCategoryDeleteManyArgs} args - Arguments to filter AchievementCategories to delete.
     * @example
     * // Delete a few AchievementCategories
     * const { count } = await prisma.achievementCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementCategoryDeleteManyArgs>(args?: SelectSubset<T, AchievementCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AchievementCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AchievementCategories
     * const achievementCategory = await prisma.achievementCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementCategoryUpdateManyArgs>(args: SelectSubset<T, AchievementCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AchievementCategory.
     * @param {AchievementCategoryUpsertArgs} args - Arguments to update or create a AchievementCategory.
     * @example
     * // Update or create a AchievementCategory
     * const achievementCategory = await prisma.achievementCategory.upsert({
     *   create: {
     *     // ... data to create a AchievementCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AchievementCategory we want to update
     *   }
     * })
     */
    upsert<T extends AchievementCategoryUpsertArgs>(args: SelectSubset<T, AchievementCategoryUpsertArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more AchievementCategories that matches the filter.
     * @param {AchievementCategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const achievementCategory = await prisma.achievementCategory.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AchievementCategoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AchievementCategory.
     * @param {AchievementCategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const achievementCategory = await prisma.achievementCategory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AchievementCategoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AchievementCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCategoryCountArgs} args - Arguments to filter AchievementCategories to count.
     * @example
     * // Count the number of AchievementCategories
     * const count = await prisma.achievementCategory.count({
     *   where: {
     *     // ... the filter for the AchievementCategories we want to count
     *   }
     * })
    **/
    count<T extends AchievementCategoryCountArgs>(
      args?: Subset<T, AchievementCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AchievementCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementCategoryAggregateArgs>(args: Subset<T, AchievementCategoryAggregateArgs>): Prisma.PrismaPromise<GetAchievementCategoryAggregateType<T>>

    /**
     * Group by AchievementCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementCategoryGroupByArgs['orderBy'] }
        : { orderBy?: AchievementCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AchievementCategory model
   */
  readonly fields: AchievementCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AchievementCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    milestones<T extends AchievementCategory$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, AchievementCategory$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AchievementCategory model
   */ 
  interface AchievementCategoryFieldRefs {
    readonly id: FieldRef<"AchievementCategory", 'String'>
    readonly name: FieldRef<"AchievementCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AchievementCategory findUnique
   */
  export type AchievementCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AchievementCategory to fetch.
     */
    where: AchievementCategoryWhereUniqueInput
  }

  /**
   * AchievementCategory findUniqueOrThrow
   */
  export type AchievementCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AchievementCategory to fetch.
     */
    where: AchievementCategoryWhereUniqueInput
  }

  /**
   * AchievementCategory findFirst
   */
  export type AchievementCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AchievementCategory to fetch.
     */
    where?: AchievementCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementCategories to fetch.
     */
    orderBy?: AchievementCategoryOrderByWithRelationInput | AchievementCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementCategories.
     */
    cursor?: AchievementCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementCategories.
     */
    distinct?: AchievementCategoryScalarFieldEnum | AchievementCategoryScalarFieldEnum[]
  }

  /**
   * AchievementCategory findFirstOrThrow
   */
  export type AchievementCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AchievementCategory to fetch.
     */
    where?: AchievementCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementCategories to fetch.
     */
    orderBy?: AchievementCategoryOrderByWithRelationInput | AchievementCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementCategories.
     */
    cursor?: AchievementCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementCategories.
     */
    distinct?: AchievementCategoryScalarFieldEnum | AchievementCategoryScalarFieldEnum[]
  }

  /**
   * AchievementCategory findMany
   */
  export type AchievementCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AchievementCategories to fetch.
     */
    where?: AchievementCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementCategories to fetch.
     */
    orderBy?: AchievementCategoryOrderByWithRelationInput | AchievementCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AchievementCategories.
     */
    cursor?: AchievementCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementCategories.
     */
    skip?: number
    distinct?: AchievementCategoryScalarFieldEnum | AchievementCategoryScalarFieldEnum[]
  }

  /**
   * AchievementCategory create
   */
  export type AchievementCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AchievementCategory.
     */
    data: XOR<AchievementCategoryCreateInput, AchievementCategoryUncheckedCreateInput>
  }

  /**
   * AchievementCategory createMany
   */
  export type AchievementCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AchievementCategories.
     */
    data: AchievementCategoryCreateManyInput | AchievementCategoryCreateManyInput[]
  }

  /**
   * AchievementCategory update
   */
  export type AchievementCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AchievementCategory.
     */
    data: XOR<AchievementCategoryUpdateInput, AchievementCategoryUncheckedUpdateInput>
    /**
     * Choose, which AchievementCategory to update.
     */
    where: AchievementCategoryWhereUniqueInput
  }

  /**
   * AchievementCategory updateMany
   */
  export type AchievementCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AchievementCategories.
     */
    data: XOR<AchievementCategoryUpdateManyMutationInput, AchievementCategoryUncheckedUpdateManyInput>
    /**
     * Filter which AchievementCategories to update
     */
    where?: AchievementCategoryWhereInput
  }

  /**
   * AchievementCategory upsert
   */
  export type AchievementCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AchievementCategory to update in case it exists.
     */
    where: AchievementCategoryWhereUniqueInput
    /**
     * In case the AchievementCategory found by the `where` argument doesn't exist, create a new AchievementCategory with this data.
     */
    create: XOR<AchievementCategoryCreateInput, AchievementCategoryUncheckedCreateInput>
    /**
     * In case the AchievementCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementCategoryUpdateInput, AchievementCategoryUncheckedUpdateInput>
  }

  /**
   * AchievementCategory delete
   */
  export type AchievementCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
    /**
     * Filter which AchievementCategory to delete.
     */
    where: AchievementCategoryWhereUniqueInput
  }

  /**
   * AchievementCategory deleteMany
   */
  export type AchievementCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementCategories to delete
     */
    where?: AchievementCategoryWhereInput
  }

  /**
   * AchievementCategory findRaw
   */
  export type AchievementCategoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AchievementCategory aggregateRaw
   */
  export type AchievementCategoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AchievementCategory.milestones
   */
  export type AchievementCategory$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    where?: AchievementMilestoneWhereInput
    orderBy?: AchievementMilestoneOrderByWithRelationInput | AchievementMilestoneOrderByWithRelationInput[]
    cursor?: AchievementMilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementMilestoneScalarFieldEnum | AchievementMilestoneScalarFieldEnum[]
  }

  /**
   * AchievementCategory without action
   */
  export type AchievementCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCategory
     */
    select?: AchievementCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementCategoryInclude<ExtArgs> | null
  }


  /**
   * Model AchievementMilestone
   */

  export type AggregateAchievementMilestone = {
    _count: AchievementMilestoneCountAggregateOutputType | null
    _min: AchievementMilestoneMinAggregateOutputType | null
    _max: AchievementMilestoneMaxAggregateOutputType | null
  }

  export type AchievementMilestoneMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    icon: string | null
    unlocked: boolean | null
  }

  export type AchievementMilestoneMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    icon: string | null
    unlocked: boolean | null
  }

  export type AchievementMilestoneCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    icon: number
    unlocked: number
    _all: number
  }


  export type AchievementMilestoneMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    icon?: true
    unlocked?: true
  }

  export type AchievementMilestoneMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    icon?: true
    unlocked?: true
  }

  export type AchievementMilestoneCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    icon?: true
    unlocked?: true
    _all?: true
  }

  export type AchievementMilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementMilestone to aggregate.
     */
    where?: AchievementMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementMilestones to fetch.
     */
    orderBy?: AchievementMilestoneOrderByWithRelationInput | AchievementMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AchievementMilestones
    **/
    _count?: true | AchievementMilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMilestoneMaxAggregateInputType
  }

  export type GetAchievementMilestoneAggregateType<T extends AchievementMilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievementMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievementMilestone[P]>
      : GetScalarType<T[P], AggregateAchievementMilestone[P]>
  }




  export type AchievementMilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementMilestoneWhereInput
    orderBy?: AchievementMilestoneOrderByWithAggregationInput | AchievementMilestoneOrderByWithAggregationInput[]
    by: AchievementMilestoneScalarFieldEnum[] | AchievementMilestoneScalarFieldEnum
    having?: AchievementMilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementMilestoneCountAggregateInputType | true
    _min?: AchievementMilestoneMinAggregateInputType
    _max?: AchievementMilestoneMaxAggregateInputType
  }

  export type AchievementMilestoneGroupByOutputType = {
    id: string
    categoryId: string
    name: string
    icon: string
    unlocked: boolean
    _count: AchievementMilestoneCountAggregateOutputType | null
    _min: AchievementMilestoneMinAggregateOutputType | null
    _max: AchievementMilestoneMaxAggregateOutputType | null
  }

  type GetAchievementMilestoneGroupByPayload<T extends AchievementMilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementMilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementMilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementMilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementMilestoneGroupByOutputType[P]>
        }
      >
    >


  export type AchievementMilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    icon?: boolean
    unlocked?: boolean
    category?: boolean | AchievementCategoryDefaultArgs<ExtArgs>
    userAchievements?: boolean | AchievementMilestone$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementMilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementMilestone"]>


  export type AchievementMilestoneSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    icon?: boolean
    unlocked?: boolean
  }

  export type AchievementMilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | AchievementCategoryDefaultArgs<ExtArgs>
    userAchievements?: boolean | AchievementMilestone$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementMilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AchievementMilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AchievementMilestone"
    objects: {
      category: Prisma.$AchievementCategoryPayload<ExtArgs>
      userAchievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      name: string
      icon: string
      unlocked: boolean
    }, ExtArgs["result"]["achievementMilestone"]>
    composites: {}
  }

  type AchievementMilestoneGetPayload<S extends boolean | null | undefined | AchievementMilestoneDefaultArgs> = $Result.GetResult<Prisma.$AchievementMilestonePayload, S>

  type AchievementMilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementMilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementMilestoneCountAggregateInputType | true
    }

  export interface AchievementMilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AchievementMilestone'], meta: { name: 'AchievementMilestone' } }
    /**
     * Find zero or one AchievementMilestone that matches the filter.
     * @param {AchievementMilestoneFindUniqueArgs} args - Arguments to find a AchievementMilestone
     * @example
     * // Get one AchievementMilestone
     * const achievementMilestone = await prisma.achievementMilestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementMilestoneFindUniqueArgs>(args: SelectSubset<T, AchievementMilestoneFindUniqueArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AchievementMilestone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementMilestoneFindUniqueOrThrowArgs} args - Arguments to find a AchievementMilestone
     * @example
     * // Get one AchievementMilestone
     * const achievementMilestone = await prisma.achievementMilestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementMilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementMilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AchievementMilestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementMilestoneFindFirstArgs} args - Arguments to find a AchievementMilestone
     * @example
     * // Get one AchievementMilestone
     * const achievementMilestone = await prisma.achievementMilestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementMilestoneFindFirstArgs>(args?: SelectSubset<T, AchievementMilestoneFindFirstArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AchievementMilestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementMilestoneFindFirstOrThrowArgs} args - Arguments to find a AchievementMilestone
     * @example
     * // Get one AchievementMilestone
     * const achievementMilestone = await prisma.achievementMilestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementMilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementMilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AchievementMilestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementMilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AchievementMilestones
     * const achievementMilestones = await prisma.achievementMilestone.findMany()
     * 
     * // Get first 10 AchievementMilestones
     * const achievementMilestones = await prisma.achievementMilestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementMilestoneWithIdOnly = await prisma.achievementMilestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementMilestoneFindManyArgs>(args?: SelectSubset<T, AchievementMilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AchievementMilestone.
     * @param {AchievementMilestoneCreateArgs} args - Arguments to create a AchievementMilestone.
     * @example
     * // Create one AchievementMilestone
     * const AchievementMilestone = await prisma.achievementMilestone.create({
     *   data: {
     *     // ... data to create a AchievementMilestone
     *   }
     * })
     * 
     */
    create<T extends AchievementMilestoneCreateArgs>(args: SelectSubset<T, AchievementMilestoneCreateArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AchievementMilestones.
     * @param {AchievementMilestoneCreateManyArgs} args - Arguments to create many AchievementMilestones.
     * @example
     * // Create many AchievementMilestones
     * const achievementMilestone = await prisma.achievementMilestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementMilestoneCreateManyArgs>(args?: SelectSubset<T, AchievementMilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AchievementMilestone.
     * @param {AchievementMilestoneDeleteArgs} args - Arguments to delete one AchievementMilestone.
     * @example
     * // Delete one AchievementMilestone
     * const AchievementMilestone = await prisma.achievementMilestone.delete({
     *   where: {
     *     // ... filter to delete one AchievementMilestone
     *   }
     * })
     * 
     */
    delete<T extends AchievementMilestoneDeleteArgs>(args: SelectSubset<T, AchievementMilestoneDeleteArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AchievementMilestone.
     * @param {AchievementMilestoneUpdateArgs} args - Arguments to update one AchievementMilestone.
     * @example
     * // Update one AchievementMilestone
     * const achievementMilestone = await prisma.achievementMilestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementMilestoneUpdateArgs>(args: SelectSubset<T, AchievementMilestoneUpdateArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AchievementMilestones.
     * @param {AchievementMilestoneDeleteManyArgs} args - Arguments to filter AchievementMilestones to delete.
     * @example
     * // Delete a few AchievementMilestones
     * const { count } = await prisma.achievementMilestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementMilestoneDeleteManyArgs>(args?: SelectSubset<T, AchievementMilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AchievementMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementMilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AchievementMilestones
     * const achievementMilestone = await prisma.achievementMilestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementMilestoneUpdateManyArgs>(args: SelectSubset<T, AchievementMilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AchievementMilestone.
     * @param {AchievementMilestoneUpsertArgs} args - Arguments to update or create a AchievementMilestone.
     * @example
     * // Update or create a AchievementMilestone
     * const achievementMilestone = await prisma.achievementMilestone.upsert({
     *   create: {
     *     // ... data to create a AchievementMilestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AchievementMilestone we want to update
     *   }
     * })
     */
    upsert<T extends AchievementMilestoneUpsertArgs>(args: SelectSubset<T, AchievementMilestoneUpsertArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more AchievementMilestones that matches the filter.
     * @param {AchievementMilestoneFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const achievementMilestone = await prisma.achievementMilestone.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AchievementMilestoneFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AchievementMilestone.
     * @param {AchievementMilestoneAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const achievementMilestone = await prisma.achievementMilestone.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AchievementMilestoneAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AchievementMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementMilestoneCountArgs} args - Arguments to filter AchievementMilestones to count.
     * @example
     * // Count the number of AchievementMilestones
     * const count = await prisma.achievementMilestone.count({
     *   where: {
     *     // ... the filter for the AchievementMilestones we want to count
     *   }
     * })
    **/
    count<T extends AchievementMilestoneCountArgs>(
      args?: Subset<T, AchievementMilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementMilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AchievementMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementMilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementMilestoneAggregateArgs>(args: Subset<T, AchievementMilestoneAggregateArgs>): Prisma.PrismaPromise<GetAchievementMilestoneAggregateType<T>>

    /**
     * Group by AchievementMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementMilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementMilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementMilestoneGroupByArgs['orderBy'] }
        : { orderBy?: AchievementMilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementMilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AchievementMilestone model
   */
  readonly fields: AchievementMilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AchievementMilestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementMilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends AchievementCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementCategoryDefaultArgs<ExtArgs>>): Prisma__AchievementCategoryClient<$Result.GetResult<Prisma.$AchievementCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userAchievements<T extends AchievementMilestone$userAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, AchievementMilestone$userAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AchievementMilestone model
   */ 
  interface AchievementMilestoneFieldRefs {
    readonly id: FieldRef<"AchievementMilestone", 'String'>
    readonly categoryId: FieldRef<"AchievementMilestone", 'String'>
    readonly name: FieldRef<"AchievementMilestone", 'String'>
    readonly icon: FieldRef<"AchievementMilestone", 'String'>
    readonly unlocked: FieldRef<"AchievementMilestone", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AchievementMilestone findUnique
   */
  export type AchievementMilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AchievementMilestone to fetch.
     */
    where: AchievementMilestoneWhereUniqueInput
  }

  /**
   * AchievementMilestone findUniqueOrThrow
   */
  export type AchievementMilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AchievementMilestone to fetch.
     */
    where: AchievementMilestoneWhereUniqueInput
  }

  /**
   * AchievementMilestone findFirst
   */
  export type AchievementMilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AchievementMilestone to fetch.
     */
    where?: AchievementMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementMilestones to fetch.
     */
    orderBy?: AchievementMilestoneOrderByWithRelationInput | AchievementMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementMilestones.
     */
    cursor?: AchievementMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementMilestones.
     */
    distinct?: AchievementMilestoneScalarFieldEnum | AchievementMilestoneScalarFieldEnum[]
  }

  /**
   * AchievementMilestone findFirstOrThrow
   */
  export type AchievementMilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AchievementMilestone to fetch.
     */
    where?: AchievementMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementMilestones to fetch.
     */
    orderBy?: AchievementMilestoneOrderByWithRelationInput | AchievementMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementMilestones.
     */
    cursor?: AchievementMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementMilestones.
     */
    distinct?: AchievementMilestoneScalarFieldEnum | AchievementMilestoneScalarFieldEnum[]
  }

  /**
   * AchievementMilestone findMany
   */
  export type AchievementMilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which AchievementMilestones to fetch.
     */
    where?: AchievementMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementMilestones to fetch.
     */
    orderBy?: AchievementMilestoneOrderByWithRelationInput | AchievementMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AchievementMilestones.
     */
    cursor?: AchievementMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementMilestones.
     */
    skip?: number
    distinct?: AchievementMilestoneScalarFieldEnum | AchievementMilestoneScalarFieldEnum[]
  }

  /**
   * AchievementMilestone create
   */
  export type AchievementMilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a AchievementMilestone.
     */
    data: XOR<AchievementMilestoneCreateInput, AchievementMilestoneUncheckedCreateInput>
  }

  /**
   * AchievementMilestone createMany
   */
  export type AchievementMilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AchievementMilestones.
     */
    data: AchievementMilestoneCreateManyInput | AchievementMilestoneCreateManyInput[]
  }

  /**
   * AchievementMilestone update
   */
  export type AchievementMilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a AchievementMilestone.
     */
    data: XOR<AchievementMilestoneUpdateInput, AchievementMilestoneUncheckedUpdateInput>
    /**
     * Choose, which AchievementMilestone to update.
     */
    where: AchievementMilestoneWhereUniqueInput
  }

  /**
   * AchievementMilestone updateMany
   */
  export type AchievementMilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AchievementMilestones.
     */
    data: XOR<AchievementMilestoneUpdateManyMutationInput, AchievementMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which AchievementMilestones to update
     */
    where?: AchievementMilestoneWhereInput
  }

  /**
   * AchievementMilestone upsert
   */
  export type AchievementMilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the AchievementMilestone to update in case it exists.
     */
    where: AchievementMilestoneWhereUniqueInput
    /**
     * In case the AchievementMilestone found by the `where` argument doesn't exist, create a new AchievementMilestone with this data.
     */
    create: XOR<AchievementMilestoneCreateInput, AchievementMilestoneUncheckedCreateInput>
    /**
     * In case the AchievementMilestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementMilestoneUpdateInput, AchievementMilestoneUncheckedUpdateInput>
  }

  /**
   * AchievementMilestone delete
   */
  export type AchievementMilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
    /**
     * Filter which AchievementMilestone to delete.
     */
    where: AchievementMilestoneWhereUniqueInput
  }

  /**
   * AchievementMilestone deleteMany
   */
  export type AchievementMilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementMilestones to delete
     */
    where?: AchievementMilestoneWhereInput
  }

  /**
   * AchievementMilestone findRaw
   */
  export type AchievementMilestoneFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AchievementMilestone aggregateRaw
   */
  export type AchievementMilestoneAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AchievementMilestone.userAchievements
   */
  export type AchievementMilestone$userAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * AchievementMilestone without action
   */
  export type AchievementMilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementMilestone
     */
    select?: AchievementMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementMilestoneInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    milestoneId: string | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    milestoneId: string | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    milestoneId: number
    _all: number
  }


  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    milestoneId?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    milestoneId?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    milestoneId?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    milestoneId: string
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    milestoneId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    milestone?: boolean | AchievementMilestoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>


  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    milestoneId?: boolean
  }

  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    milestone?: boolean | AchievementMilestoneDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      milestone: Prisma.$AchievementMilestonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      milestoneId: string
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * @param {UserAchievementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userAchievement = await prisma.userAchievement.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserAchievementFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserAchievement.
     * @param {UserAchievementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userAchievement = await prisma.userAchievement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAchievementAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    milestone<T extends AchievementMilestoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementMilestoneDefaultArgs<ExtArgs>>): Prisma__AchievementMilestoneClient<$Result.GetResult<Prisma.$AchievementMilestonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */ 
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly milestoneId: FieldRef<"UserAchievement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement findRaw
   */
  export type UserAchievementFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserAchievement aggregateRaw
   */
  export type UserAchievementAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model DailyReward
   */

  export type AggregateDailyReward = {
    _count: DailyRewardCountAggregateOutputType | null
    _avg: DailyRewardAvgAggregateOutputType | null
    _sum: DailyRewardSumAggregateOutputType | null
    _min: DailyRewardMinAggregateOutputType | null
    _max: DailyRewardMaxAggregateOutputType | null
  }

  export type DailyRewardAvgAggregateOutputType = {
    day: number | null
    coins: number | null
  }

  export type DailyRewardSumAggregateOutputType = {
    day: number | null
    coins: number | null
  }

  export type DailyRewardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    day: number | null
    coins: number | null
    createdAt: Date | null
  }

  export type DailyRewardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    day: number | null
    coins: number | null
    createdAt: Date | null
  }

  export type DailyRewardCountAggregateOutputType = {
    id: number
    userId: number
    day: number
    coins: number
    createdAt: number
    _all: number
  }


  export type DailyRewardAvgAggregateInputType = {
    day?: true
    coins?: true
  }

  export type DailyRewardSumAggregateInputType = {
    day?: true
    coins?: true
  }

  export type DailyRewardMinAggregateInputType = {
    id?: true
    userId?: true
    day?: true
    coins?: true
    createdAt?: true
  }

  export type DailyRewardMaxAggregateInputType = {
    id?: true
    userId?: true
    day?: true
    coins?: true
    createdAt?: true
  }

  export type DailyRewardCountAggregateInputType = {
    id?: true
    userId?: true
    day?: true
    coins?: true
    createdAt?: true
    _all?: true
  }

  export type DailyRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyReward to aggregate.
     */
    where?: DailyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewards to fetch.
     */
    orderBy?: DailyRewardOrderByWithRelationInput | DailyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyRewards
    **/
    _count?: true | DailyRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyRewardMaxAggregateInputType
  }

  export type GetDailyRewardAggregateType<T extends DailyRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyReward[P]>
      : GetScalarType<T[P], AggregateDailyReward[P]>
  }




  export type DailyRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRewardWhereInput
    orderBy?: DailyRewardOrderByWithAggregationInput | DailyRewardOrderByWithAggregationInput[]
    by: DailyRewardScalarFieldEnum[] | DailyRewardScalarFieldEnum
    having?: DailyRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyRewardCountAggregateInputType | true
    _avg?: DailyRewardAvgAggregateInputType
    _sum?: DailyRewardSumAggregateInputType
    _min?: DailyRewardMinAggregateInputType
    _max?: DailyRewardMaxAggregateInputType
  }

  export type DailyRewardGroupByOutputType = {
    id: string
    userId: string
    day: number
    coins: number
    createdAt: Date
    _count: DailyRewardCountAggregateOutputType | null
    _avg: DailyRewardAvgAggregateOutputType | null
    _sum: DailyRewardSumAggregateOutputType | null
    _min: DailyRewardMinAggregateOutputType | null
    _max: DailyRewardMaxAggregateOutputType | null
  }

  type GetDailyRewardGroupByPayload<T extends DailyRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyRewardGroupByOutputType[P]>
            : GetScalarType<T[P], DailyRewardGroupByOutputType[P]>
        }
      >
    >


  export type DailyRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    day?: boolean
    coins?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyReward"]>


  export type DailyRewardSelectScalar = {
    id?: boolean
    userId?: boolean
    day?: boolean
    coins?: boolean
    createdAt?: boolean
  }

  export type DailyRewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyReward"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      day: number
      coins: number
      createdAt: Date
    }, ExtArgs["result"]["dailyReward"]>
    composites: {}
  }

  type DailyRewardGetPayload<S extends boolean | null | undefined | DailyRewardDefaultArgs> = $Result.GetResult<Prisma.$DailyRewardPayload, S>

  type DailyRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyRewardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyRewardCountAggregateInputType | true
    }

  export interface DailyRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyReward'], meta: { name: 'DailyReward' } }
    /**
     * Find zero or one DailyReward that matches the filter.
     * @param {DailyRewardFindUniqueArgs} args - Arguments to find a DailyReward
     * @example
     * // Get one DailyReward
     * const dailyReward = await prisma.dailyReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyRewardFindUniqueArgs>(args: SelectSubset<T, DailyRewardFindUniqueArgs<ExtArgs>>): Prisma__DailyRewardClient<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyReward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyRewardFindUniqueOrThrowArgs} args - Arguments to find a DailyReward
     * @example
     * // Get one DailyReward
     * const dailyReward = await prisma.dailyReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyRewardClient<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardFindFirstArgs} args - Arguments to find a DailyReward
     * @example
     * // Get one DailyReward
     * const dailyReward = await prisma.dailyReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyRewardFindFirstArgs>(args?: SelectSubset<T, DailyRewardFindFirstArgs<ExtArgs>>): Prisma__DailyRewardClient<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardFindFirstOrThrowArgs} args - Arguments to find a DailyReward
     * @example
     * // Get one DailyReward
     * const dailyReward = await prisma.dailyReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyRewardClient<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyRewards
     * const dailyRewards = await prisma.dailyReward.findMany()
     * 
     * // Get first 10 DailyRewards
     * const dailyRewards = await prisma.dailyReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyRewardWithIdOnly = await prisma.dailyReward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyRewardFindManyArgs>(args?: SelectSubset<T, DailyRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyReward.
     * @param {DailyRewardCreateArgs} args - Arguments to create a DailyReward.
     * @example
     * // Create one DailyReward
     * const DailyReward = await prisma.dailyReward.create({
     *   data: {
     *     // ... data to create a DailyReward
     *   }
     * })
     * 
     */
    create<T extends DailyRewardCreateArgs>(args: SelectSubset<T, DailyRewardCreateArgs<ExtArgs>>): Prisma__DailyRewardClient<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyRewards.
     * @param {DailyRewardCreateManyArgs} args - Arguments to create many DailyRewards.
     * @example
     * // Create many DailyRewards
     * const dailyReward = await prisma.dailyReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyRewardCreateManyArgs>(args?: SelectSubset<T, DailyRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DailyReward.
     * @param {DailyRewardDeleteArgs} args - Arguments to delete one DailyReward.
     * @example
     * // Delete one DailyReward
     * const DailyReward = await prisma.dailyReward.delete({
     *   where: {
     *     // ... filter to delete one DailyReward
     *   }
     * })
     * 
     */
    delete<T extends DailyRewardDeleteArgs>(args: SelectSubset<T, DailyRewardDeleteArgs<ExtArgs>>): Prisma__DailyRewardClient<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyReward.
     * @param {DailyRewardUpdateArgs} args - Arguments to update one DailyReward.
     * @example
     * // Update one DailyReward
     * const dailyReward = await prisma.dailyReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyRewardUpdateArgs>(args: SelectSubset<T, DailyRewardUpdateArgs<ExtArgs>>): Prisma__DailyRewardClient<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyRewards.
     * @param {DailyRewardDeleteManyArgs} args - Arguments to filter DailyRewards to delete.
     * @example
     * // Delete a few DailyRewards
     * const { count } = await prisma.dailyReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyRewardDeleteManyArgs>(args?: SelectSubset<T, DailyRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyRewards
     * const dailyReward = await prisma.dailyReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyRewardUpdateManyArgs>(args: SelectSubset<T, DailyRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyReward.
     * @param {DailyRewardUpsertArgs} args - Arguments to update or create a DailyReward.
     * @example
     * // Update or create a DailyReward
     * const dailyReward = await prisma.dailyReward.upsert({
     *   create: {
     *     // ... data to create a DailyReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyReward we want to update
     *   }
     * })
     */
    upsert<T extends DailyRewardUpsertArgs>(args: SelectSubset<T, DailyRewardUpsertArgs<ExtArgs>>): Prisma__DailyRewardClient<$Result.GetResult<Prisma.$DailyRewardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DailyRewards that matches the filter.
     * @param {DailyRewardFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dailyReward = await prisma.dailyReward.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DailyRewardFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DailyReward.
     * @param {DailyRewardAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dailyReward = await prisma.dailyReward.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DailyRewardAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DailyRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardCountArgs} args - Arguments to filter DailyRewards to count.
     * @example
     * // Count the number of DailyRewards
     * const count = await prisma.dailyReward.count({
     *   where: {
     *     // ... the filter for the DailyRewards we want to count
     *   }
     * })
    **/
    count<T extends DailyRewardCountArgs>(
      args?: Subset<T, DailyRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyRewardAggregateArgs>(args: Subset<T, DailyRewardAggregateArgs>): Prisma.PrismaPromise<GetDailyRewardAggregateType<T>>

    /**
     * Group by DailyReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyRewardGroupByArgs['orderBy'] }
        : { orderBy?: DailyRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyReward model
   */
  readonly fields: DailyRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyReward model
   */ 
  interface DailyRewardFieldRefs {
    readonly id: FieldRef<"DailyReward", 'String'>
    readonly userId: FieldRef<"DailyReward", 'String'>
    readonly day: FieldRef<"DailyReward", 'Int'>
    readonly coins: FieldRef<"DailyReward", 'Int'>
    readonly createdAt: FieldRef<"DailyReward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyReward findUnique
   */
  export type DailyRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * Filter, which DailyReward to fetch.
     */
    where: DailyRewardWhereUniqueInput
  }

  /**
   * DailyReward findUniqueOrThrow
   */
  export type DailyRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * Filter, which DailyReward to fetch.
     */
    where: DailyRewardWhereUniqueInput
  }

  /**
   * DailyReward findFirst
   */
  export type DailyRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * Filter, which DailyReward to fetch.
     */
    where?: DailyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewards to fetch.
     */
    orderBy?: DailyRewardOrderByWithRelationInput | DailyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRewards.
     */
    cursor?: DailyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRewards.
     */
    distinct?: DailyRewardScalarFieldEnum | DailyRewardScalarFieldEnum[]
  }

  /**
   * DailyReward findFirstOrThrow
   */
  export type DailyRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * Filter, which DailyReward to fetch.
     */
    where?: DailyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewards to fetch.
     */
    orderBy?: DailyRewardOrderByWithRelationInput | DailyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRewards.
     */
    cursor?: DailyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRewards.
     */
    distinct?: DailyRewardScalarFieldEnum | DailyRewardScalarFieldEnum[]
  }

  /**
   * DailyReward findMany
   */
  export type DailyRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewards to fetch.
     */
    where?: DailyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewards to fetch.
     */
    orderBy?: DailyRewardOrderByWithRelationInput | DailyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyRewards.
     */
    cursor?: DailyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewards.
     */
    skip?: number
    distinct?: DailyRewardScalarFieldEnum | DailyRewardScalarFieldEnum[]
  }

  /**
   * DailyReward create
   */
  export type DailyRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyReward.
     */
    data: XOR<DailyRewardCreateInput, DailyRewardUncheckedCreateInput>
  }

  /**
   * DailyReward createMany
   */
  export type DailyRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyRewards.
     */
    data: DailyRewardCreateManyInput | DailyRewardCreateManyInput[]
  }

  /**
   * DailyReward update
   */
  export type DailyRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyReward.
     */
    data: XOR<DailyRewardUpdateInput, DailyRewardUncheckedUpdateInput>
    /**
     * Choose, which DailyReward to update.
     */
    where: DailyRewardWhereUniqueInput
  }

  /**
   * DailyReward updateMany
   */
  export type DailyRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyRewards.
     */
    data: XOR<DailyRewardUpdateManyMutationInput, DailyRewardUncheckedUpdateManyInput>
    /**
     * Filter which DailyRewards to update
     */
    where?: DailyRewardWhereInput
  }

  /**
   * DailyReward upsert
   */
  export type DailyRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyReward to update in case it exists.
     */
    where: DailyRewardWhereUniqueInput
    /**
     * In case the DailyReward found by the `where` argument doesn't exist, create a new DailyReward with this data.
     */
    create: XOR<DailyRewardCreateInput, DailyRewardUncheckedCreateInput>
    /**
     * In case the DailyReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyRewardUpdateInput, DailyRewardUncheckedUpdateInput>
  }

  /**
   * DailyReward delete
   */
  export type DailyRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
    /**
     * Filter which DailyReward to delete.
     */
    where: DailyRewardWhereUniqueInput
  }

  /**
   * DailyReward deleteMany
   */
  export type DailyRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRewards to delete
     */
    where?: DailyRewardWhereInput
  }

  /**
   * DailyReward findRaw
   */
  export type DailyRewardFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DailyReward aggregateRaw
   */
  export type DailyRewardAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DailyReward without action
   */
  export type DailyRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardInclude<ExtArgs> | null
  }


  /**
   * Model Card
   */

  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    baseCost: number | null
    basePPH: number | null
    baseLevel: number | null
    requiredCardLevel: number | null
  }

  export type CardSumAggregateOutputType = {
    baseCost: number | null
    basePPH: number | null
    baseLevel: number | null
    requiredCardLevel: number | null
  }

  export type CardMinAggregateOutputType = {
    id: string | null
    title: string | null
    image: string | null
    baseCost: number | null
    basePPH: number | null
    baseLevel: number | null
    category: string | null
    discription: string | null
    requiredCardId: string | null
    requiredCardLevel: number | null
    requiredCardTitle: string | null
  }

  export type CardMaxAggregateOutputType = {
    id: string | null
    title: string | null
    image: string | null
    baseCost: number | null
    basePPH: number | null
    baseLevel: number | null
    category: string | null
    discription: string | null
    requiredCardId: string | null
    requiredCardLevel: number | null
    requiredCardTitle: string | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    title: number
    image: number
    baseCost: number
    basePPH: number
    baseLevel: number
    category: number
    discription: number
    requiredCardId: number
    requiredCardLevel: number
    requiredCardTitle: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    baseCost?: true
    basePPH?: true
    baseLevel?: true
    requiredCardLevel?: true
  }

  export type CardSumAggregateInputType = {
    baseCost?: true
    basePPH?: true
    baseLevel?: true
    requiredCardLevel?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    title?: true
    image?: true
    baseCost?: true
    basePPH?: true
    baseLevel?: true
    category?: true
    discription?: true
    requiredCardId?: true
    requiredCardLevel?: true
    requiredCardTitle?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    title?: true
    image?: true
    baseCost?: true
    basePPH?: true
    baseLevel?: true
    category?: true
    discription?: true
    requiredCardId?: true
    requiredCardLevel?: true
    requiredCardTitle?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    title?: true
    image?: true
    baseCost?: true
    basePPH?: true
    baseLevel?: true
    category?: true
    discription?: true
    requiredCardId?: true
    requiredCardLevel?: true
    requiredCardTitle?: true
    _all?: true
  }

  export type CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Card to aggregate.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
    orderBy?: CardOrderByWithAggregationInput | CardOrderByWithAggregationInput[]
    by: CardScalarFieldEnum[] | CardScalarFieldEnum
    having?: CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }

  export type CardGroupByOutputType = {
    id: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel: number
    category: string
    discription: string | null
    requiredCardId: string | null
    requiredCardLevel: number | null
    requiredCardTitle: string | null
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    baseCost?: boolean
    basePPH?: boolean
    baseLevel?: boolean
    category?: boolean
    discription?: boolean
    requiredCardId?: boolean
    requiredCardLevel?: boolean
    requiredCardTitle?: boolean
    users?: boolean | Card$usersArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["card"]>


  export type CardSelectScalar = {
    id?: boolean
    title?: boolean
    image?: boolean
    baseCost?: boolean
    basePPH?: boolean
    baseLevel?: boolean
    category?: boolean
    discription?: boolean
    requiredCardId?: boolean
    requiredCardLevel?: boolean
    requiredCardTitle?: boolean
  }

  export type CardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Card$usersArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Card"
    objects: {
      users: Prisma.$UserCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      image: string
      baseCost: number
      basePPH: number
      baseLevel: number
      category: string
      discription: string | null
      requiredCardId: string | null
      requiredCardLevel: number | null
      requiredCardTitle: string | null
    }, ExtArgs["result"]["card"]>
    composites: {}
  }

  type CardGetPayload<S extends boolean | null | undefined | CardDefaultArgs> = $Result.GetResult<Prisma.$CardPayload, S>

  type CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CardCountAggregateInputType | true
    }

  export interface CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Card'], meta: { name: 'Card' } }
    /**
     * Find zero or one Card that matches the filter.
     * @param {CardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardFindUniqueArgs>(args: SelectSubset<T, CardFindUniqueArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Card that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardFindUniqueOrThrowArgs>(args: SelectSubset<T, CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardFindFirstArgs>(args?: SelectSubset<T, CardFindFirstArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardFindFirstOrThrowArgs>(args?: SelectSubset<T, CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardFindManyArgs>(args?: SelectSubset<T, CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Card.
     * @param {CardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
     */
    create<T extends CardCreateArgs>(args: SelectSubset<T, CardCreateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cards.
     * @param {CardCreateManyArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardCreateManyArgs>(args?: SelectSubset<T, CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Card.
     * @param {CardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
     */
    delete<T extends CardDeleteArgs>(args: SelectSubset<T, CardDeleteArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Card.
     * @param {CardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardUpdateArgs>(args: SelectSubset<T, CardUpdateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cards.
     * @param {CardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardDeleteManyArgs>(args?: SelectSubset<T, CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardUpdateManyArgs>(args: SelectSubset<T, CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Card.
     * @param {CardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
     */
    upsert<T extends CardUpsertArgs>(args: SelectSubset<T, CardUpsertArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Cards that matches the filter.
     * @param {CardFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const card = await prisma.card.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CardFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Card.
     * @param {CardAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const card = await prisma.card.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CardAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends CardCountArgs>(
      args?: Subset<T, CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): Prisma.PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Card model
   */
  readonly fields: CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Card$usersArgs<ExtArgs> = {}>(args?: Subset<T, Card$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Card model
   */ 
  interface CardFieldRefs {
    readonly id: FieldRef<"Card", 'String'>
    readonly title: FieldRef<"Card", 'String'>
    readonly image: FieldRef<"Card", 'String'>
    readonly baseCost: FieldRef<"Card", 'Float'>
    readonly basePPH: FieldRef<"Card", 'Float'>
    readonly baseLevel: FieldRef<"Card", 'Int'>
    readonly category: FieldRef<"Card", 'String'>
    readonly discription: FieldRef<"Card", 'String'>
    readonly requiredCardId: FieldRef<"Card", 'String'>
    readonly requiredCardLevel: FieldRef<"Card", 'Int'>
    readonly requiredCardTitle: FieldRef<"Card", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Card findUnique
   */
  export type CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findUniqueOrThrow
   */
  export type CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findFirst
   */
  export type CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findFirstOrThrow
   */
  export type CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findMany
   */
  export type CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card create
   */
  export type CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to create a Card.
     */
    data: XOR<CardCreateInput, CardUncheckedCreateInput>
  }

  /**
   * Card createMany
   */
  export type CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
  }

  /**
   * Card update
   */
  export type CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to update a Card.
     */
    data: XOR<CardUpdateInput, CardUncheckedUpdateInput>
    /**
     * Choose, which Card to update.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card updateMany
   */
  export type CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
  }

  /**
   * Card upsert
   */
  export type CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The filter to search for the Card to update in case it exists.
     */
    where: CardWhereUniqueInput
    /**
     * In case the Card found by the `where` argument doesn't exist, create a new Card with this data.
     */
    create: XOR<CardCreateInput, CardUncheckedCreateInput>
    /**
     * In case the Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardUpdateInput, CardUncheckedUpdateInput>
  }

  /**
   * Card delete
   */
  export type CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter which Card to delete.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card deleteMany
   */
  export type CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to delete
     */
    where?: CardWhereInput
  }

  /**
   * Card findRaw
   */
  export type CardFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Card aggregateRaw
   */
  export type CardAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Card.users
   */
  export type Card$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    where?: UserCardWhereInput
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    cursor?: UserCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * Card without action
   */
  export type CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
  }


  /**
   * Model UserCard
   */

  export type AggregateUserCard = {
    _count: UserCardCountAggregateOutputType | null
    _avg: UserCardAvgAggregateOutputType | null
    _sum: UserCardSumAggregateOutputType | null
    _min: UserCardMinAggregateOutputType | null
    _max: UserCardMaxAggregateOutputType | null
  }

  export type UserCardAvgAggregateOutputType = {
    baseCost: number | null
    basePPH: number | null
    baseLevel: number | null
  }

  export type UserCardSumAggregateOutputType = {
    baseCost: number | null
    basePPH: number | null
    baseLevel: number | null
  }

  export type UserCardMinAggregateOutputType = {
    id: string | null
    title: string | null
    image: string | null
    baseCost: number | null
    basePPH: number | null
    baseLevel: number | null
    userId: string | null
    cardId: string | null
    category: string | null
    discription: string | null
  }

  export type UserCardMaxAggregateOutputType = {
    id: string | null
    title: string | null
    image: string | null
    baseCost: number | null
    basePPH: number | null
    baseLevel: number | null
    userId: string | null
    cardId: string | null
    category: string | null
    discription: string | null
  }

  export type UserCardCountAggregateOutputType = {
    id: number
    title: number
    image: number
    baseCost: number
    basePPH: number
    baseLevel: number
    userId: number
    cardId: number
    category: number
    discription: number
    _all: number
  }


  export type UserCardAvgAggregateInputType = {
    baseCost?: true
    basePPH?: true
    baseLevel?: true
  }

  export type UserCardSumAggregateInputType = {
    baseCost?: true
    basePPH?: true
    baseLevel?: true
  }

  export type UserCardMinAggregateInputType = {
    id?: true
    title?: true
    image?: true
    baseCost?: true
    basePPH?: true
    baseLevel?: true
    userId?: true
    cardId?: true
    category?: true
    discription?: true
  }

  export type UserCardMaxAggregateInputType = {
    id?: true
    title?: true
    image?: true
    baseCost?: true
    basePPH?: true
    baseLevel?: true
    userId?: true
    cardId?: true
    category?: true
    discription?: true
  }

  export type UserCardCountAggregateInputType = {
    id?: true
    title?: true
    image?: true
    baseCost?: true
    basePPH?: true
    baseLevel?: true
    userId?: true
    cardId?: true
    category?: true
    discription?: true
    _all?: true
  }

  export type UserCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCard to aggregate.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCards
    **/
    _count?: true | UserCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCardMaxAggregateInputType
  }

  export type GetUserCardAggregateType<T extends UserCardAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCard[P]>
      : GetScalarType<T[P], AggregateUserCard[P]>
  }




  export type UserCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCardWhereInput
    orderBy?: UserCardOrderByWithAggregationInput | UserCardOrderByWithAggregationInput[]
    by: UserCardScalarFieldEnum[] | UserCardScalarFieldEnum
    having?: UserCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCardCountAggregateInputType | true
    _avg?: UserCardAvgAggregateInputType
    _sum?: UserCardSumAggregateInputType
    _min?: UserCardMinAggregateInputType
    _max?: UserCardMaxAggregateInputType
  }

  export type UserCardGroupByOutputType = {
    id: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel: number
    userId: string
    cardId: string
    category: string
    discription: string | null
    _count: UserCardCountAggregateOutputType | null
    _avg: UserCardAvgAggregateOutputType | null
    _sum: UserCardSumAggregateOutputType | null
    _min: UserCardMinAggregateOutputType | null
    _max: UserCardMaxAggregateOutputType | null
  }

  type GetUserCardGroupByPayload<T extends UserCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCardGroupByOutputType[P]>
            : GetScalarType<T[P], UserCardGroupByOutputType[P]>
        }
      >
    >


  export type UserCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    baseCost?: boolean
    basePPH?: boolean
    baseLevel?: boolean
    userId?: boolean
    cardId?: boolean
    category?: boolean
    discription?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCard"]>


  export type UserCardSelectScalar = {
    id?: boolean
    title?: boolean
    image?: boolean
    baseCost?: boolean
    basePPH?: boolean
    baseLevel?: boolean
    userId?: boolean
    cardId?: boolean
    category?: boolean
    discription?: boolean
  }

  export type UserCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }

  export type $UserCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      card: Prisma.$CardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      image: string
      baseCost: number
      basePPH: number
      baseLevel: number
      userId: string
      cardId: string
      category: string
      discription: string | null
    }, ExtArgs["result"]["userCard"]>
    composites: {}
  }

  type UserCardGetPayload<S extends boolean | null | undefined | UserCardDefaultArgs> = $Result.GetResult<Prisma.$UserCardPayload, S>

  type UserCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCardCountAggregateInputType | true
    }

  export interface UserCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCard'], meta: { name: 'UserCard' } }
    /**
     * Find zero or one UserCard that matches the filter.
     * @param {UserCardFindUniqueArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCardFindUniqueArgs>(args: SelectSubset<T, UserCardFindUniqueArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserCardFindUniqueOrThrowArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCardFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindFirstArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCardFindFirstArgs>(args?: SelectSubset<T, UserCardFindFirstArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindFirstOrThrowArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCardFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCards
     * const userCards = await prisma.userCard.findMany()
     * 
     * // Get first 10 UserCards
     * const userCards = await prisma.userCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCardWithIdOnly = await prisma.userCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCardFindManyArgs>(args?: SelectSubset<T, UserCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserCard.
     * @param {UserCardCreateArgs} args - Arguments to create a UserCard.
     * @example
     * // Create one UserCard
     * const UserCard = await prisma.userCard.create({
     *   data: {
     *     // ... data to create a UserCard
     *   }
     * })
     * 
     */
    create<T extends UserCardCreateArgs>(args: SelectSubset<T, UserCardCreateArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserCards.
     * @param {UserCardCreateManyArgs} args - Arguments to create many UserCards.
     * @example
     * // Create many UserCards
     * const userCard = await prisma.userCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCardCreateManyArgs>(args?: SelectSubset<T, UserCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserCard.
     * @param {UserCardDeleteArgs} args - Arguments to delete one UserCard.
     * @example
     * // Delete one UserCard
     * const UserCard = await prisma.userCard.delete({
     *   where: {
     *     // ... filter to delete one UserCard
     *   }
     * })
     * 
     */
    delete<T extends UserCardDeleteArgs>(args: SelectSubset<T, UserCardDeleteArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserCard.
     * @param {UserCardUpdateArgs} args - Arguments to update one UserCard.
     * @example
     * // Update one UserCard
     * const userCard = await prisma.userCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCardUpdateArgs>(args: SelectSubset<T, UserCardUpdateArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserCards.
     * @param {UserCardDeleteManyArgs} args - Arguments to filter UserCards to delete.
     * @example
     * // Delete a few UserCards
     * const { count } = await prisma.userCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCardDeleteManyArgs>(args?: SelectSubset<T, UserCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCards
     * const userCard = await prisma.userCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCardUpdateManyArgs>(args: SelectSubset<T, UserCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCard.
     * @param {UserCardUpsertArgs} args - Arguments to update or create a UserCard.
     * @example
     * // Update or create a UserCard
     * const userCard = await prisma.userCard.upsert({
     *   create: {
     *     // ... data to create a UserCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCard we want to update
     *   }
     * })
     */
    upsert<T extends UserCardUpsertArgs>(args: SelectSubset<T, UserCardUpsertArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more UserCards that matches the filter.
     * @param {UserCardFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userCard = await prisma.userCard.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserCardFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserCard.
     * @param {UserCardAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userCard = await prisma.userCard.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserCardAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardCountArgs} args - Arguments to filter UserCards to count.
     * @example
     * // Count the number of UserCards
     * const count = await prisma.userCard.count({
     *   where: {
     *     // ... the filter for the UserCards we want to count
     *   }
     * })
    **/
    count<T extends UserCardCountArgs>(
      args?: Subset<T, UserCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCardAggregateArgs>(args: Subset<T, UserCardAggregateArgs>): Prisma.PrismaPromise<GetUserCardAggregateType<T>>

    /**
     * Group by UserCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCardGroupByArgs['orderBy'] }
        : { orderBy?: UserCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCard model
   */
  readonly fields: UserCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCard model
   */ 
  interface UserCardFieldRefs {
    readonly id: FieldRef<"UserCard", 'String'>
    readonly title: FieldRef<"UserCard", 'String'>
    readonly image: FieldRef<"UserCard", 'String'>
    readonly baseCost: FieldRef<"UserCard", 'Float'>
    readonly basePPH: FieldRef<"UserCard", 'Float'>
    readonly baseLevel: FieldRef<"UserCard", 'Int'>
    readonly userId: FieldRef<"UserCard", 'String'>
    readonly cardId: FieldRef<"UserCard", 'String'>
    readonly category: FieldRef<"UserCard", 'String'>
    readonly discription: FieldRef<"UserCard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserCard findUnique
   */
  export type UserCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard findUniqueOrThrow
   */
  export type UserCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard findFirst
   */
  export type UserCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCards.
     */
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard findFirstOrThrow
   */
  export type UserCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCards.
     */
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard findMany
   */
  export type UserCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCards to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard create
   */
  export type UserCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCard.
     */
    data: XOR<UserCardCreateInput, UserCardUncheckedCreateInput>
  }

  /**
   * UserCard createMany
   */
  export type UserCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCards.
     */
    data: UserCardCreateManyInput | UserCardCreateManyInput[]
  }

  /**
   * UserCard update
   */
  export type UserCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCard.
     */
    data: XOR<UserCardUpdateInput, UserCardUncheckedUpdateInput>
    /**
     * Choose, which UserCard to update.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard updateMany
   */
  export type UserCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCards.
     */
    data: XOR<UserCardUpdateManyMutationInput, UserCardUncheckedUpdateManyInput>
    /**
     * Filter which UserCards to update
     */
    where?: UserCardWhereInput
  }

  /**
   * UserCard upsert
   */
  export type UserCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCard to update in case it exists.
     */
    where: UserCardWhereUniqueInput
    /**
     * In case the UserCard found by the `where` argument doesn't exist, create a new UserCard with this data.
     */
    create: XOR<UserCardCreateInput, UserCardUncheckedCreateInput>
    /**
     * In case the UserCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCardUpdateInput, UserCardUncheckedUpdateInput>
  }

  /**
   * UserCard delete
   */
  export type UserCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter which UserCard to delete.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard deleteMany
   */
  export type UserCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCards to delete
     */
    where?: UserCardWhereInput
  }

  /**
   * UserCard findRaw
   */
  export type UserCardFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserCard aggregateRaw
   */
  export type UserCardAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserCard without action
   */
  export type UserCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>


  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AccountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>


  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>


  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * @param {VerificationTokenFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const verificationToken = await prisma.verificationToken.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: VerificationTokenFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VerificationToken.
     * @param {VerificationTokenAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const verificationToken = await prisma.verificationToken.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VerificationTokenAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken findRaw
   */
  export type VerificationTokenFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VerificationToken aggregateRaw
   */
  export type VerificationTokenAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model Authenticator
   */

  export type AggregateAuthenticator = {
    _count: AuthenticatorCountAggregateOutputType | null
    _avg: AuthenticatorAvgAggregateOutputType | null
    _sum: AuthenticatorSumAggregateOutputType | null
    _min: AuthenticatorMinAggregateOutputType | null
    _max: AuthenticatorMaxAggregateOutputType | null
  }

  export type AuthenticatorAvgAggregateOutputType = {
    counter: number | null
  }

  export type AuthenticatorSumAggregateOutputType = {
    counter: number | null
  }

  export type AuthenticatorMinAggregateOutputType = {
    credentialID: string | null
    userId: string | null
    providerAccountId: string | null
    credentialPublicKey: string | null
    counter: number | null
    credentialDeviceType: string | null
    credentialBackedUp: boolean | null
    transports: string | null
  }

  export type AuthenticatorMaxAggregateOutputType = {
    credentialID: string | null
    userId: string | null
    providerAccountId: string | null
    credentialPublicKey: string | null
    counter: number | null
    credentialDeviceType: string | null
    credentialBackedUp: boolean | null
    transports: string | null
  }

  export type AuthenticatorCountAggregateOutputType = {
    credentialID: number
    userId: number
    providerAccountId: number
    credentialPublicKey: number
    counter: number
    credentialDeviceType: number
    credentialBackedUp: number
    transports: number
    _all: number
  }


  export type AuthenticatorAvgAggregateInputType = {
    counter?: true
  }

  export type AuthenticatorSumAggregateInputType = {
    counter?: true
  }

  export type AuthenticatorMinAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
  }

  export type AuthenticatorMaxAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
  }

  export type AuthenticatorCountAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
    _all?: true
  }

  export type AuthenticatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authenticator to aggregate.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authenticators
    **/
    _count?: true | AuthenticatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthenticatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthenticatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthenticatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthenticatorMaxAggregateInputType
  }

  export type GetAuthenticatorAggregateType<T extends AuthenticatorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthenticator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthenticator[P]>
      : GetScalarType<T[P], AggregateAuthenticator[P]>
  }




  export type AuthenticatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthenticatorWhereInput
    orderBy?: AuthenticatorOrderByWithAggregationInput | AuthenticatorOrderByWithAggregationInput[]
    by: AuthenticatorScalarFieldEnum[] | AuthenticatorScalarFieldEnum
    having?: AuthenticatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthenticatorCountAggregateInputType | true
    _avg?: AuthenticatorAvgAggregateInputType
    _sum?: AuthenticatorSumAggregateInputType
    _min?: AuthenticatorMinAggregateInputType
    _max?: AuthenticatorMaxAggregateInputType
  }

  export type AuthenticatorGroupByOutputType = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports: string | null
    _count: AuthenticatorCountAggregateOutputType | null
    _avg: AuthenticatorAvgAggregateOutputType | null
    _sum: AuthenticatorSumAggregateOutputType | null
    _min: AuthenticatorMinAggregateOutputType | null
    _max: AuthenticatorMaxAggregateOutputType | null
  }

  type GetAuthenticatorGroupByPayload<T extends AuthenticatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthenticatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthenticatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthenticatorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthenticatorGroupByOutputType[P]>
        }
      >
    >


  export type AuthenticatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authenticator"]>


  export type AuthenticatorSelectScalar = {
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
  }

  export type AuthenticatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthenticatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Authenticator"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      credentialID: string
      userId: string
      providerAccountId: string
      credentialPublicKey: string
      counter: number
      credentialDeviceType: string
      credentialBackedUp: boolean
      transports: string | null
    }, ExtArgs["result"]["authenticator"]>
    composites: {}
  }

  type AuthenticatorGetPayload<S extends boolean | null | undefined | AuthenticatorDefaultArgs> = $Result.GetResult<Prisma.$AuthenticatorPayload, S>

  type AuthenticatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuthenticatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthenticatorCountAggregateInputType | true
    }

  export interface AuthenticatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Authenticator'], meta: { name: 'Authenticator' } }
    /**
     * Find zero or one Authenticator that matches the filter.
     * @param {AuthenticatorFindUniqueArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthenticatorFindUniqueArgs>(args: SelectSubset<T, AuthenticatorFindUniqueArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Authenticator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuthenticatorFindUniqueOrThrowArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthenticatorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthenticatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Authenticator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindFirstArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthenticatorFindFirstArgs>(args?: SelectSubset<T, AuthenticatorFindFirstArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Authenticator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindFirstOrThrowArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthenticatorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthenticatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Authenticators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authenticators
     * const authenticators = await prisma.authenticator.findMany()
     * 
     * // Get first 10 Authenticators
     * const authenticators = await prisma.authenticator.findMany({ take: 10 })
     * 
     * // Only select the `credentialID`
     * const authenticatorWithCredentialIDOnly = await prisma.authenticator.findMany({ select: { credentialID: true } })
     * 
     */
    findMany<T extends AuthenticatorFindManyArgs>(args?: SelectSubset<T, AuthenticatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Authenticator.
     * @param {AuthenticatorCreateArgs} args - Arguments to create a Authenticator.
     * @example
     * // Create one Authenticator
     * const Authenticator = await prisma.authenticator.create({
     *   data: {
     *     // ... data to create a Authenticator
     *   }
     * })
     * 
     */
    create<T extends AuthenticatorCreateArgs>(args: SelectSubset<T, AuthenticatorCreateArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Authenticators.
     * @param {AuthenticatorCreateManyArgs} args - Arguments to create many Authenticators.
     * @example
     * // Create many Authenticators
     * const authenticator = await prisma.authenticator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthenticatorCreateManyArgs>(args?: SelectSubset<T, AuthenticatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Authenticator.
     * @param {AuthenticatorDeleteArgs} args - Arguments to delete one Authenticator.
     * @example
     * // Delete one Authenticator
     * const Authenticator = await prisma.authenticator.delete({
     *   where: {
     *     // ... filter to delete one Authenticator
     *   }
     * })
     * 
     */
    delete<T extends AuthenticatorDeleteArgs>(args: SelectSubset<T, AuthenticatorDeleteArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Authenticator.
     * @param {AuthenticatorUpdateArgs} args - Arguments to update one Authenticator.
     * @example
     * // Update one Authenticator
     * const authenticator = await prisma.authenticator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthenticatorUpdateArgs>(args: SelectSubset<T, AuthenticatorUpdateArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Authenticators.
     * @param {AuthenticatorDeleteManyArgs} args - Arguments to filter Authenticators to delete.
     * @example
     * // Delete a few Authenticators
     * const { count } = await prisma.authenticator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthenticatorDeleteManyArgs>(args?: SelectSubset<T, AuthenticatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authenticators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authenticators
     * const authenticator = await prisma.authenticator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthenticatorUpdateManyArgs>(args: SelectSubset<T, AuthenticatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Authenticator.
     * @param {AuthenticatorUpsertArgs} args - Arguments to update or create a Authenticator.
     * @example
     * // Update or create a Authenticator
     * const authenticator = await prisma.authenticator.upsert({
     *   create: {
     *     // ... data to create a Authenticator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authenticator we want to update
     *   }
     * })
     */
    upsert<T extends AuthenticatorUpsertArgs>(args: SelectSubset<T, AuthenticatorUpsertArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Authenticators that matches the filter.
     * @param {AuthenticatorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const authenticator = await prisma.authenticator.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AuthenticatorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Authenticator.
     * @param {AuthenticatorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const authenticator = await prisma.authenticator.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AuthenticatorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Authenticators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorCountArgs} args - Arguments to filter Authenticators to count.
     * @example
     * // Count the number of Authenticators
     * const count = await prisma.authenticator.count({
     *   where: {
     *     // ... the filter for the Authenticators we want to count
     *   }
     * })
    **/
    count<T extends AuthenticatorCountArgs>(
      args?: Subset<T, AuthenticatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthenticatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authenticator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthenticatorAggregateArgs>(args: Subset<T, AuthenticatorAggregateArgs>): Prisma.PrismaPromise<GetAuthenticatorAggregateType<T>>

    /**
     * Group by Authenticator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthenticatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthenticatorGroupByArgs['orderBy'] }
        : { orderBy?: AuthenticatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthenticatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthenticatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Authenticator model
   */
  readonly fields: AuthenticatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Authenticator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthenticatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Authenticator model
   */ 
  interface AuthenticatorFieldRefs {
    readonly credentialID: FieldRef<"Authenticator", 'String'>
    readonly userId: FieldRef<"Authenticator", 'String'>
    readonly providerAccountId: FieldRef<"Authenticator", 'String'>
    readonly credentialPublicKey: FieldRef<"Authenticator", 'String'>
    readonly counter: FieldRef<"Authenticator", 'Int'>
    readonly credentialDeviceType: FieldRef<"Authenticator", 'String'>
    readonly credentialBackedUp: FieldRef<"Authenticator", 'Boolean'>
    readonly transports: FieldRef<"Authenticator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Authenticator findUnique
   */
  export type AuthenticatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator findUniqueOrThrow
   */
  export type AuthenticatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator findFirst
   */
  export type AuthenticatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authenticators.
     */
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator findFirstOrThrow
   */
  export type AuthenticatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authenticators.
     */
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator findMany
   */
  export type AuthenticatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticators to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator create
   */
  export type AuthenticatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Authenticator.
     */
    data: XOR<AuthenticatorCreateInput, AuthenticatorUncheckedCreateInput>
  }

  /**
   * Authenticator createMany
   */
  export type AuthenticatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authenticators.
     */
    data: AuthenticatorCreateManyInput | AuthenticatorCreateManyInput[]
  }

  /**
   * Authenticator update
   */
  export type AuthenticatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Authenticator.
     */
    data: XOR<AuthenticatorUpdateInput, AuthenticatorUncheckedUpdateInput>
    /**
     * Choose, which Authenticator to update.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator updateMany
   */
  export type AuthenticatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authenticators.
     */
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyInput>
    /**
     * Filter which Authenticators to update
     */
    where?: AuthenticatorWhereInput
  }

  /**
   * Authenticator upsert
   */
  export type AuthenticatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Authenticator to update in case it exists.
     */
    where: AuthenticatorWhereUniqueInput
    /**
     * In case the Authenticator found by the `where` argument doesn't exist, create a new Authenticator with this data.
     */
    create: XOR<AuthenticatorCreateInput, AuthenticatorUncheckedCreateInput>
    /**
     * In case the Authenticator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthenticatorUpdateInput, AuthenticatorUncheckedUpdateInput>
  }

  /**
   * Authenticator delete
   */
  export type AuthenticatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter which Authenticator to delete.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator deleteMany
   */
  export type AuthenticatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authenticators to delete
     */
    where?: AuthenticatorWhereInput
  }

  /**
   * Authenticator findRaw
   */
  export type AuthenticatorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Authenticator aggregateRaw
   */
  export type AuthenticatorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Authenticator without action
   */
  export type AuthenticatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
  }


  /**
   * Model Leagues
   */

  export type AggregateLeagues = {
    _count: LeaguesCountAggregateOutputType | null
    _avg: LeaguesAvgAggregateOutputType | null
    _sum: LeaguesSumAggregateOutputType | null
    _min: LeaguesMinAggregateOutputType | null
    _max: LeaguesMaxAggregateOutputType | null
  }

  export type LeaguesAvgAggregateOutputType = {
    minEntry: number | null
    pointLimit: number | null
  }

  export type LeaguesSumAggregateOutputType = {
    minEntry: number | null
    pointLimit: number | null
  }

  export type LeaguesMinAggregateOutputType = {
    id: string | null
    name: string | null
    minEntry: number | null
    pointLimit: number | null
    trophy: string | null
    entryReward: string | null
  }

  export type LeaguesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    minEntry: number | null
    pointLimit: number | null
    trophy: string | null
    entryReward: string | null
  }

  export type LeaguesCountAggregateOutputType = {
    id: number
    name: number
    minEntry: number
    pointLimit: number
    trophy: number
    entryReward: number
    _all: number
  }


  export type LeaguesAvgAggregateInputType = {
    minEntry?: true
    pointLimit?: true
  }

  export type LeaguesSumAggregateInputType = {
    minEntry?: true
    pointLimit?: true
  }

  export type LeaguesMinAggregateInputType = {
    id?: true
    name?: true
    minEntry?: true
    pointLimit?: true
    trophy?: true
    entryReward?: true
  }

  export type LeaguesMaxAggregateInputType = {
    id?: true
    name?: true
    minEntry?: true
    pointLimit?: true
    trophy?: true
    entryReward?: true
  }

  export type LeaguesCountAggregateInputType = {
    id?: true
    name?: true
    minEntry?: true
    pointLimit?: true
    trophy?: true
    entryReward?: true
    _all?: true
  }

  export type LeaguesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leagues to aggregate.
     */
    where?: LeaguesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeaguesOrderByWithRelationInput | LeaguesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaguesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leagues
    **/
    _count?: true | LeaguesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaguesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaguesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaguesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaguesMaxAggregateInputType
  }

  export type GetLeaguesAggregateType<T extends LeaguesAggregateArgs> = {
        [P in keyof T & keyof AggregateLeagues]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeagues[P]>
      : GetScalarType<T[P], AggregateLeagues[P]>
  }




  export type LeaguesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaguesWhereInput
    orderBy?: LeaguesOrderByWithAggregationInput | LeaguesOrderByWithAggregationInput[]
    by: LeaguesScalarFieldEnum[] | LeaguesScalarFieldEnum
    having?: LeaguesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaguesCountAggregateInputType | true
    _avg?: LeaguesAvgAggregateInputType
    _sum?: LeaguesSumAggregateInputType
    _min?: LeaguesMinAggregateInputType
    _max?: LeaguesMaxAggregateInputType
  }

  export type LeaguesGroupByOutputType = {
    id: string
    name: string
    minEntry: number
    pointLimit: number
    trophy: string
    entryReward: string
    _count: LeaguesCountAggregateOutputType | null
    _avg: LeaguesAvgAggregateOutputType | null
    _sum: LeaguesSumAggregateOutputType | null
    _min: LeaguesMinAggregateOutputType | null
    _max: LeaguesMaxAggregateOutputType | null
  }

  type GetLeaguesGroupByPayload<T extends LeaguesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaguesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaguesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaguesGroupByOutputType[P]>
            : GetScalarType<T[P], LeaguesGroupByOutputType[P]>
        }
      >
    >


  export type LeaguesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    minEntry?: boolean
    pointLimit?: boolean
    trophy?: boolean
    entryReward?: boolean
  }, ExtArgs["result"]["leagues"]>


  export type LeaguesSelectScalar = {
    id?: boolean
    name?: boolean
    minEntry?: boolean
    pointLimit?: boolean
    trophy?: boolean
    entryReward?: boolean
  }


  export type $LeaguesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leagues"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      minEntry: number
      pointLimit: number
      trophy: string
      entryReward: string
    }, ExtArgs["result"]["leagues"]>
    composites: {}
  }

  type LeaguesGetPayload<S extends boolean | null | undefined | LeaguesDefaultArgs> = $Result.GetResult<Prisma.$LeaguesPayload, S>

  type LeaguesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaguesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaguesCountAggregateInputType | true
    }

  export interface LeaguesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leagues'], meta: { name: 'Leagues' } }
    /**
     * Find zero or one Leagues that matches the filter.
     * @param {LeaguesFindUniqueArgs} args - Arguments to find a Leagues
     * @example
     * // Get one Leagues
     * const leagues = await prisma.leagues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaguesFindUniqueArgs>(args: SelectSubset<T, LeaguesFindUniqueArgs<ExtArgs>>): Prisma__LeaguesClient<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Leagues that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaguesFindUniqueOrThrowArgs} args - Arguments to find a Leagues
     * @example
     * // Get one Leagues
     * const leagues = await prisma.leagues.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaguesFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaguesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaguesClient<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Leagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaguesFindFirstArgs} args - Arguments to find a Leagues
     * @example
     * // Get one Leagues
     * const leagues = await prisma.leagues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaguesFindFirstArgs>(args?: SelectSubset<T, LeaguesFindFirstArgs<ExtArgs>>): Prisma__LeaguesClient<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Leagues that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaguesFindFirstOrThrowArgs} args - Arguments to find a Leagues
     * @example
     * // Get one Leagues
     * const leagues = await prisma.leagues.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaguesFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaguesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaguesClient<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaguesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leagues
     * const leagues = await prisma.leagues.findMany()
     * 
     * // Get first 10 Leagues
     * const leagues = await prisma.leagues.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaguesWithIdOnly = await prisma.leagues.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaguesFindManyArgs>(args?: SelectSubset<T, LeaguesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Leagues.
     * @param {LeaguesCreateArgs} args - Arguments to create a Leagues.
     * @example
     * // Create one Leagues
     * const Leagues = await prisma.leagues.create({
     *   data: {
     *     // ... data to create a Leagues
     *   }
     * })
     * 
     */
    create<T extends LeaguesCreateArgs>(args: SelectSubset<T, LeaguesCreateArgs<ExtArgs>>): Prisma__LeaguesClient<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leagues.
     * @param {LeaguesCreateManyArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const leagues = await prisma.leagues.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaguesCreateManyArgs>(args?: SelectSubset<T, LeaguesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leagues.
     * @param {LeaguesDeleteArgs} args - Arguments to delete one Leagues.
     * @example
     * // Delete one Leagues
     * const Leagues = await prisma.leagues.delete({
     *   where: {
     *     // ... filter to delete one Leagues
     *   }
     * })
     * 
     */
    delete<T extends LeaguesDeleteArgs>(args: SelectSubset<T, LeaguesDeleteArgs<ExtArgs>>): Prisma__LeaguesClient<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Leagues.
     * @param {LeaguesUpdateArgs} args - Arguments to update one Leagues.
     * @example
     * // Update one Leagues
     * const leagues = await prisma.leagues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaguesUpdateArgs>(args: SelectSubset<T, LeaguesUpdateArgs<ExtArgs>>): Prisma__LeaguesClient<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leagues.
     * @param {LeaguesDeleteManyArgs} args - Arguments to filter Leagues to delete.
     * @example
     * // Delete a few Leagues
     * const { count } = await prisma.leagues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaguesDeleteManyArgs>(args?: SelectSubset<T, LeaguesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaguesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leagues
     * const leagues = await prisma.leagues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaguesUpdateManyArgs>(args: SelectSubset<T, LeaguesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leagues.
     * @param {LeaguesUpsertArgs} args - Arguments to update or create a Leagues.
     * @example
     * // Update or create a Leagues
     * const leagues = await prisma.leagues.upsert({
     *   create: {
     *     // ... data to create a Leagues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leagues we want to update
     *   }
     * })
     */
    upsert<T extends LeaguesUpsertArgs>(args: SelectSubset<T, LeaguesUpsertArgs<ExtArgs>>): Prisma__LeaguesClient<$Result.GetResult<Prisma.$LeaguesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Leagues that matches the filter.
     * @param {LeaguesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const leagues = await prisma.leagues.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: LeaguesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Leagues.
     * @param {LeaguesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const leagues = await prisma.leagues.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LeaguesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaguesCountArgs} args - Arguments to filter Leagues to count.
     * @example
     * // Count the number of Leagues
     * const count = await prisma.leagues.count({
     *   where: {
     *     // ... the filter for the Leagues we want to count
     *   }
     * })
    **/
    count<T extends LeaguesCountArgs>(
      args?: Subset<T, LeaguesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaguesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaguesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaguesAggregateArgs>(args: Subset<T, LeaguesAggregateArgs>): Prisma.PrismaPromise<GetLeaguesAggregateType<T>>

    /**
     * Group by Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaguesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaguesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaguesGroupByArgs['orderBy'] }
        : { orderBy?: LeaguesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaguesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaguesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leagues model
   */
  readonly fields: LeaguesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leagues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaguesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leagues model
   */ 
  interface LeaguesFieldRefs {
    readonly id: FieldRef<"Leagues", 'String'>
    readonly name: FieldRef<"Leagues", 'String'>
    readonly minEntry: FieldRef<"Leagues", 'Int'>
    readonly pointLimit: FieldRef<"Leagues", 'Int'>
    readonly trophy: FieldRef<"Leagues", 'String'>
    readonly entryReward: FieldRef<"Leagues", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Leagues findUnique
   */
  export type LeaguesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where: LeaguesWhereUniqueInput
  }

  /**
   * Leagues findUniqueOrThrow
   */
  export type LeaguesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where: LeaguesWhereUniqueInput
  }

  /**
   * Leagues findFirst
   */
  export type LeaguesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where?: LeaguesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeaguesOrderByWithRelationInput | LeaguesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeaguesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeaguesScalarFieldEnum | LeaguesScalarFieldEnum[]
  }

  /**
   * Leagues findFirstOrThrow
   */
  export type LeaguesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where?: LeaguesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeaguesOrderByWithRelationInput | LeaguesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeaguesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeaguesScalarFieldEnum | LeaguesScalarFieldEnum[]
  }

  /**
   * Leagues findMany
   */
  export type LeaguesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where?: LeaguesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeaguesOrderByWithRelationInput | LeaguesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leagues.
     */
    cursor?: LeaguesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    distinct?: LeaguesScalarFieldEnum | LeaguesScalarFieldEnum[]
  }

  /**
   * Leagues create
   */
  export type LeaguesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * The data needed to create a Leagues.
     */
    data: XOR<LeaguesCreateInput, LeaguesUncheckedCreateInput>
  }

  /**
   * Leagues createMany
   */
  export type LeaguesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leagues.
     */
    data: LeaguesCreateManyInput | LeaguesCreateManyInput[]
  }

  /**
   * Leagues update
   */
  export type LeaguesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * The data needed to update a Leagues.
     */
    data: XOR<LeaguesUpdateInput, LeaguesUncheckedUpdateInput>
    /**
     * Choose, which Leagues to update.
     */
    where: LeaguesWhereUniqueInput
  }

  /**
   * Leagues updateMany
   */
  export type LeaguesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeaguesUpdateManyMutationInput, LeaguesUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeaguesWhereInput
  }

  /**
   * Leagues upsert
   */
  export type LeaguesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * The filter to search for the Leagues to update in case it exists.
     */
    where: LeaguesWhereUniqueInput
    /**
     * In case the Leagues found by the `where` argument doesn't exist, create a new Leagues with this data.
     */
    create: XOR<LeaguesCreateInput, LeaguesUncheckedCreateInput>
    /**
     * In case the Leagues was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaguesUpdateInput, LeaguesUncheckedUpdateInput>
  }

  /**
   * Leagues delete
   */
  export type LeaguesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
    /**
     * Filter which Leagues to delete.
     */
    where: LeaguesWhereUniqueInput
  }

  /**
   * Leagues deleteMany
   */
  export type LeaguesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leagues to delete
     */
    where?: LeaguesWhereInput
  }

  /**
   * Leagues findRaw
   */
  export type LeaguesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Leagues aggregateRaw
   */
  export type LeaguesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Leagues without action
   */
  export type LeaguesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leagues
     */
    select?: LeaguesSelect<ExtArgs> | null
  }


  /**
   * Model Points
   */

  export type AggregatePoints = {
    _count: PointsCountAggregateOutputType | null
    _avg: PointsAvgAggregateOutputType | null
    _sum: PointsSumAggregateOutputType | null
    _min: PointsMinAggregateOutputType | null
    _max: PointsMaxAggregateOutputType | null
  }

  export type PointsAvgAggregateOutputType = {
    points: number | null
    tapLimit: number | null
  }

  export type PointsSumAggregateOutputType = {
    points: number | null
    tapLimit: number | null
  }

  export type PointsMinAggregateOutputType = {
    id: string | null
    user: string | null
    points: number | null
    league: string | null
    autominer: boolean | null
    tapLimit: number | null
    lastTap: Date | null
  }

  export type PointsMaxAggregateOutputType = {
    id: string | null
    user: string | null
    points: number | null
    league: string | null
    autominer: boolean | null
    tapLimit: number | null
    lastTap: Date | null
  }

  export type PointsCountAggregateOutputType = {
    id: number
    user: number
    points: number
    league: number
    autominer: number
    tapLimit: number
    lastTap: number
    _all: number
  }


  export type PointsAvgAggregateInputType = {
    points?: true
    tapLimit?: true
  }

  export type PointsSumAggregateInputType = {
    points?: true
    tapLimit?: true
  }

  export type PointsMinAggregateInputType = {
    id?: true
    user?: true
    points?: true
    league?: true
    autominer?: true
    tapLimit?: true
    lastTap?: true
  }

  export type PointsMaxAggregateInputType = {
    id?: true
    user?: true
    points?: true
    league?: true
    autominer?: true
    tapLimit?: true
    lastTap?: true
  }

  export type PointsCountAggregateInputType = {
    id?: true
    user?: true
    points?: true
    league?: true
    autominer?: true
    tapLimit?: true
    lastTap?: true
    _all?: true
  }

  export type PointsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Points to aggregate.
     */
    where?: PointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     */
    orderBy?: PointsOrderByWithRelationInput | PointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Points
    **/
    _count?: true | PointsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointsMaxAggregateInputType
  }

  export type GetPointsAggregateType<T extends PointsAggregateArgs> = {
        [P in keyof T & keyof AggregatePoints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoints[P]>
      : GetScalarType<T[P], AggregatePoints[P]>
  }




  export type PointsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsWhereInput
    orderBy?: PointsOrderByWithAggregationInput | PointsOrderByWithAggregationInput[]
    by: PointsScalarFieldEnum[] | PointsScalarFieldEnum
    having?: PointsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointsCountAggregateInputType | true
    _avg?: PointsAvgAggregateInputType
    _sum?: PointsSumAggregateInputType
    _min?: PointsMinAggregateInputType
    _max?: PointsMaxAggregateInputType
  }

  export type PointsGroupByOutputType = {
    id: string
    user: string
    points: number
    league: string
    autominer: boolean
    tapLimit: number
    lastTap: Date
    _count: PointsCountAggregateOutputType | null
    _avg: PointsAvgAggregateOutputType | null
    _sum: PointsSumAggregateOutputType | null
    _min: PointsMinAggregateOutputType | null
    _max: PointsMaxAggregateOutputType | null
  }

  type GetPointsGroupByPayload<T extends PointsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointsGroupByOutputType[P]>
            : GetScalarType<T[P], PointsGroupByOutputType[P]>
        }
      >
    >


  export type PointsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    points?: boolean
    league?: boolean
    autominer?: boolean
    tapLimit?: boolean
    lastTap?: boolean
  }, ExtArgs["result"]["points"]>


  export type PointsSelectScalar = {
    id?: boolean
    user?: boolean
    points?: boolean
    league?: boolean
    autominer?: boolean
    tapLimit?: boolean
    lastTap?: boolean
  }


  export type $PointsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Points"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user: string
      points: number
      league: string
      autominer: boolean
      tapLimit: number
      lastTap: Date
    }, ExtArgs["result"]["points"]>
    composites: {}
  }

  type PointsGetPayload<S extends boolean | null | undefined | PointsDefaultArgs> = $Result.GetResult<Prisma.$PointsPayload, S>

  type PointsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PointsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PointsCountAggregateInputType | true
    }

  export interface PointsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Points'], meta: { name: 'Points' } }
    /**
     * Find zero or one Points that matches the filter.
     * @param {PointsFindUniqueArgs} args - Arguments to find a Points
     * @example
     * // Get one Points
     * const points = await prisma.points.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointsFindUniqueArgs>(args: SelectSubset<T, PointsFindUniqueArgs<ExtArgs>>): Prisma__PointsClient<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Points that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PointsFindUniqueOrThrowArgs} args - Arguments to find a Points
     * @example
     * // Get one Points
     * const points = await prisma.points.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointsFindUniqueOrThrowArgs>(args: SelectSubset<T, PointsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointsClient<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Points that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsFindFirstArgs} args - Arguments to find a Points
     * @example
     * // Get one Points
     * const points = await prisma.points.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointsFindFirstArgs>(args?: SelectSubset<T, PointsFindFirstArgs<ExtArgs>>): Prisma__PointsClient<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Points that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsFindFirstOrThrowArgs} args - Arguments to find a Points
     * @example
     * // Get one Points
     * const points = await prisma.points.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointsFindFirstOrThrowArgs>(args?: SelectSubset<T, PointsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointsClient<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Points that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Points
     * const points = await prisma.points.findMany()
     * 
     * // Get first 10 Points
     * const points = await prisma.points.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointsWithIdOnly = await prisma.points.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointsFindManyArgs>(args?: SelectSubset<T, PointsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Points.
     * @param {PointsCreateArgs} args - Arguments to create a Points.
     * @example
     * // Create one Points
     * const Points = await prisma.points.create({
     *   data: {
     *     // ... data to create a Points
     *   }
     * })
     * 
     */
    create<T extends PointsCreateArgs>(args: SelectSubset<T, PointsCreateArgs<ExtArgs>>): Prisma__PointsClient<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Points.
     * @param {PointsCreateManyArgs} args - Arguments to create many Points.
     * @example
     * // Create many Points
     * const points = await prisma.points.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointsCreateManyArgs>(args?: SelectSubset<T, PointsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Points.
     * @param {PointsDeleteArgs} args - Arguments to delete one Points.
     * @example
     * // Delete one Points
     * const Points = await prisma.points.delete({
     *   where: {
     *     // ... filter to delete one Points
     *   }
     * })
     * 
     */
    delete<T extends PointsDeleteArgs>(args: SelectSubset<T, PointsDeleteArgs<ExtArgs>>): Prisma__PointsClient<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Points.
     * @param {PointsUpdateArgs} args - Arguments to update one Points.
     * @example
     * // Update one Points
     * const points = await prisma.points.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointsUpdateArgs>(args: SelectSubset<T, PointsUpdateArgs<ExtArgs>>): Prisma__PointsClient<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Points.
     * @param {PointsDeleteManyArgs} args - Arguments to filter Points to delete.
     * @example
     * // Delete a few Points
     * const { count } = await prisma.points.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointsDeleteManyArgs>(args?: SelectSubset<T, PointsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Points
     * const points = await prisma.points.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointsUpdateManyArgs>(args: SelectSubset<T, PointsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Points.
     * @param {PointsUpsertArgs} args - Arguments to update or create a Points.
     * @example
     * // Update or create a Points
     * const points = await prisma.points.upsert({
     *   create: {
     *     // ... data to create a Points
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Points we want to update
     *   }
     * })
     */
    upsert<T extends PointsUpsertArgs>(args: SelectSubset<T, PointsUpsertArgs<ExtArgs>>): Prisma__PointsClient<$Result.GetResult<Prisma.$PointsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Points that matches the filter.
     * @param {PointsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const points = await prisma.points.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PointsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Points.
     * @param {PointsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const points = await prisma.points.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PointsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsCountArgs} args - Arguments to filter Points to count.
     * @example
     * // Count the number of Points
     * const count = await prisma.points.count({
     *   where: {
     *     // ... the filter for the Points we want to count
     *   }
     * })
    **/
    count<T extends PointsCountArgs>(
      args?: Subset<T, PointsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointsAggregateArgs>(args: Subset<T, PointsAggregateArgs>): Prisma.PrismaPromise<GetPointsAggregateType<T>>

    /**
     * Group by Points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointsGroupByArgs['orderBy'] }
        : { orderBy?: PointsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Points model
   */
  readonly fields: PointsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Points.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Points model
   */ 
  interface PointsFieldRefs {
    readonly id: FieldRef<"Points", 'String'>
    readonly user: FieldRef<"Points", 'String'>
    readonly points: FieldRef<"Points", 'Int'>
    readonly league: FieldRef<"Points", 'String'>
    readonly autominer: FieldRef<"Points", 'Boolean'>
    readonly tapLimit: FieldRef<"Points", 'Int'>
    readonly lastTap: FieldRef<"Points", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Points findUnique
   */
  export type PointsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * Filter, which Points to fetch.
     */
    where: PointsWhereUniqueInput
  }

  /**
   * Points findUniqueOrThrow
   */
  export type PointsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * Filter, which Points to fetch.
     */
    where: PointsWhereUniqueInput
  }

  /**
   * Points findFirst
   */
  export type PointsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * Filter, which Points to fetch.
     */
    where?: PointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     */
    orderBy?: PointsOrderByWithRelationInput | PointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Points.
     */
    cursor?: PointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Points.
     */
    distinct?: PointsScalarFieldEnum | PointsScalarFieldEnum[]
  }

  /**
   * Points findFirstOrThrow
   */
  export type PointsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * Filter, which Points to fetch.
     */
    where?: PointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     */
    orderBy?: PointsOrderByWithRelationInput | PointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Points.
     */
    cursor?: PointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Points.
     */
    distinct?: PointsScalarFieldEnum | PointsScalarFieldEnum[]
  }

  /**
   * Points findMany
   */
  export type PointsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * Filter, which Points to fetch.
     */
    where?: PointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     */
    orderBy?: PointsOrderByWithRelationInput | PointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Points.
     */
    cursor?: PointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     */
    skip?: number
    distinct?: PointsScalarFieldEnum | PointsScalarFieldEnum[]
  }

  /**
   * Points create
   */
  export type PointsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * The data needed to create a Points.
     */
    data: XOR<PointsCreateInput, PointsUncheckedCreateInput>
  }

  /**
   * Points createMany
   */
  export type PointsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Points.
     */
    data: PointsCreateManyInput | PointsCreateManyInput[]
  }

  /**
   * Points update
   */
  export type PointsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * The data needed to update a Points.
     */
    data: XOR<PointsUpdateInput, PointsUncheckedUpdateInput>
    /**
     * Choose, which Points to update.
     */
    where: PointsWhereUniqueInput
  }

  /**
   * Points updateMany
   */
  export type PointsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Points.
     */
    data: XOR<PointsUpdateManyMutationInput, PointsUncheckedUpdateManyInput>
    /**
     * Filter which Points to update
     */
    where?: PointsWhereInput
  }

  /**
   * Points upsert
   */
  export type PointsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * The filter to search for the Points to update in case it exists.
     */
    where: PointsWhereUniqueInput
    /**
     * In case the Points found by the `where` argument doesn't exist, create a new Points with this data.
     */
    create: XOR<PointsCreateInput, PointsUncheckedCreateInput>
    /**
     * In case the Points was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointsUpdateInput, PointsUncheckedUpdateInput>
  }

  /**
   * Points delete
   */
  export type PointsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
    /**
     * Filter which Points to delete.
     */
    where: PointsWhereUniqueInput
  }

  /**
   * Points deleteMany
   */
  export type PointsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Points to delete
     */
    where?: PointsWhereInput
  }

  /**
   * Points findRaw
   */
  export type PointsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Points aggregateRaw
   */
  export type PointsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Points without action
   */
  export type PointsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Points
     */
    select?: PointsSelect<ExtArgs> | null
  }


  /**
   * Model Bonuster
   */

  export type AggregateBonuster = {
    _count: BonusterCountAggregateOutputType | null
    _avg: BonusterAvgAggregateOutputType | null
    _sum: BonusterSumAggregateOutputType | null
    _min: BonusterMinAggregateOutputType | null
    _max: BonusterMaxAggregateOutputType | null
  }

  export type BonusterAvgAggregateOutputType = {
    energy: number | null
    energyCost: number | null
    energylevel: number | null
    multiClickLevel: number | null
    multiClickCost: number | null
  }

  export type BonusterSumAggregateOutputType = {
    energy: number | null
    energyCost: number | null
    energylevel: number | null
    multiClickLevel: number | null
    multiClickCost: number | null
  }

  export type BonusterMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    energy: number | null
    energyCost: number | null
    energylevel: number | null
    multiClickLevel: number | null
    multiClickCost: number | null
  }

  export type BonusterMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    energy: number | null
    energyCost: number | null
    energylevel: number | null
    multiClickLevel: number | null
    multiClickCost: number | null
  }

  export type BonusterCountAggregateOutputType = {
    id: number
    chatId: number
    energy: number
    energyCost: number
    energylevel: number
    multiClickLevel: number
    multiClickCost: number
    _all: number
  }


  export type BonusterAvgAggregateInputType = {
    energy?: true
    energyCost?: true
    energylevel?: true
    multiClickLevel?: true
    multiClickCost?: true
  }

  export type BonusterSumAggregateInputType = {
    energy?: true
    energyCost?: true
    energylevel?: true
    multiClickLevel?: true
    multiClickCost?: true
  }

  export type BonusterMinAggregateInputType = {
    id?: true
    chatId?: true
    energy?: true
    energyCost?: true
    energylevel?: true
    multiClickLevel?: true
    multiClickCost?: true
  }

  export type BonusterMaxAggregateInputType = {
    id?: true
    chatId?: true
    energy?: true
    energyCost?: true
    energylevel?: true
    multiClickLevel?: true
    multiClickCost?: true
  }

  export type BonusterCountAggregateInputType = {
    id?: true
    chatId?: true
    energy?: true
    energyCost?: true
    energylevel?: true
    multiClickLevel?: true
    multiClickCost?: true
    _all?: true
  }

  export type BonusterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonuster to aggregate.
     */
    where?: BonusterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonusters to fetch.
     */
    orderBy?: BonusterOrderByWithRelationInput | BonusterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BonusterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonusters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonusters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bonusters
    **/
    _count?: true | BonusterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BonusterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BonusterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BonusterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BonusterMaxAggregateInputType
  }

  export type GetBonusterAggregateType<T extends BonusterAggregateArgs> = {
        [P in keyof T & keyof AggregateBonuster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBonuster[P]>
      : GetScalarType<T[P], AggregateBonuster[P]>
  }




  export type BonusterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusterWhereInput
    orderBy?: BonusterOrderByWithAggregationInput | BonusterOrderByWithAggregationInput[]
    by: BonusterScalarFieldEnum[] | BonusterScalarFieldEnum
    having?: BonusterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BonusterCountAggregateInputType | true
    _avg?: BonusterAvgAggregateInputType
    _sum?: BonusterSumAggregateInputType
    _min?: BonusterMinAggregateInputType
    _max?: BonusterMaxAggregateInputType
  }

  export type BonusterGroupByOutputType = {
    id: string
    chatId: string
    energy: number
    energyCost: number
    energylevel: number
    multiClickLevel: number
    multiClickCost: number
    _count: BonusterCountAggregateOutputType | null
    _avg: BonusterAvgAggregateOutputType | null
    _sum: BonusterSumAggregateOutputType | null
    _min: BonusterMinAggregateOutputType | null
    _max: BonusterMaxAggregateOutputType | null
  }

  type GetBonusterGroupByPayload<T extends BonusterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BonusterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BonusterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BonusterGroupByOutputType[P]>
            : GetScalarType<T[P], BonusterGroupByOutputType[P]>
        }
      >
    >


  export type BonusterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    energy?: boolean
    energyCost?: boolean
    energylevel?: boolean
    multiClickLevel?: boolean
    multiClickCost?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bonuster"]>


  export type BonusterSelectScalar = {
    id?: boolean
    chatId?: boolean
    energy?: boolean
    energyCost?: boolean
    energylevel?: boolean
    multiClickLevel?: boolean
    multiClickCost?: boolean
  }

  export type BonusterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BonusterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bonuster"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      energy: number
      energyCost: number
      energylevel: number
      multiClickLevel: number
      multiClickCost: number
    }, ExtArgs["result"]["bonuster"]>
    composites: {}
  }

  type BonusterGetPayload<S extends boolean | null | undefined | BonusterDefaultArgs> = $Result.GetResult<Prisma.$BonusterPayload, S>

  type BonusterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BonusterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BonusterCountAggregateInputType | true
    }

  export interface BonusterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bonuster'], meta: { name: 'Bonuster' } }
    /**
     * Find zero or one Bonuster that matches the filter.
     * @param {BonusterFindUniqueArgs} args - Arguments to find a Bonuster
     * @example
     * // Get one Bonuster
     * const bonuster = await prisma.bonuster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BonusterFindUniqueArgs>(args: SelectSubset<T, BonusterFindUniqueArgs<ExtArgs>>): Prisma__BonusterClient<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bonuster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BonusterFindUniqueOrThrowArgs} args - Arguments to find a Bonuster
     * @example
     * // Get one Bonuster
     * const bonuster = await prisma.bonuster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BonusterFindUniqueOrThrowArgs>(args: SelectSubset<T, BonusterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BonusterClient<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bonuster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusterFindFirstArgs} args - Arguments to find a Bonuster
     * @example
     * // Get one Bonuster
     * const bonuster = await prisma.bonuster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BonusterFindFirstArgs>(args?: SelectSubset<T, BonusterFindFirstArgs<ExtArgs>>): Prisma__BonusterClient<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bonuster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusterFindFirstOrThrowArgs} args - Arguments to find a Bonuster
     * @example
     * // Get one Bonuster
     * const bonuster = await prisma.bonuster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BonusterFindFirstOrThrowArgs>(args?: SelectSubset<T, BonusterFindFirstOrThrowArgs<ExtArgs>>): Prisma__BonusterClient<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bonusters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bonusters
     * const bonusters = await prisma.bonuster.findMany()
     * 
     * // Get first 10 Bonusters
     * const bonusters = await prisma.bonuster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bonusterWithIdOnly = await prisma.bonuster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BonusterFindManyArgs>(args?: SelectSubset<T, BonusterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bonuster.
     * @param {BonusterCreateArgs} args - Arguments to create a Bonuster.
     * @example
     * // Create one Bonuster
     * const Bonuster = await prisma.bonuster.create({
     *   data: {
     *     // ... data to create a Bonuster
     *   }
     * })
     * 
     */
    create<T extends BonusterCreateArgs>(args: SelectSubset<T, BonusterCreateArgs<ExtArgs>>): Prisma__BonusterClient<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bonusters.
     * @param {BonusterCreateManyArgs} args - Arguments to create many Bonusters.
     * @example
     * // Create many Bonusters
     * const bonuster = await prisma.bonuster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BonusterCreateManyArgs>(args?: SelectSubset<T, BonusterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bonuster.
     * @param {BonusterDeleteArgs} args - Arguments to delete one Bonuster.
     * @example
     * // Delete one Bonuster
     * const Bonuster = await prisma.bonuster.delete({
     *   where: {
     *     // ... filter to delete one Bonuster
     *   }
     * })
     * 
     */
    delete<T extends BonusterDeleteArgs>(args: SelectSubset<T, BonusterDeleteArgs<ExtArgs>>): Prisma__BonusterClient<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bonuster.
     * @param {BonusterUpdateArgs} args - Arguments to update one Bonuster.
     * @example
     * // Update one Bonuster
     * const bonuster = await prisma.bonuster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BonusterUpdateArgs>(args: SelectSubset<T, BonusterUpdateArgs<ExtArgs>>): Prisma__BonusterClient<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bonusters.
     * @param {BonusterDeleteManyArgs} args - Arguments to filter Bonusters to delete.
     * @example
     * // Delete a few Bonusters
     * const { count } = await prisma.bonuster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BonusterDeleteManyArgs>(args?: SelectSubset<T, BonusterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bonusters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bonusters
     * const bonuster = await prisma.bonuster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BonusterUpdateManyArgs>(args: SelectSubset<T, BonusterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bonuster.
     * @param {BonusterUpsertArgs} args - Arguments to update or create a Bonuster.
     * @example
     * // Update or create a Bonuster
     * const bonuster = await prisma.bonuster.upsert({
     *   create: {
     *     // ... data to create a Bonuster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bonuster we want to update
     *   }
     * })
     */
    upsert<T extends BonusterUpsertArgs>(args: SelectSubset<T, BonusterUpsertArgs<ExtArgs>>): Prisma__BonusterClient<$Result.GetResult<Prisma.$BonusterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Bonusters that matches the filter.
     * @param {BonusterFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const bonuster = await prisma.bonuster.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BonusterFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Bonuster.
     * @param {BonusterAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const bonuster = await prisma.bonuster.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BonusterAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Bonusters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusterCountArgs} args - Arguments to filter Bonusters to count.
     * @example
     * // Count the number of Bonusters
     * const count = await prisma.bonuster.count({
     *   where: {
     *     // ... the filter for the Bonusters we want to count
     *   }
     * })
    **/
    count<T extends BonusterCountArgs>(
      args?: Subset<T, BonusterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BonusterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bonuster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BonusterAggregateArgs>(args: Subset<T, BonusterAggregateArgs>): Prisma.PrismaPromise<GetBonusterAggregateType<T>>

    /**
     * Group by Bonuster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BonusterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BonusterGroupByArgs['orderBy'] }
        : { orderBy?: BonusterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BonusterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBonusterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bonuster model
   */
  readonly fields: BonusterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bonuster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BonusterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bonuster model
   */ 
  interface BonusterFieldRefs {
    readonly id: FieldRef<"Bonuster", 'String'>
    readonly chatId: FieldRef<"Bonuster", 'String'>
    readonly energy: FieldRef<"Bonuster", 'Int'>
    readonly energyCost: FieldRef<"Bonuster", 'Int'>
    readonly energylevel: FieldRef<"Bonuster", 'Int'>
    readonly multiClickLevel: FieldRef<"Bonuster", 'Int'>
    readonly multiClickCost: FieldRef<"Bonuster", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Bonuster findUnique
   */
  export type BonusterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * Filter, which Bonuster to fetch.
     */
    where: BonusterWhereUniqueInput
  }

  /**
   * Bonuster findUniqueOrThrow
   */
  export type BonusterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * Filter, which Bonuster to fetch.
     */
    where: BonusterWhereUniqueInput
  }

  /**
   * Bonuster findFirst
   */
  export type BonusterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * Filter, which Bonuster to fetch.
     */
    where?: BonusterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonusters to fetch.
     */
    orderBy?: BonusterOrderByWithRelationInput | BonusterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonusters.
     */
    cursor?: BonusterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonusters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonusters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonusters.
     */
    distinct?: BonusterScalarFieldEnum | BonusterScalarFieldEnum[]
  }

  /**
   * Bonuster findFirstOrThrow
   */
  export type BonusterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * Filter, which Bonuster to fetch.
     */
    where?: BonusterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonusters to fetch.
     */
    orderBy?: BonusterOrderByWithRelationInput | BonusterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonusters.
     */
    cursor?: BonusterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonusters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonusters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonusters.
     */
    distinct?: BonusterScalarFieldEnum | BonusterScalarFieldEnum[]
  }

  /**
   * Bonuster findMany
   */
  export type BonusterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * Filter, which Bonusters to fetch.
     */
    where?: BonusterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonusters to fetch.
     */
    orderBy?: BonusterOrderByWithRelationInput | BonusterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bonusters.
     */
    cursor?: BonusterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonusters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonusters.
     */
    skip?: number
    distinct?: BonusterScalarFieldEnum | BonusterScalarFieldEnum[]
  }

  /**
   * Bonuster create
   */
  export type BonusterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * The data needed to create a Bonuster.
     */
    data: XOR<BonusterCreateInput, BonusterUncheckedCreateInput>
  }

  /**
   * Bonuster createMany
   */
  export type BonusterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bonusters.
     */
    data: BonusterCreateManyInput | BonusterCreateManyInput[]
  }

  /**
   * Bonuster update
   */
  export type BonusterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * The data needed to update a Bonuster.
     */
    data: XOR<BonusterUpdateInput, BonusterUncheckedUpdateInput>
    /**
     * Choose, which Bonuster to update.
     */
    where: BonusterWhereUniqueInput
  }

  /**
   * Bonuster updateMany
   */
  export type BonusterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bonusters.
     */
    data: XOR<BonusterUpdateManyMutationInput, BonusterUncheckedUpdateManyInput>
    /**
     * Filter which Bonusters to update
     */
    where?: BonusterWhereInput
  }

  /**
   * Bonuster upsert
   */
  export type BonusterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * The filter to search for the Bonuster to update in case it exists.
     */
    where: BonusterWhereUniqueInput
    /**
     * In case the Bonuster found by the `where` argument doesn't exist, create a new Bonuster with this data.
     */
    create: XOR<BonusterCreateInput, BonusterUncheckedCreateInput>
    /**
     * In case the Bonuster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BonusterUpdateInput, BonusterUncheckedUpdateInput>
  }

  /**
   * Bonuster delete
   */
  export type BonusterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
    /**
     * Filter which Bonuster to delete.
     */
    where: BonusterWhereUniqueInput
  }

  /**
   * Bonuster deleteMany
   */
  export type BonusterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonusters to delete
     */
    where?: BonusterWhereInput
  }

  /**
   * Bonuster findRaw
   */
  export type BonusterFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Bonuster aggregateRaw
   */
  export type BonusterAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Bonuster without action
   */
  export type BonusterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonuster
     */
    select?: BonusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusterInclude<ExtArgs> | null
  }


  /**
   * Model DailyBoosters
   */

  export type AggregateDailyBoosters = {
    _count: DailyBoostersCountAggregateOutputType | null
    _avg: DailyBoostersAvgAggregateOutputType | null
    _sum: DailyBoostersSumAggregateOutputType | null
    _min: DailyBoostersMinAggregateOutputType | null
    _max: DailyBoostersMaxAggregateOutputType | null
  }

  export type DailyBoostersAvgAggregateOutputType = {
    count: number | null
  }

  export type DailyBoostersSumAggregateOutputType = {
    count: number | null
  }

  export type DailyBoostersMinAggregateOutputType = {
    id: string | null
    name: string | null
    count: number | null
    icon: string | null
  }

  export type DailyBoostersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    count: number | null
    icon: string | null
  }

  export type DailyBoostersCountAggregateOutputType = {
    id: number
    name: number
    count: number
    icon: number
    _all: number
  }


  export type DailyBoostersAvgAggregateInputType = {
    count?: true
  }

  export type DailyBoostersSumAggregateInputType = {
    count?: true
  }

  export type DailyBoostersMinAggregateInputType = {
    id?: true
    name?: true
    count?: true
    icon?: true
  }

  export type DailyBoostersMaxAggregateInputType = {
    id?: true
    name?: true
    count?: true
    icon?: true
  }

  export type DailyBoostersCountAggregateInputType = {
    id?: true
    name?: true
    count?: true
    icon?: true
    _all?: true
  }

  export type DailyBoostersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyBoosters to aggregate.
     */
    where?: DailyBoostersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyBoosters to fetch.
     */
    orderBy?: DailyBoostersOrderByWithRelationInput | DailyBoostersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyBoostersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyBoosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyBoosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyBoosters
    **/
    _count?: true | DailyBoostersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyBoostersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyBoostersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyBoostersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyBoostersMaxAggregateInputType
  }

  export type GetDailyBoostersAggregateType<T extends DailyBoostersAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyBoosters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyBoosters[P]>
      : GetScalarType<T[P], AggregateDailyBoosters[P]>
  }




  export type DailyBoostersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyBoostersWhereInput
    orderBy?: DailyBoostersOrderByWithAggregationInput | DailyBoostersOrderByWithAggregationInput[]
    by: DailyBoostersScalarFieldEnum[] | DailyBoostersScalarFieldEnum
    having?: DailyBoostersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyBoostersCountAggregateInputType | true
    _avg?: DailyBoostersAvgAggregateInputType
    _sum?: DailyBoostersSumAggregateInputType
    _min?: DailyBoostersMinAggregateInputType
    _max?: DailyBoostersMaxAggregateInputType
  }

  export type DailyBoostersGroupByOutputType = {
    id: string
    name: string
    count: number
    icon: string
    _count: DailyBoostersCountAggregateOutputType | null
    _avg: DailyBoostersAvgAggregateOutputType | null
    _sum: DailyBoostersSumAggregateOutputType | null
    _min: DailyBoostersMinAggregateOutputType | null
    _max: DailyBoostersMaxAggregateOutputType | null
  }

  type GetDailyBoostersGroupByPayload<T extends DailyBoostersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyBoostersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyBoostersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyBoostersGroupByOutputType[P]>
            : GetScalarType<T[P], DailyBoostersGroupByOutputType[P]>
        }
      >
    >


  export type DailyBoostersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    count?: boolean
    icon?: boolean
  }, ExtArgs["result"]["dailyBoosters"]>


  export type DailyBoostersSelectScalar = {
    id?: boolean
    name?: boolean
    count?: boolean
    icon?: boolean
  }


  export type $DailyBoostersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyBoosters"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      count: number
      icon: string
    }, ExtArgs["result"]["dailyBoosters"]>
    composites: {}
  }

  type DailyBoostersGetPayload<S extends boolean | null | undefined | DailyBoostersDefaultArgs> = $Result.GetResult<Prisma.$DailyBoostersPayload, S>

  type DailyBoostersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyBoostersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyBoostersCountAggregateInputType | true
    }

  export interface DailyBoostersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyBoosters'], meta: { name: 'DailyBoosters' } }
    /**
     * Find zero or one DailyBoosters that matches the filter.
     * @param {DailyBoostersFindUniqueArgs} args - Arguments to find a DailyBoosters
     * @example
     * // Get one DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyBoostersFindUniqueArgs>(args: SelectSubset<T, DailyBoostersFindUniqueArgs<ExtArgs>>): Prisma__DailyBoostersClient<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyBoosters that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyBoostersFindUniqueOrThrowArgs} args - Arguments to find a DailyBoosters
     * @example
     * // Get one DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyBoostersFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyBoostersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyBoostersClient<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyBoosters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyBoostersFindFirstArgs} args - Arguments to find a DailyBoosters
     * @example
     * // Get one DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyBoostersFindFirstArgs>(args?: SelectSubset<T, DailyBoostersFindFirstArgs<ExtArgs>>): Prisma__DailyBoostersClient<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyBoosters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyBoostersFindFirstOrThrowArgs} args - Arguments to find a DailyBoosters
     * @example
     * // Get one DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyBoostersFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyBoostersFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyBoostersClient<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyBoosters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyBoostersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.findMany()
     * 
     * // Get first 10 DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyBoostersWithIdOnly = await prisma.dailyBoosters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyBoostersFindManyArgs>(args?: SelectSubset<T, DailyBoostersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyBoosters.
     * @param {DailyBoostersCreateArgs} args - Arguments to create a DailyBoosters.
     * @example
     * // Create one DailyBoosters
     * const DailyBoosters = await prisma.dailyBoosters.create({
     *   data: {
     *     // ... data to create a DailyBoosters
     *   }
     * })
     * 
     */
    create<T extends DailyBoostersCreateArgs>(args: SelectSubset<T, DailyBoostersCreateArgs<ExtArgs>>): Prisma__DailyBoostersClient<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyBoosters.
     * @param {DailyBoostersCreateManyArgs} args - Arguments to create many DailyBoosters.
     * @example
     * // Create many DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyBoostersCreateManyArgs>(args?: SelectSubset<T, DailyBoostersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DailyBoosters.
     * @param {DailyBoostersDeleteArgs} args - Arguments to delete one DailyBoosters.
     * @example
     * // Delete one DailyBoosters
     * const DailyBoosters = await prisma.dailyBoosters.delete({
     *   where: {
     *     // ... filter to delete one DailyBoosters
     *   }
     * })
     * 
     */
    delete<T extends DailyBoostersDeleteArgs>(args: SelectSubset<T, DailyBoostersDeleteArgs<ExtArgs>>): Prisma__DailyBoostersClient<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyBoosters.
     * @param {DailyBoostersUpdateArgs} args - Arguments to update one DailyBoosters.
     * @example
     * // Update one DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyBoostersUpdateArgs>(args: SelectSubset<T, DailyBoostersUpdateArgs<ExtArgs>>): Prisma__DailyBoostersClient<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyBoosters.
     * @param {DailyBoostersDeleteManyArgs} args - Arguments to filter DailyBoosters to delete.
     * @example
     * // Delete a few DailyBoosters
     * const { count } = await prisma.dailyBoosters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyBoostersDeleteManyArgs>(args?: SelectSubset<T, DailyBoostersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyBoosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyBoostersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyBoostersUpdateManyArgs>(args: SelectSubset<T, DailyBoostersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyBoosters.
     * @param {DailyBoostersUpsertArgs} args - Arguments to update or create a DailyBoosters.
     * @example
     * // Update or create a DailyBoosters
     * const dailyBoosters = await prisma.dailyBoosters.upsert({
     *   create: {
     *     // ... data to create a DailyBoosters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyBoosters we want to update
     *   }
     * })
     */
    upsert<T extends DailyBoostersUpsertArgs>(args: SelectSubset<T, DailyBoostersUpsertArgs<ExtArgs>>): Prisma__DailyBoostersClient<$Result.GetResult<Prisma.$DailyBoostersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DailyBoosters that matches the filter.
     * @param {DailyBoostersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dailyBoosters = await prisma.dailyBoosters.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DailyBoostersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DailyBoosters.
     * @param {DailyBoostersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dailyBoosters = await prisma.dailyBoosters.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DailyBoostersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DailyBoosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyBoostersCountArgs} args - Arguments to filter DailyBoosters to count.
     * @example
     * // Count the number of DailyBoosters
     * const count = await prisma.dailyBoosters.count({
     *   where: {
     *     // ... the filter for the DailyBoosters we want to count
     *   }
     * })
    **/
    count<T extends DailyBoostersCountArgs>(
      args?: Subset<T, DailyBoostersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyBoostersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyBoosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyBoostersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyBoostersAggregateArgs>(args: Subset<T, DailyBoostersAggregateArgs>): Prisma.PrismaPromise<GetDailyBoostersAggregateType<T>>

    /**
     * Group by DailyBoosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyBoostersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyBoostersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyBoostersGroupByArgs['orderBy'] }
        : { orderBy?: DailyBoostersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyBoostersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyBoostersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyBoosters model
   */
  readonly fields: DailyBoostersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyBoosters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyBoostersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyBoosters model
   */ 
  interface DailyBoostersFieldRefs {
    readonly id: FieldRef<"DailyBoosters", 'String'>
    readonly name: FieldRef<"DailyBoosters", 'String'>
    readonly count: FieldRef<"DailyBoosters", 'Int'>
    readonly icon: FieldRef<"DailyBoosters", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DailyBoosters findUnique
   */
  export type DailyBoostersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * Filter, which DailyBoosters to fetch.
     */
    where: DailyBoostersWhereUniqueInput
  }

  /**
   * DailyBoosters findUniqueOrThrow
   */
  export type DailyBoostersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * Filter, which DailyBoosters to fetch.
     */
    where: DailyBoostersWhereUniqueInput
  }

  /**
   * DailyBoosters findFirst
   */
  export type DailyBoostersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * Filter, which DailyBoosters to fetch.
     */
    where?: DailyBoostersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyBoosters to fetch.
     */
    orderBy?: DailyBoostersOrderByWithRelationInput | DailyBoostersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyBoosters.
     */
    cursor?: DailyBoostersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyBoosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyBoosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyBoosters.
     */
    distinct?: DailyBoostersScalarFieldEnum | DailyBoostersScalarFieldEnum[]
  }

  /**
   * DailyBoosters findFirstOrThrow
   */
  export type DailyBoostersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * Filter, which DailyBoosters to fetch.
     */
    where?: DailyBoostersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyBoosters to fetch.
     */
    orderBy?: DailyBoostersOrderByWithRelationInput | DailyBoostersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyBoosters.
     */
    cursor?: DailyBoostersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyBoosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyBoosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyBoosters.
     */
    distinct?: DailyBoostersScalarFieldEnum | DailyBoostersScalarFieldEnum[]
  }

  /**
   * DailyBoosters findMany
   */
  export type DailyBoostersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * Filter, which DailyBoosters to fetch.
     */
    where?: DailyBoostersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyBoosters to fetch.
     */
    orderBy?: DailyBoostersOrderByWithRelationInput | DailyBoostersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyBoosters.
     */
    cursor?: DailyBoostersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyBoosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyBoosters.
     */
    skip?: number
    distinct?: DailyBoostersScalarFieldEnum | DailyBoostersScalarFieldEnum[]
  }

  /**
   * DailyBoosters create
   */
  export type DailyBoostersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * The data needed to create a DailyBoosters.
     */
    data: XOR<DailyBoostersCreateInput, DailyBoostersUncheckedCreateInput>
  }

  /**
   * DailyBoosters createMany
   */
  export type DailyBoostersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyBoosters.
     */
    data: DailyBoostersCreateManyInput | DailyBoostersCreateManyInput[]
  }

  /**
   * DailyBoosters update
   */
  export type DailyBoostersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * The data needed to update a DailyBoosters.
     */
    data: XOR<DailyBoostersUpdateInput, DailyBoostersUncheckedUpdateInput>
    /**
     * Choose, which DailyBoosters to update.
     */
    where: DailyBoostersWhereUniqueInput
  }

  /**
   * DailyBoosters updateMany
   */
  export type DailyBoostersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyBoosters.
     */
    data: XOR<DailyBoostersUpdateManyMutationInput, DailyBoostersUncheckedUpdateManyInput>
    /**
     * Filter which DailyBoosters to update
     */
    where?: DailyBoostersWhereInput
  }

  /**
   * DailyBoosters upsert
   */
  export type DailyBoostersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * The filter to search for the DailyBoosters to update in case it exists.
     */
    where: DailyBoostersWhereUniqueInput
    /**
     * In case the DailyBoosters found by the `where` argument doesn't exist, create a new DailyBoosters with this data.
     */
    create: XOR<DailyBoostersCreateInput, DailyBoostersUncheckedCreateInput>
    /**
     * In case the DailyBoosters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyBoostersUpdateInput, DailyBoostersUncheckedUpdateInput>
  }

  /**
   * DailyBoosters delete
   */
  export type DailyBoostersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
    /**
     * Filter which DailyBoosters to delete.
     */
    where: DailyBoostersWhereUniqueInput
  }

  /**
   * DailyBoosters deleteMany
   */
  export type DailyBoostersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyBoosters to delete
     */
    where?: DailyBoostersWhereInput
  }

  /**
   * DailyBoosters findRaw
   */
  export type DailyBoostersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DailyBoosters aggregateRaw
   */
  export type DailyBoostersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DailyBoosters without action
   */
  export type DailyBoostersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyBoosters
     */
    select?: DailyBoostersSelect<ExtArgs> | null
  }


  /**
   * Model TaskCategories
   */

  export type AggregateTaskCategories = {
    _count: TaskCategoriesCountAggregateOutputType | null
    _min: TaskCategoriesMinAggregateOutputType | null
    _max: TaskCategoriesMaxAggregateOutputType | null
  }

  export type TaskCategoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TaskCategoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TaskCategoriesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TaskCategoriesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TaskCategoriesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TaskCategoriesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TaskCategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCategories to aggregate.
     */
    where?: TaskCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCategories to fetch.
     */
    orderBy?: TaskCategoriesOrderByWithRelationInput | TaskCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskCategories
    **/
    _count?: true | TaskCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCategoriesMaxAggregateInputType
  }

  export type GetTaskCategoriesAggregateType<T extends TaskCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskCategories[P]>
      : GetScalarType<T[P], AggregateTaskCategories[P]>
  }




  export type TaskCategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCategoriesWhereInput
    orderBy?: TaskCategoriesOrderByWithAggregationInput | TaskCategoriesOrderByWithAggregationInput[]
    by: TaskCategoriesScalarFieldEnum[] | TaskCategoriesScalarFieldEnum
    having?: TaskCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCategoriesCountAggregateInputType | true
    _min?: TaskCategoriesMinAggregateInputType
    _max?: TaskCategoriesMaxAggregateInputType
  }

  export type TaskCategoriesGroupByOutputType = {
    id: string
    name: string
    _count: TaskCategoriesCountAggregateOutputType | null
    _min: TaskCategoriesMinAggregateOutputType | null
    _max: TaskCategoriesMaxAggregateOutputType | null
  }

  type GetTaskCategoriesGroupByPayload<T extends TaskCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type TaskCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["taskCategories"]>


  export type TaskCategoriesSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type $TaskCategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskCategories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["taskCategories"]>
    composites: {}
  }

  type TaskCategoriesGetPayload<S extends boolean | null | undefined | TaskCategoriesDefaultArgs> = $Result.GetResult<Prisma.$TaskCategoriesPayload, S>

  type TaskCategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskCategoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCategoriesCountAggregateInputType | true
    }

  export interface TaskCategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskCategories'], meta: { name: 'TaskCategories' } }
    /**
     * Find zero or one TaskCategories that matches the filter.
     * @param {TaskCategoriesFindUniqueArgs} args - Arguments to find a TaskCategories
     * @example
     * // Get one TaskCategories
     * const taskCategories = await prisma.taskCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCategoriesFindUniqueArgs>(args: SelectSubset<T, TaskCategoriesFindUniqueArgs<ExtArgs>>): Prisma__TaskCategoriesClient<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskCategories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskCategoriesFindUniqueOrThrowArgs} args - Arguments to find a TaskCategories
     * @example
     * // Get one TaskCategories
     * const taskCategories = await prisma.taskCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCategoriesClient<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCategoriesFindFirstArgs} args - Arguments to find a TaskCategories
     * @example
     * // Get one TaskCategories
     * const taskCategories = await prisma.taskCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCategoriesFindFirstArgs>(args?: SelectSubset<T, TaskCategoriesFindFirstArgs<ExtArgs>>): Prisma__TaskCategoriesClient<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCategoriesFindFirstOrThrowArgs} args - Arguments to find a TaskCategories
     * @example
     * // Get one TaskCategories
     * const taskCategories = await prisma.taskCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCategoriesClient<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskCategories
     * const taskCategories = await prisma.taskCategories.findMany()
     * 
     * // Get first 10 TaskCategories
     * const taskCategories = await prisma.taskCategories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCategoriesWithIdOnly = await prisma.taskCategories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCategoriesFindManyArgs>(args?: SelectSubset<T, TaskCategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskCategories.
     * @param {TaskCategoriesCreateArgs} args - Arguments to create a TaskCategories.
     * @example
     * // Create one TaskCategories
     * const TaskCategories = await prisma.taskCategories.create({
     *   data: {
     *     // ... data to create a TaskCategories
     *   }
     * })
     * 
     */
    create<T extends TaskCategoriesCreateArgs>(args: SelectSubset<T, TaskCategoriesCreateArgs<ExtArgs>>): Prisma__TaskCategoriesClient<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskCategories.
     * @param {TaskCategoriesCreateManyArgs} args - Arguments to create many TaskCategories.
     * @example
     * // Create many TaskCategories
     * const taskCategories = await prisma.taskCategories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCategoriesCreateManyArgs>(args?: SelectSubset<T, TaskCategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskCategories.
     * @param {TaskCategoriesDeleteArgs} args - Arguments to delete one TaskCategories.
     * @example
     * // Delete one TaskCategories
     * const TaskCategories = await prisma.taskCategories.delete({
     *   where: {
     *     // ... filter to delete one TaskCategories
     *   }
     * })
     * 
     */
    delete<T extends TaskCategoriesDeleteArgs>(args: SelectSubset<T, TaskCategoriesDeleteArgs<ExtArgs>>): Prisma__TaskCategoriesClient<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskCategories.
     * @param {TaskCategoriesUpdateArgs} args - Arguments to update one TaskCategories.
     * @example
     * // Update one TaskCategories
     * const taskCategories = await prisma.taskCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCategoriesUpdateArgs>(args: SelectSubset<T, TaskCategoriesUpdateArgs<ExtArgs>>): Prisma__TaskCategoriesClient<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskCategories.
     * @param {TaskCategoriesDeleteManyArgs} args - Arguments to filter TaskCategories to delete.
     * @example
     * // Delete a few TaskCategories
     * const { count } = await prisma.taskCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCategoriesDeleteManyArgs>(args?: SelectSubset<T, TaskCategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskCategories
     * const taskCategories = await prisma.taskCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCategoriesUpdateManyArgs>(args: SelectSubset<T, TaskCategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskCategories.
     * @param {TaskCategoriesUpsertArgs} args - Arguments to update or create a TaskCategories.
     * @example
     * // Update or create a TaskCategories
     * const taskCategories = await prisma.taskCategories.upsert({
     *   create: {
     *     // ... data to create a TaskCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskCategories we want to update
     *   }
     * })
     */
    upsert<T extends TaskCategoriesUpsertArgs>(args: SelectSubset<T, TaskCategoriesUpsertArgs<ExtArgs>>): Prisma__TaskCategoriesClient<$Result.GetResult<Prisma.$TaskCategoriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TaskCategories that matches the filter.
     * @param {TaskCategoriesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const taskCategories = await prisma.taskCategories.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TaskCategoriesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TaskCategories.
     * @param {TaskCategoriesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const taskCategories = await prisma.taskCategories.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TaskCategoriesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TaskCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCategoriesCountArgs} args - Arguments to filter TaskCategories to count.
     * @example
     * // Count the number of TaskCategories
     * const count = await prisma.taskCategories.count({
     *   where: {
     *     // ... the filter for the TaskCategories we want to count
     *   }
     * })
    **/
    count<T extends TaskCategoriesCountArgs>(
      args?: Subset<T, TaskCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCategoriesAggregateArgs>(args: Subset<T, TaskCategoriesAggregateArgs>): Prisma.PrismaPromise<GetTaskCategoriesAggregateType<T>>

    /**
     * Group by TaskCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: TaskCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskCategories model
   */
  readonly fields: TaskCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskCategories model
   */ 
  interface TaskCategoriesFieldRefs {
    readonly id: FieldRef<"TaskCategories", 'String'>
    readonly name: FieldRef<"TaskCategories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskCategories findUnique
   */
  export type TaskCategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which TaskCategories to fetch.
     */
    where: TaskCategoriesWhereUniqueInput
  }

  /**
   * TaskCategories findUniqueOrThrow
   */
  export type TaskCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which TaskCategories to fetch.
     */
    where: TaskCategoriesWhereUniqueInput
  }

  /**
   * TaskCategories findFirst
   */
  export type TaskCategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which TaskCategories to fetch.
     */
    where?: TaskCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCategories to fetch.
     */
    orderBy?: TaskCategoriesOrderByWithRelationInput | TaskCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCategories.
     */
    cursor?: TaskCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCategories.
     */
    distinct?: TaskCategoriesScalarFieldEnum | TaskCategoriesScalarFieldEnum[]
  }

  /**
   * TaskCategories findFirstOrThrow
   */
  export type TaskCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which TaskCategories to fetch.
     */
    where?: TaskCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCategories to fetch.
     */
    orderBy?: TaskCategoriesOrderByWithRelationInput | TaskCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCategories.
     */
    cursor?: TaskCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCategories.
     */
    distinct?: TaskCategoriesScalarFieldEnum | TaskCategoriesScalarFieldEnum[]
  }

  /**
   * TaskCategories findMany
   */
  export type TaskCategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which TaskCategories to fetch.
     */
    where?: TaskCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCategories to fetch.
     */
    orderBy?: TaskCategoriesOrderByWithRelationInput | TaskCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskCategories.
     */
    cursor?: TaskCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCategories.
     */
    skip?: number
    distinct?: TaskCategoriesScalarFieldEnum | TaskCategoriesScalarFieldEnum[]
  }

  /**
   * TaskCategories create
   */
  export type TaskCategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a TaskCategories.
     */
    data: XOR<TaskCategoriesCreateInput, TaskCategoriesUncheckedCreateInput>
  }

  /**
   * TaskCategories createMany
   */
  export type TaskCategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskCategories.
     */
    data: TaskCategoriesCreateManyInput | TaskCategoriesCreateManyInput[]
  }

  /**
   * TaskCategories update
   */
  export type TaskCategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a TaskCategories.
     */
    data: XOR<TaskCategoriesUpdateInput, TaskCategoriesUncheckedUpdateInput>
    /**
     * Choose, which TaskCategories to update.
     */
    where: TaskCategoriesWhereUniqueInput
  }

  /**
   * TaskCategories updateMany
   */
  export type TaskCategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskCategories.
     */
    data: XOR<TaskCategoriesUpdateManyMutationInput, TaskCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which TaskCategories to update
     */
    where?: TaskCategoriesWhereInput
  }

  /**
   * TaskCategories upsert
   */
  export type TaskCategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the TaskCategories to update in case it exists.
     */
    where: TaskCategoriesWhereUniqueInput
    /**
     * In case the TaskCategories found by the `where` argument doesn't exist, create a new TaskCategories with this data.
     */
    create: XOR<TaskCategoriesCreateInput, TaskCategoriesUncheckedCreateInput>
    /**
     * In case the TaskCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCategoriesUpdateInput, TaskCategoriesUncheckedUpdateInput>
  }

  /**
   * TaskCategories delete
   */
  export type TaskCategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
    /**
     * Filter which TaskCategories to delete.
     */
    where: TaskCategoriesWhereUniqueInput
  }

  /**
   * TaskCategories deleteMany
   */
  export type TaskCategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCategories to delete
     */
    where?: TaskCategoriesWhereInput
  }

  /**
   * TaskCategories findRaw
   */
  export type TaskCategoriesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TaskCategories aggregateRaw
   */
  export type TaskCategoriesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TaskCategories without action
   */
  export type TaskCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCategories
     */
    select?: TaskCategoriesSelect<ExtArgs> | null
  }


  /**
   * Model Tasks
   */

  export type AggregateTasks = {
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  export type TasksAvgAggregateOutputType = {
    points: number | null
  }

  export type TasksSumAggregateOutputType = {
    points: number | null
  }

  export type TasksMinAggregateOutputType = {
    id: string | null
    category: string | null
    name: string | null
    points: number | null
    link: string | null
    icon: string | null
  }

  export type TasksMaxAggregateOutputType = {
    id: string | null
    category: string | null
    name: string | null
    points: number | null
    link: string | null
    icon: string | null
  }

  export type TasksCountAggregateOutputType = {
    id: number
    category: number
    name: number
    points: number
    link: number
    icon: number
    _all: number
  }


  export type TasksAvgAggregateInputType = {
    points?: true
  }

  export type TasksSumAggregateInputType = {
    points?: true
  }

  export type TasksMinAggregateInputType = {
    id?: true
    category?: true
    name?: true
    points?: true
    link?: true
    icon?: true
  }

  export type TasksMaxAggregateInputType = {
    id?: true
    category?: true
    name?: true
    points?: true
    link?: true
    icon?: true
  }

  export type TasksCountAggregateInputType = {
    id?: true
    category?: true
    name?: true
    points?: true
    link?: true
    icon?: true
    _all?: true
  }

  export type TasksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to aggregate.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TasksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TasksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksMaxAggregateInputType
  }

  export type GetTasksAggregateType<T extends TasksAggregateArgs> = {
        [P in keyof T & keyof AggregateTasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasks[P]>
      : GetScalarType<T[P], AggregateTasks[P]>
  }




  export type TasksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithAggregationInput | TasksOrderByWithAggregationInput[]
    by: TasksScalarFieldEnum[] | TasksScalarFieldEnum
    having?: TasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksCountAggregateInputType | true
    _avg?: TasksAvgAggregateInputType
    _sum?: TasksSumAggregateInputType
    _min?: TasksMinAggregateInputType
    _max?: TasksMaxAggregateInputType
  }

  export type TasksGroupByOutputType = {
    id: string
    category: string
    name: string
    points: number
    link: string
    icon: string
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  type GetTasksGroupByPayload<T extends TasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksGroupByOutputType[P]>
            : GetScalarType<T[P], TasksGroupByOutputType[P]>
        }
      >
    >


  export type TasksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    name?: boolean
    points?: boolean
    link?: boolean
    icon?: boolean
    user?: boolean | Tasks$userArgs<ExtArgs>
    _count?: boolean | TasksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>


  export type TasksSelectScalar = {
    id?: boolean
    category?: boolean
    name?: boolean
    points?: boolean
    link?: boolean
    icon?: boolean
  }

  export type TasksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Tasks$userArgs<ExtArgs>
    _count?: boolean | TasksCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TasksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tasks"
    objects: {
      user: Prisma.$TasksCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      name: string
      points: number
      link: string
      icon: string
    }, ExtArgs["result"]["tasks"]>
    composites: {}
  }

  type TasksGetPayload<S extends boolean | null | undefined | TasksDefaultArgs> = $Result.GetResult<Prisma.$TasksPayload, S>

  type TasksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TasksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TasksCountAggregateInputType | true
    }

  export interface TasksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tasks'], meta: { name: 'Tasks' } }
    /**
     * Find zero or one Tasks that matches the filter.
     * @param {TasksFindUniqueArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TasksFindUniqueArgs>(args: SelectSubset<T, TasksFindUniqueArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tasks that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TasksFindUniqueOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TasksFindUniqueOrThrowArgs>(args: SelectSubset<T, TasksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TasksFindFirstArgs>(args?: SelectSubset<T, TasksFindFirstArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tasks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TasksFindFirstOrThrowArgs>(args?: SelectSubset<T, TasksFindFirstOrThrowArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.tasks.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.tasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tasksWithIdOnly = await prisma.tasks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TasksFindManyArgs>(args?: SelectSubset<T, TasksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tasks.
     * @param {TasksCreateArgs} args - Arguments to create a Tasks.
     * @example
     * // Create one Tasks
     * const Tasks = await prisma.tasks.create({
     *   data: {
     *     // ... data to create a Tasks
     *   }
     * })
     * 
     */
    create<T extends TasksCreateArgs>(args: SelectSubset<T, TasksCreateArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TasksCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const tasks = await prisma.tasks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TasksCreateManyArgs>(args?: SelectSubset<T, TasksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tasks.
     * @param {TasksDeleteArgs} args - Arguments to delete one Tasks.
     * @example
     * // Delete one Tasks
     * const Tasks = await prisma.tasks.delete({
     *   where: {
     *     // ... filter to delete one Tasks
     *   }
     * })
     * 
     */
    delete<T extends TasksDeleteArgs>(args: SelectSubset<T, TasksDeleteArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tasks.
     * @param {TasksUpdateArgs} args - Arguments to update one Tasks.
     * @example
     * // Update one Tasks
     * const tasks = await prisma.tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TasksUpdateArgs>(args: SelectSubset<T, TasksUpdateArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TasksDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TasksDeleteManyArgs>(args?: SelectSubset<T, TasksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TasksUpdateManyArgs>(args: SelectSubset<T, TasksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tasks.
     * @param {TasksUpsertArgs} args - Arguments to update or create a Tasks.
     * @example
     * // Update or create a Tasks
     * const tasks = await prisma.tasks.upsert({
     *   create: {
     *     // ... data to create a Tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tasks we want to update
     *   }
     * })
     */
    upsert<T extends TasksUpsertArgs>(args: SelectSubset<T, TasksUpsertArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * @param {TasksFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tasks = await prisma.tasks.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TasksFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tasks.
     * @param {TasksAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tasks = await prisma.tasks.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TasksAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.tasks.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TasksCountArgs>(
      args?: Subset<T, TasksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksAggregateArgs>(args: Subset<T, TasksAggregateArgs>): Prisma.PrismaPromise<GetTasksAggregateType<T>>

    /**
     * Group by Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksGroupByArgs['orderBy'] }
        : { orderBy?: TasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tasks model
   */
  readonly fields: TasksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TasksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Tasks$userArgs<ExtArgs> = {}>(args?: Subset<T, Tasks$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tasks model
   */ 
  interface TasksFieldRefs {
    readonly id: FieldRef<"Tasks", 'String'>
    readonly category: FieldRef<"Tasks", 'String'>
    readonly name: FieldRef<"Tasks", 'String'>
    readonly points: FieldRef<"Tasks", 'Int'>
    readonly link: FieldRef<"Tasks", 'String'>
    readonly icon: FieldRef<"Tasks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tasks findUnique
   */
  export type TasksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks findUniqueOrThrow
   */
  export type TasksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks findFirst
   */
  export type TasksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks findFirstOrThrow
   */
  export type TasksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks findMany
   */
  export type TasksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks create
   */
  export type TasksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The data needed to create a Tasks.
     */
    data: XOR<TasksCreateInput, TasksUncheckedCreateInput>
  }

  /**
   * Tasks createMany
   */
  export type TasksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TasksCreateManyInput | TasksCreateManyInput[]
  }

  /**
   * Tasks update
   */
  export type TasksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The data needed to update a Tasks.
     */
    data: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
    /**
     * Choose, which Tasks to update.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks updateMany
   */
  export type TasksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TasksWhereInput
  }

  /**
   * Tasks upsert
   */
  export type TasksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The filter to search for the Tasks to update in case it exists.
     */
    where: TasksWhereUniqueInput
    /**
     * In case the Tasks found by the `where` argument doesn't exist, create a new Tasks with this data.
     */
    create: XOR<TasksCreateInput, TasksUncheckedCreateInput>
    /**
     * In case the Tasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
  }

  /**
   * Tasks delete
   */
  export type TasksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter which Tasks to delete.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks deleteMany
   */
  export type TasksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TasksWhereInput
  }

  /**
   * Tasks findRaw
   */
  export type TasksFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tasks aggregateRaw
   */
  export type TasksAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tasks.user
   */
  export type Tasks$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    where?: TasksCompletionWhereInput
    orderBy?: TasksCompletionOrderByWithRelationInput | TasksCompletionOrderByWithRelationInput[]
    cursor?: TasksCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksCompletionScalarFieldEnum | TasksCompletionScalarFieldEnum[]
  }

  /**
   * Tasks without action
   */
  export type TasksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
  }


  /**
   * Model TasksCompletion
   */

  export type AggregateTasksCompletion = {
    _count: TasksCompletionCountAggregateOutputType | null
    _avg: TasksCompletionAvgAggregateOutputType | null
    _sum: TasksCompletionSumAggregateOutputType | null
    _min: TasksCompletionMinAggregateOutputType | null
    _max: TasksCompletionMaxAggregateOutputType | null
  }

  export type TasksCompletionAvgAggregateOutputType = {
    points: number | null
  }

  export type TasksCompletionSumAggregateOutputType = {
    points: number | null
  }

  export type TasksCompletionMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    points: number | null
  }

  export type TasksCompletionMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    points: number | null
  }

  export type TasksCompletionCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    points: number
    _all: number
  }


  export type TasksCompletionAvgAggregateInputType = {
    points?: true
  }

  export type TasksCompletionSumAggregateInputType = {
    points?: true
  }

  export type TasksCompletionMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    points?: true
  }

  export type TasksCompletionMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    points?: true
  }

  export type TasksCompletionCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    points?: true
    _all?: true
  }

  export type TasksCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TasksCompletion to aggregate.
     */
    where?: TasksCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksCompletions to fetch.
     */
    orderBy?: TasksCompletionOrderByWithRelationInput | TasksCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TasksCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TasksCompletions
    **/
    _count?: true | TasksCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TasksCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TasksCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksCompletionMaxAggregateInputType
  }

  export type GetTasksCompletionAggregateType<T extends TasksCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateTasksCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasksCompletion[P]>
      : GetScalarType<T[P], AggregateTasksCompletion[P]>
  }




  export type TasksCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksCompletionWhereInput
    orderBy?: TasksCompletionOrderByWithAggregationInput | TasksCompletionOrderByWithAggregationInput[]
    by: TasksCompletionScalarFieldEnum[] | TasksCompletionScalarFieldEnum
    having?: TasksCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksCompletionCountAggregateInputType | true
    _avg?: TasksCompletionAvgAggregateInputType
    _sum?: TasksCompletionSumAggregateInputType
    _min?: TasksCompletionMinAggregateInputType
    _max?: TasksCompletionMaxAggregateInputType
  }

  export type TasksCompletionGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    points: number
    _count: TasksCompletionCountAggregateOutputType | null
    _avg: TasksCompletionAvgAggregateOutputType | null
    _sum: TasksCompletionSumAggregateOutputType | null
    _min: TasksCompletionMinAggregateOutputType | null
    _max: TasksCompletionMaxAggregateOutputType | null
  }

  type GetTasksCompletionGroupByPayload<T extends TasksCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TasksCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], TasksCompletionGroupByOutputType[P]>
        }
      >
    >


  export type TasksCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    points?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TasksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasksCompletion"]>


  export type TasksCompletionSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    points?: boolean
  }

  export type TasksCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TasksDefaultArgs<ExtArgs>
  }

  export type $TasksCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TasksCompletion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      task: Prisma.$TasksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
      points: number
    }, ExtArgs["result"]["tasksCompletion"]>
    composites: {}
  }

  type TasksCompletionGetPayload<S extends boolean | null | undefined | TasksCompletionDefaultArgs> = $Result.GetResult<Prisma.$TasksCompletionPayload, S>

  type TasksCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TasksCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TasksCompletionCountAggregateInputType | true
    }

  export interface TasksCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TasksCompletion'], meta: { name: 'TasksCompletion' } }
    /**
     * Find zero or one TasksCompletion that matches the filter.
     * @param {TasksCompletionFindUniqueArgs} args - Arguments to find a TasksCompletion
     * @example
     * // Get one TasksCompletion
     * const tasksCompletion = await prisma.tasksCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TasksCompletionFindUniqueArgs>(args: SelectSubset<T, TasksCompletionFindUniqueArgs<ExtArgs>>): Prisma__TasksCompletionClient<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TasksCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TasksCompletionFindUniqueOrThrowArgs} args - Arguments to find a TasksCompletion
     * @example
     * // Get one TasksCompletion
     * const tasksCompletion = await prisma.tasksCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TasksCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, TasksCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TasksCompletionClient<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TasksCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCompletionFindFirstArgs} args - Arguments to find a TasksCompletion
     * @example
     * // Get one TasksCompletion
     * const tasksCompletion = await prisma.tasksCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TasksCompletionFindFirstArgs>(args?: SelectSubset<T, TasksCompletionFindFirstArgs<ExtArgs>>): Prisma__TasksCompletionClient<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TasksCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCompletionFindFirstOrThrowArgs} args - Arguments to find a TasksCompletion
     * @example
     * // Get one TasksCompletion
     * const tasksCompletion = await prisma.tasksCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TasksCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, TasksCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TasksCompletionClient<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TasksCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TasksCompletions
     * const tasksCompletions = await prisma.tasksCompletion.findMany()
     * 
     * // Get first 10 TasksCompletions
     * const tasksCompletions = await prisma.tasksCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tasksCompletionWithIdOnly = await prisma.tasksCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TasksCompletionFindManyArgs>(args?: SelectSubset<T, TasksCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TasksCompletion.
     * @param {TasksCompletionCreateArgs} args - Arguments to create a TasksCompletion.
     * @example
     * // Create one TasksCompletion
     * const TasksCompletion = await prisma.tasksCompletion.create({
     *   data: {
     *     // ... data to create a TasksCompletion
     *   }
     * })
     * 
     */
    create<T extends TasksCompletionCreateArgs>(args: SelectSubset<T, TasksCompletionCreateArgs<ExtArgs>>): Prisma__TasksCompletionClient<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TasksCompletions.
     * @param {TasksCompletionCreateManyArgs} args - Arguments to create many TasksCompletions.
     * @example
     * // Create many TasksCompletions
     * const tasksCompletion = await prisma.tasksCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TasksCompletionCreateManyArgs>(args?: SelectSubset<T, TasksCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TasksCompletion.
     * @param {TasksCompletionDeleteArgs} args - Arguments to delete one TasksCompletion.
     * @example
     * // Delete one TasksCompletion
     * const TasksCompletion = await prisma.tasksCompletion.delete({
     *   where: {
     *     // ... filter to delete one TasksCompletion
     *   }
     * })
     * 
     */
    delete<T extends TasksCompletionDeleteArgs>(args: SelectSubset<T, TasksCompletionDeleteArgs<ExtArgs>>): Prisma__TasksCompletionClient<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TasksCompletion.
     * @param {TasksCompletionUpdateArgs} args - Arguments to update one TasksCompletion.
     * @example
     * // Update one TasksCompletion
     * const tasksCompletion = await prisma.tasksCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TasksCompletionUpdateArgs>(args: SelectSubset<T, TasksCompletionUpdateArgs<ExtArgs>>): Prisma__TasksCompletionClient<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TasksCompletions.
     * @param {TasksCompletionDeleteManyArgs} args - Arguments to filter TasksCompletions to delete.
     * @example
     * // Delete a few TasksCompletions
     * const { count } = await prisma.tasksCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TasksCompletionDeleteManyArgs>(args?: SelectSubset<T, TasksCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TasksCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TasksCompletions
     * const tasksCompletion = await prisma.tasksCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TasksCompletionUpdateManyArgs>(args: SelectSubset<T, TasksCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TasksCompletion.
     * @param {TasksCompletionUpsertArgs} args - Arguments to update or create a TasksCompletion.
     * @example
     * // Update or create a TasksCompletion
     * const tasksCompletion = await prisma.tasksCompletion.upsert({
     *   create: {
     *     // ... data to create a TasksCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TasksCompletion we want to update
     *   }
     * })
     */
    upsert<T extends TasksCompletionUpsertArgs>(args: SelectSubset<T, TasksCompletionUpsertArgs<ExtArgs>>): Prisma__TasksCompletionClient<$Result.GetResult<Prisma.$TasksCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TasksCompletions that matches the filter.
     * @param {TasksCompletionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tasksCompletion = await prisma.tasksCompletion.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TasksCompletionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TasksCompletion.
     * @param {TasksCompletionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tasksCompletion = await prisma.tasksCompletion.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TasksCompletionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TasksCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCompletionCountArgs} args - Arguments to filter TasksCompletions to count.
     * @example
     * // Count the number of TasksCompletions
     * const count = await prisma.tasksCompletion.count({
     *   where: {
     *     // ... the filter for the TasksCompletions we want to count
     *   }
     * })
    **/
    count<T extends TasksCompletionCountArgs>(
      args?: Subset<T, TasksCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TasksCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksCompletionAggregateArgs>(args: Subset<T, TasksCompletionAggregateArgs>): Prisma.PrismaPromise<GetTasksCompletionAggregateType<T>>

    /**
     * Group by TasksCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksCompletionGroupByArgs['orderBy'] }
        : { orderBy?: TasksCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TasksCompletion model
   */
  readonly fields: TasksCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TasksCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TasksCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends TasksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TasksDefaultArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TasksCompletion model
   */ 
  interface TasksCompletionFieldRefs {
    readonly id: FieldRef<"TasksCompletion", 'String'>
    readonly taskId: FieldRef<"TasksCompletion", 'String'>
    readonly userId: FieldRef<"TasksCompletion", 'String'>
    readonly points: FieldRef<"TasksCompletion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TasksCompletion findUnique
   */
  export type TasksCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TasksCompletion to fetch.
     */
    where: TasksCompletionWhereUniqueInput
  }

  /**
   * TasksCompletion findUniqueOrThrow
   */
  export type TasksCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TasksCompletion to fetch.
     */
    where: TasksCompletionWhereUniqueInput
  }

  /**
   * TasksCompletion findFirst
   */
  export type TasksCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TasksCompletion to fetch.
     */
    where?: TasksCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksCompletions to fetch.
     */
    orderBy?: TasksCompletionOrderByWithRelationInput | TasksCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TasksCompletions.
     */
    cursor?: TasksCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TasksCompletions.
     */
    distinct?: TasksCompletionScalarFieldEnum | TasksCompletionScalarFieldEnum[]
  }

  /**
   * TasksCompletion findFirstOrThrow
   */
  export type TasksCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TasksCompletion to fetch.
     */
    where?: TasksCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksCompletions to fetch.
     */
    orderBy?: TasksCompletionOrderByWithRelationInput | TasksCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TasksCompletions.
     */
    cursor?: TasksCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TasksCompletions.
     */
    distinct?: TasksCompletionScalarFieldEnum | TasksCompletionScalarFieldEnum[]
  }

  /**
   * TasksCompletion findMany
   */
  export type TasksCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TasksCompletions to fetch.
     */
    where?: TasksCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksCompletions to fetch.
     */
    orderBy?: TasksCompletionOrderByWithRelationInput | TasksCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TasksCompletions.
     */
    cursor?: TasksCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksCompletions.
     */
    skip?: number
    distinct?: TasksCompletionScalarFieldEnum | TasksCompletionScalarFieldEnum[]
  }

  /**
   * TasksCompletion create
   */
  export type TasksCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a TasksCompletion.
     */
    data: XOR<TasksCompletionCreateInput, TasksCompletionUncheckedCreateInput>
  }

  /**
   * TasksCompletion createMany
   */
  export type TasksCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TasksCompletions.
     */
    data: TasksCompletionCreateManyInput | TasksCompletionCreateManyInput[]
  }

  /**
   * TasksCompletion update
   */
  export type TasksCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a TasksCompletion.
     */
    data: XOR<TasksCompletionUpdateInput, TasksCompletionUncheckedUpdateInput>
    /**
     * Choose, which TasksCompletion to update.
     */
    where: TasksCompletionWhereUniqueInput
  }

  /**
   * TasksCompletion updateMany
   */
  export type TasksCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TasksCompletions.
     */
    data: XOR<TasksCompletionUpdateManyMutationInput, TasksCompletionUncheckedUpdateManyInput>
    /**
     * Filter which TasksCompletions to update
     */
    where?: TasksCompletionWhereInput
  }

  /**
   * TasksCompletion upsert
   */
  export type TasksCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the TasksCompletion to update in case it exists.
     */
    where: TasksCompletionWhereUniqueInput
    /**
     * In case the TasksCompletion found by the `where` argument doesn't exist, create a new TasksCompletion with this data.
     */
    create: XOR<TasksCompletionCreateInput, TasksCompletionUncheckedCreateInput>
    /**
     * In case the TasksCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TasksCompletionUpdateInput, TasksCompletionUncheckedUpdateInput>
  }

  /**
   * TasksCompletion delete
   */
  export type TasksCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
    /**
     * Filter which TasksCompletion to delete.
     */
    where: TasksCompletionWhereUniqueInput
  }

  /**
   * TasksCompletion deleteMany
   */
  export type TasksCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TasksCompletions to delete
     */
    where?: TasksCompletionWhereInput
  }

  /**
   * TasksCompletion findRaw
   */
  export type TasksCompletionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TasksCompletion aggregateRaw
   */
  export type TasksCompletionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TasksCompletion without action
   */
  export type TasksCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCompletion
     */
    select?: TasksCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksCompletionInclude<ExtArgs> | null
  }


  /**
   * Model YouTube
   */

  export type AggregateYouTube = {
    _count: YouTubeCountAggregateOutputType | null
    _avg: YouTubeAvgAggregateOutputType | null
    _sum: YouTubeSumAggregateOutputType | null
    _min: YouTubeMinAggregateOutputType | null
    _max: YouTubeMaxAggregateOutputType | null
  }

  export type YouTubeAvgAggregateOutputType = {
    points: number | null
  }

  export type YouTubeSumAggregateOutputType = {
    points: number | null
  }

  export type YouTubeMinAggregateOutputType = {
    id: string | null
    category: string | null
    name: string | null
    points: number | null
    link: string | null
    icon: string | null
  }

  export type YouTubeMaxAggregateOutputType = {
    id: string | null
    category: string | null
    name: string | null
    points: number | null
    link: string | null
    icon: string | null
  }

  export type YouTubeCountAggregateOutputType = {
    id: number
    category: number
    name: number
    points: number
    link: number
    icon: number
    _all: number
  }


  export type YouTubeAvgAggregateInputType = {
    points?: true
  }

  export type YouTubeSumAggregateInputType = {
    points?: true
  }

  export type YouTubeMinAggregateInputType = {
    id?: true
    category?: true
    name?: true
    points?: true
    link?: true
    icon?: true
  }

  export type YouTubeMaxAggregateInputType = {
    id?: true
    category?: true
    name?: true
    points?: true
    link?: true
    icon?: true
  }

  export type YouTubeCountAggregateInputType = {
    id?: true
    category?: true
    name?: true
    points?: true
    link?: true
    icon?: true
    _all?: true
  }

  export type YouTubeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YouTube to aggregate.
     */
    where?: YouTubeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubes to fetch.
     */
    orderBy?: YouTubeOrderByWithRelationInput | YouTubeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YouTubeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YouTubes
    **/
    _count?: true | YouTubeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YouTubeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YouTubeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YouTubeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YouTubeMaxAggregateInputType
  }

  export type GetYouTubeAggregateType<T extends YouTubeAggregateArgs> = {
        [P in keyof T & keyof AggregateYouTube]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYouTube[P]>
      : GetScalarType<T[P], AggregateYouTube[P]>
  }




  export type YouTubeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YouTubeWhereInput
    orderBy?: YouTubeOrderByWithAggregationInput | YouTubeOrderByWithAggregationInput[]
    by: YouTubeScalarFieldEnum[] | YouTubeScalarFieldEnum
    having?: YouTubeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YouTubeCountAggregateInputType | true
    _avg?: YouTubeAvgAggregateInputType
    _sum?: YouTubeSumAggregateInputType
    _min?: YouTubeMinAggregateInputType
    _max?: YouTubeMaxAggregateInputType
  }

  export type YouTubeGroupByOutputType = {
    id: string
    category: string
    name: string
    points: number
    link: string
    icon: string
    _count: YouTubeCountAggregateOutputType | null
    _avg: YouTubeAvgAggregateOutputType | null
    _sum: YouTubeSumAggregateOutputType | null
    _min: YouTubeMinAggregateOutputType | null
    _max: YouTubeMaxAggregateOutputType | null
  }

  type GetYouTubeGroupByPayload<T extends YouTubeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YouTubeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YouTubeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YouTubeGroupByOutputType[P]>
            : GetScalarType<T[P], YouTubeGroupByOutputType[P]>
        }
      >
    >


  export type YouTubeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    name?: boolean
    points?: boolean
    link?: boolean
    icon?: boolean
    user?: boolean | YouTube$userArgs<ExtArgs>
    _count?: boolean | YouTubeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["youTube"]>


  export type YouTubeSelectScalar = {
    id?: boolean
    category?: boolean
    name?: boolean
    points?: boolean
    link?: boolean
    icon?: boolean
  }

  export type YouTubeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | YouTube$userArgs<ExtArgs>
    _count?: boolean | YouTubeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $YouTubePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YouTube"
    objects: {
      user: Prisma.$YouTubeCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      name: string
      points: number
      link: string
      icon: string
    }, ExtArgs["result"]["youTube"]>
    composites: {}
  }

  type YouTubeGetPayload<S extends boolean | null | undefined | YouTubeDefaultArgs> = $Result.GetResult<Prisma.$YouTubePayload, S>

  type YouTubeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<YouTubeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: YouTubeCountAggregateInputType | true
    }

  export interface YouTubeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YouTube'], meta: { name: 'YouTube' } }
    /**
     * Find zero or one YouTube that matches the filter.
     * @param {YouTubeFindUniqueArgs} args - Arguments to find a YouTube
     * @example
     * // Get one YouTube
     * const youTube = await prisma.youTube.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YouTubeFindUniqueArgs>(args: SelectSubset<T, YouTubeFindUniqueArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one YouTube that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {YouTubeFindUniqueOrThrowArgs} args - Arguments to find a YouTube
     * @example
     * // Get one YouTube
     * const youTube = await prisma.youTube.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YouTubeFindUniqueOrThrowArgs>(args: SelectSubset<T, YouTubeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first YouTube that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeFindFirstArgs} args - Arguments to find a YouTube
     * @example
     * // Get one YouTube
     * const youTube = await prisma.youTube.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YouTubeFindFirstArgs>(args?: SelectSubset<T, YouTubeFindFirstArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first YouTube that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeFindFirstOrThrowArgs} args - Arguments to find a YouTube
     * @example
     * // Get one YouTube
     * const youTube = await prisma.youTube.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YouTubeFindFirstOrThrowArgs>(args?: SelectSubset<T, YouTubeFindFirstOrThrowArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more YouTubes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YouTubes
     * const youTubes = await prisma.youTube.findMany()
     * 
     * // Get first 10 YouTubes
     * const youTubes = await prisma.youTube.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youTubeWithIdOnly = await prisma.youTube.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YouTubeFindManyArgs>(args?: SelectSubset<T, YouTubeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a YouTube.
     * @param {YouTubeCreateArgs} args - Arguments to create a YouTube.
     * @example
     * // Create one YouTube
     * const YouTube = await prisma.youTube.create({
     *   data: {
     *     // ... data to create a YouTube
     *   }
     * })
     * 
     */
    create<T extends YouTubeCreateArgs>(args: SelectSubset<T, YouTubeCreateArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many YouTubes.
     * @param {YouTubeCreateManyArgs} args - Arguments to create many YouTubes.
     * @example
     * // Create many YouTubes
     * const youTube = await prisma.youTube.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YouTubeCreateManyArgs>(args?: SelectSubset<T, YouTubeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YouTube.
     * @param {YouTubeDeleteArgs} args - Arguments to delete one YouTube.
     * @example
     * // Delete one YouTube
     * const YouTube = await prisma.youTube.delete({
     *   where: {
     *     // ... filter to delete one YouTube
     *   }
     * })
     * 
     */
    delete<T extends YouTubeDeleteArgs>(args: SelectSubset<T, YouTubeDeleteArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one YouTube.
     * @param {YouTubeUpdateArgs} args - Arguments to update one YouTube.
     * @example
     * // Update one YouTube
     * const youTube = await prisma.youTube.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YouTubeUpdateArgs>(args: SelectSubset<T, YouTubeUpdateArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more YouTubes.
     * @param {YouTubeDeleteManyArgs} args - Arguments to filter YouTubes to delete.
     * @example
     * // Delete a few YouTubes
     * const { count } = await prisma.youTube.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YouTubeDeleteManyArgs>(args?: SelectSubset<T, YouTubeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YouTubes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YouTubes
     * const youTube = await prisma.youTube.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YouTubeUpdateManyArgs>(args: SelectSubset<T, YouTubeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YouTube.
     * @param {YouTubeUpsertArgs} args - Arguments to update or create a YouTube.
     * @example
     * // Update or create a YouTube
     * const youTube = await prisma.youTube.upsert({
     *   create: {
     *     // ... data to create a YouTube
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YouTube we want to update
     *   }
     * })
     */
    upsert<T extends YouTubeUpsertArgs>(args: SelectSubset<T, YouTubeUpsertArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more YouTubes that matches the filter.
     * @param {YouTubeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const youTube = await prisma.youTube.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: YouTubeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a YouTube.
     * @param {YouTubeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const youTube = await prisma.youTube.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: YouTubeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of YouTubes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCountArgs} args - Arguments to filter YouTubes to count.
     * @example
     * // Count the number of YouTubes
     * const count = await prisma.youTube.count({
     *   where: {
     *     // ... the filter for the YouTubes we want to count
     *   }
     * })
    **/
    count<T extends YouTubeCountArgs>(
      args?: Subset<T, YouTubeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YouTubeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YouTube.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YouTubeAggregateArgs>(args: Subset<T, YouTubeAggregateArgs>): Prisma.PrismaPromise<GetYouTubeAggregateType<T>>

    /**
     * Group by YouTube.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YouTubeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YouTubeGroupByArgs['orderBy'] }
        : { orderBy?: YouTubeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YouTubeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYouTubeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YouTube model
   */
  readonly fields: YouTubeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YouTube.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YouTubeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends YouTube$userArgs<ExtArgs> = {}>(args?: Subset<T, YouTube$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YouTube model
   */ 
  interface YouTubeFieldRefs {
    readonly id: FieldRef<"YouTube", 'String'>
    readonly category: FieldRef<"YouTube", 'String'>
    readonly name: FieldRef<"YouTube", 'String'>
    readonly points: FieldRef<"YouTube", 'Int'>
    readonly link: FieldRef<"YouTube", 'String'>
    readonly icon: FieldRef<"YouTube", 'String'>
  }
    

  // Custom InputTypes
  /**
   * YouTube findUnique
   */
  export type YouTubeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * Filter, which YouTube to fetch.
     */
    where: YouTubeWhereUniqueInput
  }

  /**
   * YouTube findUniqueOrThrow
   */
  export type YouTubeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * Filter, which YouTube to fetch.
     */
    where: YouTubeWhereUniqueInput
  }

  /**
   * YouTube findFirst
   */
  export type YouTubeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * Filter, which YouTube to fetch.
     */
    where?: YouTubeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubes to fetch.
     */
    orderBy?: YouTubeOrderByWithRelationInput | YouTubeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubes.
     */
    cursor?: YouTubeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubes.
     */
    distinct?: YouTubeScalarFieldEnum | YouTubeScalarFieldEnum[]
  }

  /**
   * YouTube findFirstOrThrow
   */
  export type YouTubeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * Filter, which YouTube to fetch.
     */
    where?: YouTubeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubes to fetch.
     */
    orderBy?: YouTubeOrderByWithRelationInput | YouTubeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubes.
     */
    cursor?: YouTubeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubes.
     */
    distinct?: YouTubeScalarFieldEnum | YouTubeScalarFieldEnum[]
  }

  /**
   * YouTube findMany
   */
  export type YouTubeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * Filter, which YouTubes to fetch.
     */
    where?: YouTubeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubes to fetch.
     */
    orderBy?: YouTubeOrderByWithRelationInput | YouTubeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YouTubes.
     */
    cursor?: YouTubeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubes.
     */
    skip?: number
    distinct?: YouTubeScalarFieldEnum | YouTubeScalarFieldEnum[]
  }

  /**
   * YouTube create
   */
  export type YouTubeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * The data needed to create a YouTube.
     */
    data: XOR<YouTubeCreateInput, YouTubeUncheckedCreateInput>
  }

  /**
   * YouTube createMany
   */
  export type YouTubeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YouTubes.
     */
    data: YouTubeCreateManyInput | YouTubeCreateManyInput[]
  }

  /**
   * YouTube update
   */
  export type YouTubeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * The data needed to update a YouTube.
     */
    data: XOR<YouTubeUpdateInput, YouTubeUncheckedUpdateInput>
    /**
     * Choose, which YouTube to update.
     */
    where: YouTubeWhereUniqueInput
  }

  /**
   * YouTube updateMany
   */
  export type YouTubeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YouTubes.
     */
    data: XOR<YouTubeUpdateManyMutationInput, YouTubeUncheckedUpdateManyInput>
    /**
     * Filter which YouTubes to update
     */
    where?: YouTubeWhereInput
  }

  /**
   * YouTube upsert
   */
  export type YouTubeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * The filter to search for the YouTube to update in case it exists.
     */
    where: YouTubeWhereUniqueInput
    /**
     * In case the YouTube found by the `where` argument doesn't exist, create a new YouTube with this data.
     */
    create: XOR<YouTubeCreateInput, YouTubeUncheckedCreateInput>
    /**
     * In case the YouTube was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YouTubeUpdateInput, YouTubeUncheckedUpdateInput>
  }

  /**
   * YouTube delete
   */
  export type YouTubeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
    /**
     * Filter which YouTube to delete.
     */
    where: YouTubeWhereUniqueInput
  }

  /**
   * YouTube deleteMany
   */
  export type YouTubeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YouTubes to delete
     */
    where?: YouTubeWhereInput
  }

  /**
   * YouTube findRaw
   */
  export type YouTubeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * YouTube aggregateRaw
   */
  export type YouTubeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * YouTube.user
   */
  export type YouTube$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    where?: YouTubeCompletionWhereInput
    orderBy?: YouTubeCompletionOrderByWithRelationInput | YouTubeCompletionOrderByWithRelationInput[]
    cursor?: YouTubeCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YouTubeCompletionScalarFieldEnum | YouTubeCompletionScalarFieldEnum[]
  }

  /**
   * YouTube without action
   */
  export type YouTubeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTube
     */
    select?: YouTubeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeInclude<ExtArgs> | null
  }


  /**
   * Model YouTubeCompletion
   */

  export type AggregateYouTubeCompletion = {
    _count: YouTubeCompletionCountAggregateOutputType | null
    _avg: YouTubeCompletionAvgAggregateOutputType | null
    _sum: YouTubeCompletionSumAggregateOutputType | null
    _min: YouTubeCompletionMinAggregateOutputType | null
    _max: YouTubeCompletionMaxAggregateOutputType | null
  }

  export type YouTubeCompletionAvgAggregateOutputType = {
    points: number | null
  }

  export type YouTubeCompletionSumAggregateOutputType = {
    points: number | null
  }

  export type YouTubeCompletionMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    points: number | null
  }

  export type YouTubeCompletionMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    points: number | null
  }

  export type YouTubeCompletionCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    points: number
    _all: number
  }


  export type YouTubeCompletionAvgAggregateInputType = {
    points?: true
  }

  export type YouTubeCompletionSumAggregateInputType = {
    points?: true
  }

  export type YouTubeCompletionMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    points?: true
  }

  export type YouTubeCompletionMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    points?: true
  }

  export type YouTubeCompletionCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    points?: true
    _all?: true
  }

  export type YouTubeCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YouTubeCompletion to aggregate.
     */
    where?: YouTubeCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeCompletions to fetch.
     */
    orderBy?: YouTubeCompletionOrderByWithRelationInput | YouTubeCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YouTubeCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YouTubeCompletions
    **/
    _count?: true | YouTubeCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YouTubeCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YouTubeCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YouTubeCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YouTubeCompletionMaxAggregateInputType
  }

  export type GetYouTubeCompletionAggregateType<T extends YouTubeCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateYouTubeCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYouTubeCompletion[P]>
      : GetScalarType<T[P], AggregateYouTubeCompletion[P]>
  }




  export type YouTubeCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YouTubeCompletionWhereInput
    orderBy?: YouTubeCompletionOrderByWithAggregationInput | YouTubeCompletionOrderByWithAggregationInput[]
    by: YouTubeCompletionScalarFieldEnum[] | YouTubeCompletionScalarFieldEnum
    having?: YouTubeCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YouTubeCompletionCountAggregateInputType | true
    _avg?: YouTubeCompletionAvgAggregateInputType
    _sum?: YouTubeCompletionSumAggregateInputType
    _min?: YouTubeCompletionMinAggregateInputType
    _max?: YouTubeCompletionMaxAggregateInputType
  }

  export type YouTubeCompletionGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    points: number
    _count: YouTubeCompletionCountAggregateOutputType | null
    _avg: YouTubeCompletionAvgAggregateOutputType | null
    _sum: YouTubeCompletionSumAggregateOutputType | null
    _min: YouTubeCompletionMinAggregateOutputType | null
    _max: YouTubeCompletionMaxAggregateOutputType | null
  }

  type GetYouTubeCompletionGroupByPayload<T extends YouTubeCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YouTubeCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YouTubeCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YouTubeCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], YouTubeCompletionGroupByOutputType[P]>
        }
      >
    >


  export type YouTubeCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    points?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | YouTubeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["youTubeCompletion"]>


  export type YouTubeCompletionSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    points?: boolean
  }

  export type YouTubeCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | YouTubeDefaultArgs<ExtArgs>
  }

  export type $YouTubeCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YouTubeCompletion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      task: Prisma.$YouTubePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
      points: number
    }, ExtArgs["result"]["youTubeCompletion"]>
    composites: {}
  }

  type YouTubeCompletionGetPayload<S extends boolean | null | undefined | YouTubeCompletionDefaultArgs> = $Result.GetResult<Prisma.$YouTubeCompletionPayload, S>

  type YouTubeCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<YouTubeCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: YouTubeCompletionCountAggregateInputType | true
    }

  export interface YouTubeCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YouTubeCompletion'], meta: { name: 'YouTubeCompletion' } }
    /**
     * Find zero or one YouTubeCompletion that matches the filter.
     * @param {YouTubeCompletionFindUniqueArgs} args - Arguments to find a YouTubeCompletion
     * @example
     * // Get one YouTubeCompletion
     * const youTubeCompletion = await prisma.youTubeCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YouTubeCompletionFindUniqueArgs>(args: SelectSubset<T, YouTubeCompletionFindUniqueArgs<ExtArgs>>): Prisma__YouTubeCompletionClient<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one YouTubeCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {YouTubeCompletionFindUniqueOrThrowArgs} args - Arguments to find a YouTubeCompletion
     * @example
     * // Get one YouTubeCompletion
     * const youTubeCompletion = await prisma.youTubeCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YouTubeCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, YouTubeCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YouTubeCompletionClient<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first YouTubeCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCompletionFindFirstArgs} args - Arguments to find a YouTubeCompletion
     * @example
     * // Get one YouTubeCompletion
     * const youTubeCompletion = await prisma.youTubeCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YouTubeCompletionFindFirstArgs>(args?: SelectSubset<T, YouTubeCompletionFindFirstArgs<ExtArgs>>): Prisma__YouTubeCompletionClient<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first YouTubeCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCompletionFindFirstOrThrowArgs} args - Arguments to find a YouTubeCompletion
     * @example
     * // Get one YouTubeCompletion
     * const youTubeCompletion = await prisma.youTubeCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YouTubeCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, YouTubeCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__YouTubeCompletionClient<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more YouTubeCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YouTubeCompletions
     * const youTubeCompletions = await prisma.youTubeCompletion.findMany()
     * 
     * // Get first 10 YouTubeCompletions
     * const youTubeCompletions = await prisma.youTubeCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youTubeCompletionWithIdOnly = await prisma.youTubeCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YouTubeCompletionFindManyArgs>(args?: SelectSubset<T, YouTubeCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a YouTubeCompletion.
     * @param {YouTubeCompletionCreateArgs} args - Arguments to create a YouTubeCompletion.
     * @example
     * // Create one YouTubeCompletion
     * const YouTubeCompletion = await prisma.youTubeCompletion.create({
     *   data: {
     *     // ... data to create a YouTubeCompletion
     *   }
     * })
     * 
     */
    create<T extends YouTubeCompletionCreateArgs>(args: SelectSubset<T, YouTubeCompletionCreateArgs<ExtArgs>>): Prisma__YouTubeCompletionClient<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many YouTubeCompletions.
     * @param {YouTubeCompletionCreateManyArgs} args - Arguments to create many YouTubeCompletions.
     * @example
     * // Create many YouTubeCompletions
     * const youTubeCompletion = await prisma.youTubeCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YouTubeCompletionCreateManyArgs>(args?: SelectSubset<T, YouTubeCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YouTubeCompletion.
     * @param {YouTubeCompletionDeleteArgs} args - Arguments to delete one YouTubeCompletion.
     * @example
     * // Delete one YouTubeCompletion
     * const YouTubeCompletion = await prisma.youTubeCompletion.delete({
     *   where: {
     *     // ... filter to delete one YouTubeCompletion
     *   }
     * })
     * 
     */
    delete<T extends YouTubeCompletionDeleteArgs>(args: SelectSubset<T, YouTubeCompletionDeleteArgs<ExtArgs>>): Prisma__YouTubeCompletionClient<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one YouTubeCompletion.
     * @param {YouTubeCompletionUpdateArgs} args - Arguments to update one YouTubeCompletion.
     * @example
     * // Update one YouTubeCompletion
     * const youTubeCompletion = await prisma.youTubeCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YouTubeCompletionUpdateArgs>(args: SelectSubset<T, YouTubeCompletionUpdateArgs<ExtArgs>>): Prisma__YouTubeCompletionClient<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more YouTubeCompletions.
     * @param {YouTubeCompletionDeleteManyArgs} args - Arguments to filter YouTubeCompletions to delete.
     * @example
     * // Delete a few YouTubeCompletions
     * const { count } = await prisma.youTubeCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YouTubeCompletionDeleteManyArgs>(args?: SelectSubset<T, YouTubeCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YouTubeCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YouTubeCompletions
     * const youTubeCompletion = await prisma.youTubeCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YouTubeCompletionUpdateManyArgs>(args: SelectSubset<T, YouTubeCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YouTubeCompletion.
     * @param {YouTubeCompletionUpsertArgs} args - Arguments to update or create a YouTubeCompletion.
     * @example
     * // Update or create a YouTubeCompletion
     * const youTubeCompletion = await prisma.youTubeCompletion.upsert({
     *   create: {
     *     // ... data to create a YouTubeCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YouTubeCompletion we want to update
     *   }
     * })
     */
    upsert<T extends YouTubeCompletionUpsertArgs>(args: SelectSubset<T, YouTubeCompletionUpsertArgs<ExtArgs>>): Prisma__YouTubeCompletionClient<$Result.GetResult<Prisma.$YouTubeCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more YouTubeCompletions that matches the filter.
     * @param {YouTubeCompletionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const youTubeCompletion = await prisma.youTubeCompletion.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: YouTubeCompletionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a YouTubeCompletion.
     * @param {YouTubeCompletionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const youTubeCompletion = await prisma.youTubeCompletion.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: YouTubeCompletionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of YouTubeCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCompletionCountArgs} args - Arguments to filter YouTubeCompletions to count.
     * @example
     * // Count the number of YouTubeCompletions
     * const count = await prisma.youTubeCompletion.count({
     *   where: {
     *     // ... the filter for the YouTubeCompletions we want to count
     *   }
     * })
    **/
    count<T extends YouTubeCompletionCountArgs>(
      args?: Subset<T, YouTubeCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YouTubeCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YouTubeCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YouTubeCompletionAggregateArgs>(args: Subset<T, YouTubeCompletionAggregateArgs>): Prisma.PrismaPromise<GetYouTubeCompletionAggregateType<T>>

    /**
     * Group by YouTubeCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YouTubeCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YouTubeCompletionGroupByArgs['orderBy'] }
        : { orderBy?: YouTubeCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YouTubeCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYouTubeCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YouTubeCompletion model
   */
  readonly fields: YouTubeCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YouTubeCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YouTubeCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends YouTubeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YouTubeDefaultArgs<ExtArgs>>): Prisma__YouTubeClient<$Result.GetResult<Prisma.$YouTubePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YouTubeCompletion model
   */ 
  interface YouTubeCompletionFieldRefs {
    readonly id: FieldRef<"YouTubeCompletion", 'String'>
    readonly taskId: FieldRef<"YouTubeCompletion", 'String'>
    readonly userId: FieldRef<"YouTubeCompletion", 'String'>
    readonly points: FieldRef<"YouTubeCompletion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * YouTubeCompletion findUnique
   */
  export type YouTubeCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * Filter, which YouTubeCompletion to fetch.
     */
    where: YouTubeCompletionWhereUniqueInput
  }

  /**
   * YouTubeCompletion findUniqueOrThrow
   */
  export type YouTubeCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * Filter, which YouTubeCompletion to fetch.
     */
    where: YouTubeCompletionWhereUniqueInput
  }

  /**
   * YouTubeCompletion findFirst
   */
  export type YouTubeCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * Filter, which YouTubeCompletion to fetch.
     */
    where?: YouTubeCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeCompletions to fetch.
     */
    orderBy?: YouTubeCompletionOrderByWithRelationInput | YouTubeCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubeCompletions.
     */
    cursor?: YouTubeCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubeCompletions.
     */
    distinct?: YouTubeCompletionScalarFieldEnum | YouTubeCompletionScalarFieldEnum[]
  }

  /**
   * YouTubeCompletion findFirstOrThrow
   */
  export type YouTubeCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * Filter, which YouTubeCompletion to fetch.
     */
    where?: YouTubeCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeCompletions to fetch.
     */
    orderBy?: YouTubeCompletionOrderByWithRelationInput | YouTubeCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubeCompletions.
     */
    cursor?: YouTubeCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubeCompletions.
     */
    distinct?: YouTubeCompletionScalarFieldEnum | YouTubeCompletionScalarFieldEnum[]
  }

  /**
   * YouTubeCompletion findMany
   */
  export type YouTubeCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * Filter, which YouTubeCompletions to fetch.
     */
    where?: YouTubeCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeCompletions to fetch.
     */
    orderBy?: YouTubeCompletionOrderByWithRelationInput | YouTubeCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YouTubeCompletions.
     */
    cursor?: YouTubeCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeCompletions.
     */
    skip?: number
    distinct?: YouTubeCompletionScalarFieldEnum | YouTubeCompletionScalarFieldEnum[]
  }

  /**
   * YouTubeCompletion create
   */
  export type YouTubeCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a YouTubeCompletion.
     */
    data: XOR<YouTubeCompletionCreateInput, YouTubeCompletionUncheckedCreateInput>
  }

  /**
   * YouTubeCompletion createMany
   */
  export type YouTubeCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YouTubeCompletions.
     */
    data: YouTubeCompletionCreateManyInput | YouTubeCompletionCreateManyInput[]
  }

  /**
   * YouTubeCompletion update
   */
  export type YouTubeCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a YouTubeCompletion.
     */
    data: XOR<YouTubeCompletionUpdateInput, YouTubeCompletionUncheckedUpdateInput>
    /**
     * Choose, which YouTubeCompletion to update.
     */
    where: YouTubeCompletionWhereUniqueInput
  }

  /**
   * YouTubeCompletion updateMany
   */
  export type YouTubeCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YouTubeCompletions.
     */
    data: XOR<YouTubeCompletionUpdateManyMutationInput, YouTubeCompletionUncheckedUpdateManyInput>
    /**
     * Filter which YouTubeCompletions to update
     */
    where?: YouTubeCompletionWhereInput
  }

  /**
   * YouTubeCompletion upsert
   */
  export type YouTubeCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the YouTubeCompletion to update in case it exists.
     */
    where: YouTubeCompletionWhereUniqueInput
    /**
     * In case the YouTubeCompletion found by the `where` argument doesn't exist, create a new YouTubeCompletion with this data.
     */
    create: XOR<YouTubeCompletionCreateInput, YouTubeCompletionUncheckedCreateInput>
    /**
     * In case the YouTubeCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YouTubeCompletionUpdateInput, YouTubeCompletionUncheckedUpdateInput>
  }

  /**
   * YouTubeCompletion delete
   */
  export type YouTubeCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
    /**
     * Filter which YouTubeCompletion to delete.
     */
    where: YouTubeCompletionWhereUniqueInput
  }

  /**
   * YouTubeCompletion deleteMany
   */
  export type YouTubeCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YouTubeCompletions to delete
     */
    where?: YouTubeCompletionWhereInput
  }

  /**
   * YouTubeCompletion findRaw
   */
  export type YouTubeCompletionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * YouTubeCompletion aggregateRaw
   */
  export type YouTubeCompletionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * YouTubeCompletion without action
   */
  export type YouTubeCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCompletion
     */
    select?: YouTubeCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YouTubeCompletionInclude<ExtArgs> | null
  }


  /**
   * Model Skins
   */

  export type AggregateSkins = {
    _count: SkinsCountAggregateOutputType | null
    _avg: SkinsAvgAggregateOutputType | null
    _sum: SkinsSumAggregateOutputType | null
    _min: SkinsMinAggregateOutputType | null
    _max: SkinsMaxAggregateOutputType | null
  }

  export type SkinsAvgAggregateOutputType = {
    cost: number | null
  }

  export type SkinsSumAggregateOutputType = {
    cost: number | null
  }

  export type SkinsMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    cost: number | null
    featured: boolean | null
    league: string | null
  }

  export type SkinsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    cost: number | null
    featured: boolean | null
    league: string | null
  }

  export type SkinsCountAggregateOutputType = {
    id: number
    name: number
    image: number
    cost: number
    featured: number
    league: number
    _all: number
  }


  export type SkinsAvgAggregateInputType = {
    cost?: true
  }

  export type SkinsSumAggregateInputType = {
    cost?: true
  }

  export type SkinsMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    cost?: true
    featured?: true
    league?: true
  }

  export type SkinsMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    cost?: true
    featured?: true
    league?: true
  }

  export type SkinsCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    cost?: true
    featured?: true
    league?: true
    _all?: true
  }

  export type SkinsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skins to aggregate.
     */
    where?: SkinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skins to fetch.
     */
    orderBy?: SkinsOrderByWithRelationInput | SkinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skins
    **/
    _count?: true | SkinsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkinsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkinsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkinsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkinsMaxAggregateInputType
  }

  export type GetSkinsAggregateType<T extends SkinsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkins[P]>
      : GetScalarType<T[P], AggregateSkins[P]>
  }




  export type SkinsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkinsWhereInput
    orderBy?: SkinsOrderByWithAggregationInput | SkinsOrderByWithAggregationInput[]
    by: SkinsScalarFieldEnum[] | SkinsScalarFieldEnum
    having?: SkinsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkinsCountAggregateInputType | true
    _avg?: SkinsAvgAggregateInputType
    _sum?: SkinsSumAggregateInputType
    _min?: SkinsMinAggregateInputType
    _max?: SkinsMaxAggregateInputType
  }

  export type SkinsGroupByOutputType = {
    id: string
    name: string
    image: string
    cost: number
    featured: boolean
    league: string
    _count: SkinsCountAggregateOutputType | null
    _avg: SkinsAvgAggregateOutputType | null
    _sum: SkinsSumAggregateOutputType | null
    _min: SkinsMinAggregateOutputType | null
    _max: SkinsMaxAggregateOutputType | null
  }

  type GetSkinsGroupByPayload<T extends SkinsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkinsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkinsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkinsGroupByOutputType[P]>
            : GetScalarType<T[P], SkinsGroupByOutputType[P]>
        }
      >
    >


  export type SkinsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    cost?: boolean
    featured?: boolean
    league?: boolean
    users?: boolean | Skins$usersArgs<ExtArgs>
    _count?: boolean | SkinsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skins"]>


  export type SkinsSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    cost?: boolean
    featured?: boolean
    league?: boolean
  }

  export type SkinsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Skins$usersArgs<ExtArgs>
    _count?: boolean | SkinsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SkinsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skins"
    objects: {
      users: Prisma.$UserSkinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string
      cost: number
      featured: boolean
      league: string
    }, ExtArgs["result"]["skins"]>
    composites: {}
  }

  type SkinsGetPayload<S extends boolean | null | undefined | SkinsDefaultArgs> = $Result.GetResult<Prisma.$SkinsPayload, S>

  type SkinsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkinsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkinsCountAggregateInputType | true
    }

  export interface SkinsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skins'], meta: { name: 'Skins' } }
    /**
     * Find zero or one Skins that matches the filter.
     * @param {SkinsFindUniqueArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkinsFindUniqueArgs>(args: SelectSubset<T, SkinsFindUniqueArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skins that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkinsFindUniqueOrThrowArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkinsFindUniqueOrThrowArgs>(args: SelectSubset<T, SkinsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsFindFirstArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkinsFindFirstArgs>(args?: SelectSubset<T, SkinsFindFirstArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsFindFirstOrThrowArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkinsFindFirstOrThrowArgs>(args?: SelectSubset<T, SkinsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skins
     * const skins = await prisma.skins.findMany()
     * 
     * // Get first 10 Skins
     * const skins = await prisma.skins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skinsWithIdOnly = await prisma.skins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkinsFindManyArgs>(args?: SelectSubset<T, SkinsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skins.
     * @param {SkinsCreateArgs} args - Arguments to create a Skins.
     * @example
     * // Create one Skins
     * const Skins = await prisma.skins.create({
     *   data: {
     *     // ... data to create a Skins
     *   }
     * })
     * 
     */
    create<T extends SkinsCreateArgs>(args: SelectSubset<T, SkinsCreateArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skins.
     * @param {SkinsCreateManyArgs} args - Arguments to create many Skins.
     * @example
     * // Create many Skins
     * const skins = await prisma.skins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkinsCreateManyArgs>(args?: SelectSubset<T, SkinsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skins.
     * @param {SkinsDeleteArgs} args - Arguments to delete one Skins.
     * @example
     * // Delete one Skins
     * const Skins = await prisma.skins.delete({
     *   where: {
     *     // ... filter to delete one Skins
     *   }
     * })
     * 
     */
    delete<T extends SkinsDeleteArgs>(args: SelectSubset<T, SkinsDeleteArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skins.
     * @param {SkinsUpdateArgs} args - Arguments to update one Skins.
     * @example
     * // Update one Skins
     * const skins = await prisma.skins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkinsUpdateArgs>(args: SelectSubset<T, SkinsUpdateArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skins.
     * @param {SkinsDeleteManyArgs} args - Arguments to filter Skins to delete.
     * @example
     * // Delete a few Skins
     * const { count } = await prisma.skins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkinsDeleteManyArgs>(args?: SelectSubset<T, SkinsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skins
     * const skins = await prisma.skins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkinsUpdateManyArgs>(args: SelectSubset<T, SkinsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skins.
     * @param {SkinsUpsertArgs} args - Arguments to update or create a Skins.
     * @example
     * // Update or create a Skins
     * const skins = await prisma.skins.upsert({
     *   create: {
     *     // ... data to create a Skins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skins we want to update
     *   }
     * })
     */
    upsert<T extends SkinsUpsertArgs>(args: SelectSubset<T, SkinsUpsertArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Skins that matches the filter.
     * @param {SkinsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const skins = await prisma.skins.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SkinsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Skins.
     * @param {SkinsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const skins = await prisma.skins.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SkinsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsCountArgs} args - Arguments to filter Skins to count.
     * @example
     * // Count the number of Skins
     * const count = await prisma.skins.count({
     *   where: {
     *     // ... the filter for the Skins we want to count
     *   }
     * })
    **/
    count<T extends SkinsCountArgs>(
      args?: Subset<T, SkinsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkinsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkinsAggregateArgs>(args: Subset<T, SkinsAggregateArgs>): Prisma.PrismaPromise<GetSkinsAggregateType<T>>

    /**
     * Group by Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkinsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkinsGroupByArgs['orderBy'] }
        : { orderBy?: SkinsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkinsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkinsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skins model
   */
  readonly fields: SkinsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkinsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Skins$usersArgs<ExtArgs> = {}>(args?: Subset<T, Skins$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skins model
   */ 
  interface SkinsFieldRefs {
    readonly id: FieldRef<"Skins", 'String'>
    readonly name: FieldRef<"Skins", 'String'>
    readonly image: FieldRef<"Skins", 'String'>
    readonly cost: FieldRef<"Skins", 'Int'>
    readonly featured: FieldRef<"Skins", 'Boolean'>
    readonly league: FieldRef<"Skins", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Skins findUnique
   */
  export type SkinsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * Filter, which Skins to fetch.
     */
    where: SkinsWhereUniqueInput
  }

  /**
   * Skins findUniqueOrThrow
   */
  export type SkinsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * Filter, which Skins to fetch.
     */
    where: SkinsWhereUniqueInput
  }

  /**
   * Skins findFirst
   */
  export type SkinsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * Filter, which Skins to fetch.
     */
    where?: SkinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skins to fetch.
     */
    orderBy?: SkinsOrderByWithRelationInput | SkinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skins.
     */
    cursor?: SkinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skins.
     */
    distinct?: SkinsScalarFieldEnum | SkinsScalarFieldEnum[]
  }

  /**
   * Skins findFirstOrThrow
   */
  export type SkinsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * Filter, which Skins to fetch.
     */
    where?: SkinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skins to fetch.
     */
    orderBy?: SkinsOrderByWithRelationInput | SkinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skins.
     */
    cursor?: SkinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skins.
     */
    distinct?: SkinsScalarFieldEnum | SkinsScalarFieldEnum[]
  }

  /**
   * Skins findMany
   */
  export type SkinsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * Filter, which Skins to fetch.
     */
    where?: SkinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skins to fetch.
     */
    orderBy?: SkinsOrderByWithRelationInput | SkinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skins.
     */
    cursor?: SkinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skins.
     */
    skip?: number
    distinct?: SkinsScalarFieldEnum | SkinsScalarFieldEnum[]
  }

  /**
   * Skins create
   */
  export type SkinsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * The data needed to create a Skins.
     */
    data: XOR<SkinsCreateInput, SkinsUncheckedCreateInput>
  }

  /**
   * Skins createMany
   */
  export type SkinsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skins.
     */
    data: SkinsCreateManyInput | SkinsCreateManyInput[]
  }

  /**
   * Skins update
   */
  export type SkinsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * The data needed to update a Skins.
     */
    data: XOR<SkinsUpdateInput, SkinsUncheckedUpdateInput>
    /**
     * Choose, which Skins to update.
     */
    where: SkinsWhereUniqueInput
  }

  /**
   * Skins updateMany
   */
  export type SkinsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skins.
     */
    data: XOR<SkinsUpdateManyMutationInput, SkinsUncheckedUpdateManyInput>
    /**
     * Filter which Skins to update
     */
    where?: SkinsWhereInput
  }

  /**
   * Skins upsert
   */
  export type SkinsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * The filter to search for the Skins to update in case it exists.
     */
    where: SkinsWhereUniqueInput
    /**
     * In case the Skins found by the `where` argument doesn't exist, create a new Skins with this data.
     */
    create: XOR<SkinsCreateInput, SkinsUncheckedCreateInput>
    /**
     * In case the Skins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkinsUpdateInput, SkinsUncheckedUpdateInput>
  }

  /**
   * Skins delete
   */
  export type SkinsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
    /**
     * Filter which Skins to delete.
     */
    where: SkinsWhereUniqueInput
  }

  /**
   * Skins deleteMany
   */
  export type SkinsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skins to delete
     */
    where?: SkinsWhereInput
  }

  /**
   * Skins findRaw
   */
  export type SkinsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Skins aggregateRaw
   */
  export type SkinsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Skins.users
   */
  export type Skins$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    where?: UserSkinWhereInput
    orderBy?: UserSkinOrderByWithRelationInput | UserSkinOrderByWithRelationInput[]
    cursor?: UserSkinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkinScalarFieldEnum | UserSkinScalarFieldEnum[]
  }

  /**
   * Skins without action
   */
  export type SkinsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skins
     */
    select?: SkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkinsInclude<ExtArgs> | null
  }


  /**
   * Model UserSkin
   */

  export type AggregateUserSkin = {
    _count: UserSkinCountAggregateOutputType | null
    _min: UserSkinMinAggregateOutputType | null
    _max: UserSkinMaxAggregateOutputType | null
  }

  export type UserSkinMinAggregateOutputType = {
    id: string | null
    userId: string | null
    skinId: string | null
  }

  export type UserSkinMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    skinId: string | null
  }

  export type UserSkinCountAggregateOutputType = {
    id: number
    userId: number
    skinId: number
    _all: number
  }


  export type UserSkinMinAggregateInputType = {
    id?: true
    userId?: true
    skinId?: true
  }

  export type UserSkinMaxAggregateInputType = {
    id?: true
    userId?: true
    skinId?: true
  }

  export type UserSkinCountAggregateInputType = {
    id?: true
    userId?: true
    skinId?: true
    _all?: true
  }

  export type UserSkinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkin to aggregate.
     */
    where?: UserSkinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkins to fetch.
     */
    orderBy?: UserSkinOrderByWithRelationInput | UserSkinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSkinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSkins
    **/
    _count?: true | UserSkinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSkinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSkinMaxAggregateInputType
  }

  export type GetUserSkinAggregateType<T extends UserSkinAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSkin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSkin[P]>
      : GetScalarType<T[P], AggregateUserSkin[P]>
  }




  export type UserSkinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkinWhereInput
    orderBy?: UserSkinOrderByWithAggregationInput | UserSkinOrderByWithAggregationInput[]
    by: UserSkinScalarFieldEnum[] | UserSkinScalarFieldEnum
    having?: UserSkinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSkinCountAggregateInputType | true
    _min?: UserSkinMinAggregateInputType
    _max?: UserSkinMaxAggregateInputType
  }

  export type UserSkinGroupByOutputType = {
    id: string
    userId: string
    skinId: string
    _count: UserSkinCountAggregateOutputType | null
    _min: UserSkinMinAggregateOutputType | null
    _max: UserSkinMaxAggregateOutputType | null
  }

  type GetUserSkinGroupByPayload<T extends UserSkinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSkinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSkinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSkinGroupByOutputType[P]>
            : GetScalarType<T[P], UserSkinGroupByOutputType[P]>
        }
      >
    >


  export type UserSkinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skinId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skin?: boolean | SkinsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkin"]>


  export type UserSkinSelectScalar = {
    id?: boolean
    userId?: boolean
    skinId?: boolean
  }

  export type UserSkinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skin?: boolean | SkinsDefaultArgs<ExtArgs>
  }

  export type $UserSkinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSkin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skin: Prisma.$SkinsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      skinId: string
    }, ExtArgs["result"]["userSkin"]>
    composites: {}
  }

  type UserSkinGetPayload<S extends boolean | null | undefined | UserSkinDefaultArgs> = $Result.GetResult<Prisma.$UserSkinPayload, S>

  type UserSkinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSkinFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSkinCountAggregateInputType | true
    }

  export interface UserSkinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSkin'], meta: { name: 'UserSkin' } }
    /**
     * Find zero or one UserSkin that matches the filter.
     * @param {UserSkinFindUniqueArgs} args - Arguments to find a UserSkin
     * @example
     * // Get one UserSkin
     * const userSkin = await prisma.userSkin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSkinFindUniqueArgs>(args: SelectSubset<T, UserSkinFindUniqueArgs<ExtArgs>>): Prisma__UserSkinClient<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSkin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSkinFindUniqueOrThrowArgs} args - Arguments to find a UserSkin
     * @example
     * // Get one UserSkin
     * const userSkin = await prisma.userSkin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSkinFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSkinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSkinClient<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSkin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkinFindFirstArgs} args - Arguments to find a UserSkin
     * @example
     * // Get one UserSkin
     * const userSkin = await prisma.userSkin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSkinFindFirstArgs>(args?: SelectSubset<T, UserSkinFindFirstArgs<ExtArgs>>): Prisma__UserSkinClient<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSkin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkinFindFirstOrThrowArgs} args - Arguments to find a UserSkin
     * @example
     * // Get one UserSkin
     * const userSkin = await prisma.userSkin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSkinFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSkinFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSkinClient<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSkins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSkins
     * const userSkins = await prisma.userSkin.findMany()
     * 
     * // Get first 10 UserSkins
     * const userSkins = await prisma.userSkin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSkinWithIdOnly = await prisma.userSkin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSkinFindManyArgs>(args?: SelectSubset<T, UserSkinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSkin.
     * @param {UserSkinCreateArgs} args - Arguments to create a UserSkin.
     * @example
     * // Create one UserSkin
     * const UserSkin = await prisma.userSkin.create({
     *   data: {
     *     // ... data to create a UserSkin
     *   }
     * })
     * 
     */
    create<T extends UserSkinCreateArgs>(args: SelectSubset<T, UserSkinCreateArgs<ExtArgs>>): Prisma__UserSkinClient<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSkins.
     * @param {UserSkinCreateManyArgs} args - Arguments to create many UserSkins.
     * @example
     * // Create many UserSkins
     * const userSkin = await prisma.userSkin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSkinCreateManyArgs>(args?: SelectSubset<T, UserSkinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSkin.
     * @param {UserSkinDeleteArgs} args - Arguments to delete one UserSkin.
     * @example
     * // Delete one UserSkin
     * const UserSkin = await prisma.userSkin.delete({
     *   where: {
     *     // ... filter to delete one UserSkin
     *   }
     * })
     * 
     */
    delete<T extends UserSkinDeleteArgs>(args: SelectSubset<T, UserSkinDeleteArgs<ExtArgs>>): Prisma__UserSkinClient<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSkin.
     * @param {UserSkinUpdateArgs} args - Arguments to update one UserSkin.
     * @example
     * // Update one UserSkin
     * const userSkin = await prisma.userSkin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSkinUpdateArgs>(args: SelectSubset<T, UserSkinUpdateArgs<ExtArgs>>): Prisma__UserSkinClient<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSkins.
     * @param {UserSkinDeleteManyArgs} args - Arguments to filter UserSkins to delete.
     * @example
     * // Delete a few UserSkins
     * const { count } = await prisma.userSkin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSkinDeleteManyArgs>(args?: SelectSubset<T, UserSkinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSkins
     * const userSkin = await prisma.userSkin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSkinUpdateManyArgs>(args: SelectSubset<T, UserSkinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSkin.
     * @param {UserSkinUpsertArgs} args - Arguments to update or create a UserSkin.
     * @example
     * // Update or create a UserSkin
     * const userSkin = await prisma.userSkin.upsert({
     *   create: {
     *     // ... data to create a UserSkin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSkin we want to update
     *   }
     * })
     */
    upsert<T extends UserSkinUpsertArgs>(args: SelectSubset<T, UserSkinUpsertArgs<ExtArgs>>): Prisma__UserSkinClient<$Result.GetResult<Prisma.$UserSkinPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more UserSkins that matches the filter.
     * @param {UserSkinFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userSkin = await prisma.userSkin.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserSkinFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserSkin.
     * @param {UserSkinAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userSkin = await prisma.userSkin.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserSkinAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserSkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkinCountArgs} args - Arguments to filter UserSkins to count.
     * @example
     * // Count the number of UserSkins
     * const count = await prisma.userSkin.count({
     *   where: {
     *     // ... the filter for the UserSkins we want to count
     *   }
     * })
    **/
    count<T extends UserSkinCountArgs>(
      args?: Subset<T, UserSkinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSkinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSkin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSkinAggregateArgs>(args: Subset<T, UserSkinAggregateArgs>): Prisma.PrismaPromise<GetUserSkinAggregateType<T>>

    /**
     * Group by UserSkin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSkinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSkinGroupByArgs['orderBy'] }
        : { orderBy?: UserSkinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSkinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSkinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSkin model
   */
  readonly fields: UserSkinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSkin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSkinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skin<T extends SkinsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkinsDefaultArgs<ExtArgs>>): Prisma__SkinsClient<$Result.GetResult<Prisma.$SkinsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSkin model
   */ 
  interface UserSkinFieldRefs {
    readonly id: FieldRef<"UserSkin", 'String'>
    readonly userId: FieldRef<"UserSkin", 'String'>
    readonly skinId: FieldRef<"UserSkin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSkin findUnique
   */
  export type UserSkinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * Filter, which UserSkin to fetch.
     */
    where: UserSkinWhereUniqueInput
  }

  /**
   * UserSkin findUniqueOrThrow
   */
  export type UserSkinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * Filter, which UserSkin to fetch.
     */
    where: UserSkinWhereUniqueInput
  }

  /**
   * UserSkin findFirst
   */
  export type UserSkinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * Filter, which UserSkin to fetch.
     */
    where?: UserSkinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkins to fetch.
     */
    orderBy?: UserSkinOrderByWithRelationInput | UserSkinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkins.
     */
    cursor?: UserSkinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkins.
     */
    distinct?: UserSkinScalarFieldEnum | UserSkinScalarFieldEnum[]
  }

  /**
   * UserSkin findFirstOrThrow
   */
  export type UserSkinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * Filter, which UserSkin to fetch.
     */
    where?: UserSkinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkins to fetch.
     */
    orderBy?: UserSkinOrderByWithRelationInput | UserSkinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkins.
     */
    cursor?: UserSkinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkins.
     */
    distinct?: UserSkinScalarFieldEnum | UserSkinScalarFieldEnum[]
  }

  /**
   * UserSkin findMany
   */
  export type UserSkinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * Filter, which UserSkins to fetch.
     */
    where?: UserSkinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkins to fetch.
     */
    orderBy?: UserSkinOrderByWithRelationInput | UserSkinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSkins.
     */
    cursor?: UserSkinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkins.
     */
    skip?: number
    distinct?: UserSkinScalarFieldEnum | UserSkinScalarFieldEnum[]
  }

  /**
   * UserSkin create
   */
  export type UserSkinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSkin.
     */
    data: XOR<UserSkinCreateInput, UserSkinUncheckedCreateInput>
  }

  /**
   * UserSkin createMany
   */
  export type UserSkinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSkins.
     */
    data: UserSkinCreateManyInput | UserSkinCreateManyInput[]
  }

  /**
   * UserSkin update
   */
  export type UserSkinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSkin.
     */
    data: XOR<UserSkinUpdateInput, UserSkinUncheckedUpdateInput>
    /**
     * Choose, which UserSkin to update.
     */
    where: UserSkinWhereUniqueInput
  }

  /**
   * UserSkin updateMany
   */
  export type UserSkinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSkins.
     */
    data: XOR<UserSkinUpdateManyMutationInput, UserSkinUncheckedUpdateManyInput>
    /**
     * Filter which UserSkins to update
     */
    where?: UserSkinWhereInput
  }

  /**
   * UserSkin upsert
   */
  export type UserSkinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSkin to update in case it exists.
     */
    where: UserSkinWhereUniqueInput
    /**
     * In case the UserSkin found by the `where` argument doesn't exist, create a new UserSkin with this data.
     */
    create: XOR<UserSkinCreateInput, UserSkinUncheckedCreateInput>
    /**
     * In case the UserSkin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSkinUpdateInput, UserSkinUncheckedUpdateInput>
  }

  /**
   * UserSkin delete
   */
  export type UserSkinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
    /**
     * Filter which UserSkin to delete.
     */
    where: UserSkinWhereUniqueInput
  }

  /**
   * UserSkin deleteMany
   */
  export type UserSkinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkins to delete
     */
    where?: UserSkinWhereInput
  }

  /**
   * UserSkin findRaw
   */
  export type UserSkinFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserSkin aggregateRaw
   */
  export type UserSkinAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserSkin without action
   */
  export type UserSkinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkin
     */
    select?: UserSkinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkinInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    chatId: 'chatId',
    taps: 'taps',
    points: 'points',
    profit: 'profit',
    lastProfitDate: 'lastProfitDate',
    rechargeLimit: 'rechargeLimit',
    pointPerTap: 'pointPerTap',
    profitPerHour: 'profitPerHour',
    refillRate: 'refillRate',
    bonus: 'bonus',
    active: 'active',
    skin: 'skin',
    lastLogin: 'lastLogin',
    league: 'league',
    referralCount: 'referralCount',
    loginStreak: 'loginStreak',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referredById: 'referredById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AchievementCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AchievementCategoryScalarFieldEnum = (typeof AchievementCategoryScalarFieldEnum)[keyof typeof AchievementCategoryScalarFieldEnum]


  export const AchievementMilestoneScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    icon: 'icon',
    unlocked: 'unlocked'
  };

  export type AchievementMilestoneScalarFieldEnum = (typeof AchievementMilestoneScalarFieldEnum)[keyof typeof AchievementMilestoneScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    milestoneId: 'milestoneId'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const DailyRewardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    day: 'day',
    coins: 'coins',
    createdAt: 'createdAt'
  };

  export type DailyRewardScalarFieldEnum = (typeof DailyRewardScalarFieldEnum)[keyof typeof DailyRewardScalarFieldEnum]


  export const CardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image: 'image',
    baseCost: 'baseCost',
    basePPH: 'basePPH',
    baseLevel: 'baseLevel',
    category: 'category',
    discription: 'discription',
    requiredCardId: 'requiredCardId',
    requiredCardLevel: 'requiredCardLevel',
    requiredCardTitle: 'requiredCardTitle'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const UserCardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image: 'image',
    baseCost: 'baseCost',
    basePPH: 'basePPH',
    baseLevel: 'baseLevel',
    userId: 'userId',
    cardId: 'cardId',
    category: 'category',
    discription: 'discription'
  };

  export type UserCardScalarFieldEnum = (typeof UserCardScalarFieldEnum)[keyof typeof UserCardScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const AuthenticatorScalarFieldEnum: {
    credentialID: 'credentialID',
    userId: 'userId',
    providerAccountId: 'providerAccountId',
    credentialPublicKey: 'credentialPublicKey',
    counter: 'counter',
    credentialDeviceType: 'credentialDeviceType',
    credentialBackedUp: 'credentialBackedUp',
    transports: 'transports'
  };

  export type AuthenticatorScalarFieldEnum = (typeof AuthenticatorScalarFieldEnum)[keyof typeof AuthenticatorScalarFieldEnum]


  export const LeaguesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    minEntry: 'minEntry',
    pointLimit: 'pointLimit',
    trophy: 'trophy',
    entryReward: 'entryReward'
  };

  export type LeaguesScalarFieldEnum = (typeof LeaguesScalarFieldEnum)[keyof typeof LeaguesScalarFieldEnum]


  export const PointsScalarFieldEnum: {
    id: 'id',
    user: 'user',
    points: 'points',
    league: 'league',
    autominer: 'autominer',
    tapLimit: 'tapLimit',
    lastTap: 'lastTap'
  };

  export type PointsScalarFieldEnum = (typeof PointsScalarFieldEnum)[keyof typeof PointsScalarFieldEnum]


  export const BonusterScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    energy: 'energy',
    energyCost: 'energyCost',
    energylevel: 'energylevel',
    multiClickLevel: 'multiClickLevel',
    multiClickCost: 'multiClickCost'
  };

  export type BonusterScalarFieldEnum = (typeof BonusterScalarFieldEnum)[keyof typeof BonusterScalarFieldEnum]


  export const DailyBoostersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    count: 'count',
    icon: 'icon'
  };

  export type DailyBoostersScalarFieldEnum = (typeof DailyBoostersScalarFieldEnum)[keyof typeof DailyBoostersScalarFieldEnum]


  export const TaskCategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TaskCategoriesScalarFieldEnum = (typeof TaskCategoriesScalarFieldEnum)[keyof typeof TaskCategoriesScalarFieldEnum]


  export const TasksScalarFieldEnum: {
    id: 'id',
    category: 'category',
    name: 'name',
    points: 'points',
    link: 'link',
    icon: 'icon'
  };

  export type TasksScalarFieldEnum = (typeof TasksScalarFieldEnum)[keyof typeof TasksScalarFieldEnum]


  export const TasksCompletionScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    points: 'points'
  };

  export type TasksCompletionScalarFieldEnum = (typeof TasksCompletionScalarFieldEnum)[keyof typeof TasksCompletionScalarFieldEnum]


  export const YouTubeScalarFieldEnum: {
    id: 'id',
    category: 'category',
    name: 'name',
    points: 'points',
    link: 'link',
    icon: 'icon'
  };

  export type YouTubeScalarFieldEnum = (typeof YouTubeScalarFieldEnum)[keyof typeof YouTubeScalarFieldEnum]


  export const YouTubeCompletionScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    points: 'points'
  };

  export type YouTubeCompletionScalarFieldEnum = (typeof YouTubeCompletionScalarFieldEnum)[keyof typeof YouTubeCompletionScalarFieldEnum]


  export const SkinsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    cost: 'cost',
    featured: 'featured',
    league: 'league'
  };

  export type SkinsScalarFieldEnum = (typeof SkinsScalarFieldEnum)[keyof typeof SkinsScalarFieldEnum]


  export const UserSkinScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    skinId: 'skinId'
  };

  export type UserSkinScalarFieldEnum = (typeof UserSkinScalarFieldEnum)[keyof typeof UserSkinScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    chatId?: StringFilter<"User"> | string
    taps?: IntFilter<"User"> | number
    points?: IntFilter<"User"> | number
    profit?: IntFilter<"User"> | number
    lastProfitDate?: IntNullableFilter<"User"> | number | null
    rechargeLimit?: IntFilter<"User"> | number
    pointPerTap?: IntFilter<"User"> | number
    profitPerHour?: IntFilter<"User"> | number
    refillRate?: IntFilter<"User"> | number
    bonus?: IntFilter<"User"> | number
    active?: BoolFilter<"User"> | boolean
    skin?: StringFilter<"User"> | string
    lastLogin?: DateTimeFilter<"User"> | Date | string
    league?: StringNullableFilter<"User"> | string | null
    referralCount?: IntFilter<"User"> | number
    loginStreak?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: StringNullableFilter<"User"> | string | null
    skins?: UserSkinListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    authenticators?: AuthenticatorListRelationFilter
    userCard?: UserCardListRelationFilter
    Bonuster?: BonusterListRelationFilter
    dailyRewards?: DailyRewardListRelationFilter
    referredBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    achievements?: UserAchievementListRelationFilter
    userTasks?: TasksCompletionListRelationFilter
    userYouTube?: YouTubeCompletionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    chatId?: SortOrder
    taps?: SortOrder
    points?: SortOrder
    profit?: SortOrder
    lastProfitDate?: SortOrder
    rechargeLimit?: SortOrder
    pointPerTap?: SortOrder
    profitPerHour?: SortOrder
    refillRate?: SortOrder
    bonus?: SortOrder
    active?: SortOrder
    skin?: SortOrder
    lastLogin?: SortOrder
    league?: SortOrder
    referralCount?: SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrder
    skins?: UserSkinOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    authenticators?: AuthenticatorOrderByRelationAggregateInput
    userCard?: UserCardOrderByRelationAggregateInput
    Bonuster?: BonusterOrderByRelationAggregateInput
    dailyRewards?: DailyRewardOrderByRelationAggregateInput
    referredBy?: UserOrderByWithRelationInput
    referrals?: UserOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    userTasks?: TasksCompletionOrderByRelationAggregateInput
    userYouTube?: YouTubeCompletionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chatId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    taps?: IntFilter<"User"> | number
    points?: IntFilter<"User"> | number
    profit?: IntFilter<"User"> | number
    lastProfitDate?: IntNullableFilter<"User"> | number | null
    rechargeLimit?: IntFilter<"User"> | number
    pointPerTap?: IntFilter<"User"> | number
    profitPerHour?: IntFilter<"User"> | number
    refillRate?: IntFilter<"User"> | number
    bonus?: IntFilter<"User"> | number
    active?: BoolFilter<"User"> | boolean
    skin?: StringFilter<"User"> | string
    lastLogin?: DateTimeFilter<"User"> | Date | string
    league?: StringNullableFilter<"User"> | string | null
    referralCount?: IntFilter<"User"> | number
    loginStreak?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: StringNullableFilter<"User"> | string | null
    skins?: UserSkinListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    authenticators?: AuthenticatorListRelationFilter
    userCard?: UserCardListRelationFilter
    Bonuster?: BonusterListRelationFilter
    dailyRewards?: DailyRewardListRelationFilter
    referredBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    achievements?: UserAchievementListRelationFilter
    userTasks?: TasksCompletionListRelationFilter
    userYouTube?: YouTubeCompletionListRelationFilter
  }, "id" | "chatId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    chatId?: SortOrder
    taps?: SortOrder
    points?: SortOrder
    profit?: SortOrder
    lastProfitDate?: SortOrder
    rechargeLimit?: SortOrder
    pointPerTap?: SortOrder
    profitPerHour?: SortOrder
    refillRate?: SortOrder
    bonus?: SortOrder
    active?: SortOrder
    skin?: SortOrder
    lastLogin?: SortOrder
    league?: SortOrder
    referralCount?: SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    chatId?: StringWithAggregatesFilter<"User"> | string
    taps?: IntWithAggregatesFilter<"User"> | number
    points?: IntWithAggregatesFilter<"User"> | number
    profit?: IntWithAggregatesFilter<"User"> | number
    lastProfitDate?: IntNullableWithAggregatesFilter<"User"> | number | null
    rechargeLimit?: IntWithAggregatesFilter<"User"> | number
    pointPerTap?: IntWithAggregatesFilter<"User"> | number
    profitPerHour?: IntWithAggregatesFilter<"User"> | number
    refillRate?: IntWithAggregatesFilter<"User"> | number
    bonus?: IntWithAggregatesFilter<"User"> | number
    active?: BoolWithAggregatesFilter<"User"> | boolean
    skin?: StringWithAggregatesFilter<"User"> | string
    lastLogin?: DateTimeWithAggregatesFilter<"User"> | Date | string
    league?: StringNullableWithAggregatesFilter<"User"> | string | null
    referralCount?: IntWithAggregatesFilter<"User"> | number
    loginStreak?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    referredById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AchievementCategoryWhereInput = {
    AND?: AchievementCategoryWhereInput | AchievementCategoryWhereInput[]
    OR?: AchievementCategoryWhereInput[]
    NOT?: AchievementCategoryWhereInput | AchievementCategoryWhereInput[]
    id?: StringFilter<"AchievementCategory"> | string
    name?: StringFilter<"AchievementCategory"> | string
    milestones?: AchievementMilestoneListRelationFilter
  }

  export type AchievementCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    milestones?: AchievementMilestoneOrderByRelationAggregateInput
  }

  export type AchievementCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementCategoryWhereInput | AchievementCategoryWhereInput[]
    OR?: AchievementCategoryWhereInput[]
    NOT?: AchievementCategoryWhereInput | AchievementCategoryWhereInput[]
    name?: StringFilter<"AchievementCategory"> | string
    milestones?: AchievementMilestoneListRelationFilter
  }, "id">

  export type AchievementCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: AchievementCategoryCountOrderByAggregateInput
    _max?: AchievementCategoryMaxOrderByAggregateInput
    _min?: AchievementCategoryMinOrderByAggregateInput
  }

  export type AchievementCategoryScalarWhereWithAggregatesInput = {
    AND?: AchievementCategoryScalarWhereWithAggregatesInput | AchievementCategoryScalarWhereWithAggregatesInput[]
    OR?: AchievementCategoryScalarWhereWithAggregatesInput[]
    NOT?: AchievementCategoryScalarWhereWithAggregatesInput | AchievementCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AchievementCategory"> | string
    name?: StringWithAggregatesFilter<"AchievementCategory"> | string
  }

  export type AchievementMilestoneWhereInput = {
    AND?: AchievementMilestoneWhereInput | AchievementMilestoneWhereInput[]
    OR?: AchievementMilestoneWhereInput[]
    NOT?: AchievementMilestoneWhereInput | AchievementMilestoneWhereInput[]
    id?: StringFilter<"AchievementMilestone"> | string
    categoryId?: StringFilter<"AchievementMilestone"> | string
    name?: StringFilter<"AchievementMilestone"> | string
    icon?: StringFilter<"AchievementMilestone"> | string
    unlocked?: BoolFilter<"AchievementMilestone"> | boolean
    category?: XOR<AchievementCategoryRelationFilter, AchievementCategoryWhereInput>
    userAchievements?: UserAchievementListRelationFilter
  }

  export type AchievementMilestoneOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    unlocked?: SortOrder
    category?: AchievementCategoryOrderByWithRelationInput
    userAchievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementMilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementMilestoneWhereInput | AchievementMilestoneWhereInput[]
    OR?: AchievementMilestoneWhereInput[]
    NOT?: AchievementMilestoneWhereInput | AchievementMilestoneWhereInput[]
    categoryId?: StringFilter<"AchievementMilestone"> | string
    name?: StringFilter<"AchievementMilestone"> | string
    icon?: StringFilter<"AchievementMilestone"> | string
    unlocked?: BoolFilter<"AchievementMilestone"> | boolean
    category?: XOR<AchievementCategoryRelationFilter, AchievementCategoryWhereInput>
    userAchievements?: UserAchievementListRelationFilter
  }, "id">

  export type AchievementMilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    unlocked?: SortOrder
    _count?: AchievementMilestoneCountOrderByAggregateInput
    _max?: AchievementMilestoneMaxOrderByAggregateInput
    _min?: AchievementMilestoneMinOrderByAggregateInput
  }

  export type AchievementMilestoneScalarWhereWithAggregatesInput = {
    AND?: AchievementMilestoneScalarWhereWithAggregatesInput | AchievementMilestoneScalarWhereWithAggregatesInput[]
    OR?: AchievementMilestoneScalarWhereWithAggregatesInput[]
    NOT?: AchievementMilestoneScalarWhereWithAggregatesInput | AchievementMilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AchievementMilestone"> | string
    categoryId?: StringWithAggregatesFilter<"AchievementMilestone"> | string
    name?: StringWithAggregatesFilter<"AchievementMilestone"> | string
    icon?: StringWithAggregatesFilter<"AchievementMilestone"> | string
    unlocked?: BoolWithAggregatesFilter<"AchievementMilestone"> | boolean
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    milestoneId?: StringFilter<"UserAchievement"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    milestone?: XOR<AchievementMilestoneRelationFilter, AchievementMilestoneWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    milestoneId?: SortOrder
    user?: UserOrderByWithRelationInput
    milestone?: AchievementMilestoneOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    milestoneId?: StringFilter<"UserAchievement"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    milestone?: XOR<AchievementMilestoneRelationFilter, AchievementMilestoneWhereInput>
  }, "id">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    milestoneId?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    milestoneId?: StringWithAggregatesFilter<"UserAchievement"> | string
  }

  export type DailyRewardWhereInput = {
    AND?: DailyRewardWhereInput | DailyRewardWhereInput[]
    OR?: DailyRewardWhereInput[]
    NOT?: DailyRewardWhereInput | DailyRewardWhereInput[]
    id?: StringFilter<"DailyReward"> | string
    userId?: StringFilter<"DailyReward"> | string
    day?: IntFilter<"DailyReward"> | number
    coins?: IntFilter<"DailyReward"> | number
    createdAt?: DateTimeFilter<"DailyReward"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DailyRewardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    coins?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyRewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyRewardWhereInput | DailyRewardWhereInput[]
    OR?: DailyRewardWhereInput[]
    NOT?: DailyRewardWhereInput | DailyRewardWhereInput[]
    userId?: StringFilter<"DailyReward"> | string
    day?: IntFilter<"DailyReward"> | number
    coins?: IntFilter<"DailyReward"> | number
    createdAt?: DateTimeFilter<"DailyReward"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DailyRewardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    coins?: SortOrder
    createdAt?: SortOrder
    _count?: DailyRewardCountOrderByAggregateInput
    _avg?: DailyRewardAvgOrderByAggregateInput
    _max?: DailyRewardMaxOrderByAggregateInput
    _min?: DailyRewardMinOrderByAggregateInput
    _sum?: DailyRewardSumOrderByAggregateInput
  }

  export type DailyRewardScalarWhereWithAggregatesInput = {
    AND?: DailyRewardScalarWhereWithAggregatesInput | DailyRewardScalarWhereWithAggregatesInput[]
    OR?: DailyRewardScalarWhereWithAggregatesInput[]
    NOT?: DailyRewardScalarWhereWithAggregatesInput | DailyRewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyReward"> | string
    userId?: StringWithAggregatesFilter<"DailyReward"> | string
    day?: IntWithAggregatesFilter<"DailyReward"> | number
    coins?: IntWithAggregatesFilter<"DailyReward"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DailyReward"> | Date | string
  }

  export type CardWhereInput = {
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    id?: StringFilter<"Card"> | string
    title?: StringFilter<"Card"> | string
    image?: StringFilter<"Card"> | string
    baseCost?: FloatFilter<"Card"> | number
    basePPH?: FloatFilter<"Card"> | number
    baseLevel?: IntFilter<"Card"> | number
    category?: StringFilter<"Card"> | string
    discription?: StringNullableFilter<"Card"> | string | null
    requiredCardId?: StringNullableFilter<"Card"> | string | null
    requiredCardLevel?: IntNullableFilter<"Card"> | number | null
    requiredCardTitle?: StringNullableFilter<"Card"> | string | null
    users?: UserCardListRelationFilter
  }

  export type CardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    category?: SortOrder
    discription?: SortOrder
    requiredCardId?: SortOrder
    requiredCardLevel?: SortOrder
    requiredCardTitle?: SortOrder
    users?: UserCardOrderByRelationAggregateInput
  }

  export type CardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    title?: StringFilter<"Card"> | string
    image?: StringFilter<"Card"> | string
    baseCost?: FloatFilter<"Card"> | number
    basePPH?: FloatFilter<"Card"> | number
    baseLevel?: IntFilter<"Card"> | number
    category?: StringFilter<"Card"> | string
    discription?: StringNullableFilter<"Card"> | string | null
    requiredCardId?: StringNullableFilter<"Card"> | string | null
    requiredCardLevel?: IntNullableFilter<"Card"> | number | null
    requiredCardTitle?: StringNullableFilter<"Card"> | string | null
    users?: UserCardListRelationFilter
  }, "id">

  export type CardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    category?: SortOrder
    discription?: SortOrder
    requiredCardId?: SortOrder
    requiredCardLevel?: SortOrder
    requiredCardTitle?: SortOrder
    _count?: CardCountOrderByAggregateInput
    _avg?: CardAvgOrderByAggregateInput
    _max?: CardMaxOrderByAggregateInput
    _min?: CardMinOrderByAggregateInput
    _sum?: CardSumOrderByAggregateInput
  }

  export type CardScalarWhereWithAggregatesInput = {
    AND?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    OR?: CardScalarWhereWithAggregatesInput[]
    NOT?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Card"> | string
    title?: StringWithAggregatesFilter<"Card"> | string
    image?: StringWithAggregatesFilter<"Card"> | string
    baseCost?: FloatWithAggregatesFilter<"Card"> | number
    basePPH?: FloatWithAggregatesFilter<"Card"> | number
    baseLevel?: IntWithAggregatesFilter<"Card"> | number
    category?: StringWithAggregatesFilter<"Card"> | string
    discription?: StringNullableWithAggregatesFilter<"Card"> | string | null
    requiredCardId?: StringNullableWithAggregatesFilter<"Card"> | string | null
    requiredCardLevel?: IntNullableWithAggregatesFilter<"Card"> | number | null
    requiredCardTitle?: StringNullableWithAggregatesFilter<"Card"> | string | null
  }

  export type UserCardWhereInput = {
    AND?: UserCardWhereInput | UserCardWhereInput[]
    OR?: UserCardWhereInput[]
    NOT?: UserCardWhereInput | UserCardWhereInput[]
    id?: StringFilter<"UserCard"> | string
    title?: StringFilter<"UserCard"> | string
    image?: StringFilter<"UserCard"> | string
    baseCost?: FloatFilter<"UserCard"> | number
    basePPH?: FloatFilter<"UserCard"> | number
    baseLevel?: IntFilter<"UserCard"> | number
    userId?: StringFilter<"UserCard"> | string
    cardId?: StringFilter<"UserCard"> | string
    category?: StringFilter<"UserCard"> | string
    discription?: StringNullableFilter<"UserCard"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    card?: XOR<CardRelationFilter, CardWhereInput>
  }

  export type UserCardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    category?: SortOrder
    discription?: SortOrder
    user?: UserOrderByWithRelationInput
    card?: CardOrderByWithRelationInput
  }

  export type UserCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserCardWhereInput | UserCardWhereInput[]
    OR?: UserCardWhereInput[]
    NOT?: UserCardWhereInput | UserCardWhereInput[]
    title?: StringFilter<"UserCard"> | string
    image?: StringFilter<"UserCard"> | string
    baseCost?: FloatFilter<"UserCard"> | number
    basePPH?: FloatFilter<"UserCard"> | number
    baseLevel?: IntFilter<"UserCard"> | number
    userId?: StringFilter<"UserCard"> | string
    cardId?: StringFilter<"UserCard"> | string
    category?: StringFilter<"UserCard"> | string
    discription?: StringNullableFilter<"UserCard"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    card?: XOR<CardRelationFilter, CardWhereInput>
  }, "id">

  export type UserCardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    category?: SortOrder
    discription?: SortOrder
    _count?: UserCardCountOrderByAggregateInput
    _avg?: UserCardAvgOrderByAggregateInput
    _max?: UserCardMaxOrderByAggregateInput
    _min?: UserCardMinOrderByAggregateInput
    _sum?: UserCardSumOrderByAggregateInput
  }

  export type UserCardScalarWhereWithAggregatesInput = {
    AND?: UserCardScalarWhereWithAggregatesInput | UserCardScalarWhereWithAggregatesInput[]
    OR?: UserCardScalarWhereWithAggregatesInput[]
    NOT?: UserCardScalarWhereWithAggregatesInput | UserCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserCard"> | string
    title?: StringWithAggregatesFilter<"UserCard"> | string
    image?: StringWithAggregatesFilter<"UserCard"> | string
    baseCost?: FloatWithAggregatesFilter<"UserCard"> | number
    basePPH?: FloatWithAggregatesFilter<"UserCard"> | number
    baseLevel?: IntWithAggregatesFilter<"UserCard"> | number
    userId?: StringWithAggregatesFilter<"UserCard"> | string
    cardId?: StringWithAggregatesFilter<"UserCard"> | string
    category?: StringWithAggregatesFilter<"UserCard"> | string
    discription?: StringNullableWithAggregatesFilter<"UserCard"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    identifier?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "identifier" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type AuthenticatorWhereInput = {
    AND?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    OR?: AuthenticatorWhereInput[]
    NOT?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    credentialID?: StringFilter<"Authenticator"> | string
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuthenticatorOrderByWithRelationInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthenticatorWhereUniqueInput = Prisma.AtLeast<{
    credentialID?: string
    userId_credentialID?: AuthenticatorUserIdCredentialIDCompoundUniqueInput
    AND?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    OR?: AuthenticatorWhereInput[]
    NOT?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "credentialID" | "userId_credentialID">

  export type AuthenticatorOrderByWithAggregationInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
    _count?: AuthenticatorCountOrderByAggregateInput
    _avg?: AuthenticatorAvgOrderByAggregateInput
    _max?: AuthenticatorMaxOrderByAggregateInput
    _min?: AuthenticatorMinOrderByAggregateInput
    _sum?: AuthenticatorSumOrderByAggregateInput
  }

  export type AuthenticatorScalarWhereWithAggregatesInput = {
    AND?: AuthenticatorScalarWhereWithAggregatesInput | AuthenticatorScalarWhereWithAggregatesInput[]
    OR?: AuthenticatorScalarWhereWithAggregatesInput[]
    NOT?: AuthenticatorScalarWhereWithAggregatesInput | AuthenticatorScalarWhereWithAggregatesInput[]
    credentialID?: StringWithAggregatesFilter<"Authenticator"> | string
    userId?: StringWithAggregatesFilter<"Authenticator"> | string
    providerAccountId?: StringWithAggregatesFilter<"Authenticator"> | string
    credentialPublicKey?: StringWithAggregatesFilter<"Authenticator"> | string
    counter?: IntWithAggregatesFilter<"Authenticator"> | number
    credentialDeviceType?: StringWithAggregatesFilter<"Authenticator"> | string
    credentialBackedUp?: BoolWithAggregatesFilter<"Authenticator"> | boolean
    transports?: StringNullableWithAggregatesFilter<"Authenticator"> | string | null
  }

  export type LeaguesWhereInput = {
    AND?: LeaguesWhereInput | LeaguesWhereInput[]
    OR?: LeaguesWhereInput[]
    NOT?: LeaguesWhereInput | LeaguesWhereInput[]
    id?: StringFilter<"Leagues"> | string
    name?: StringFilter<"Leagues"> | string
    minEntry?: IntFilter<"Leagues"> | number
    pointLimit?: IntFilter<"Leagues"> | number
    trophy?: StringFilter<"Leagues"> | string
    entryReward?: StringFilter<"Leagues"> | string
  }

  export type LeaguesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    minEntry?: SortOrder
    pointLimit?: SortOrder
    trophy?: SortOrder
    entryReward?: SortOrder
  }

  export type LeaguesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaguesWhereInput | LeaguesWhereInput[]
    OR?: LeaguesWhereInput[]
    NOT?: LeaguesWhereInput | LeaguesWhereInput[]
    name?: StringFilter<"Leagues"> | string
    minEntry?: IntFilter<"Leagues"> | number
    pointLimit?: IntFilter<"Leagues"> | number
    trophy?: StringFilter<"Leagues"> | string
    entryReward?: StringFilter<"Leagues"> | string
  }, "id">

  export type LeaguesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    minEntry?: SortOrder
    pointLimit?: SortOrder
    trophy?: SortOrder
    entryReward?: SortOrder
    _count?: LeaguesCountOrderByAggregateInput
    _avg?: LeaguesAvgOrderByAggregateInput
    _max?: LeaguesMaxOrderByAggregateInput
    _min?: LeaguesMinOrderByAggregateInput
    _sum?: LeaguesSumOrderByAggregateInput
  }

  export type LeaguesScalarWhereWithAggregatesInput = {
    AND?: LeaguesScalarWhereWithAggregatesInput | LeaguesScalarWhereWithAggregatesInput[]
    OR?: LeaguesScalarWhereWithAggregatesInput[]
    NOT?: LeaguesScalarWhereWithAggregatesInput | LeaguesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Leagues"> | string
    name?: StringWithAggregatesFilter<"Leagues"> | string
    minEntry?: IntWithAggregatesFilter<"Leagues"> | number
    pointLimit?: IntWithAggregatesFilter<"Leagues"> | number
    trophy?: StringWithAggregatesFilter<"Leagues"> | string
    entryReward?: StringWithAggregatesFilter<"Leagues"> | string
  }

  export type PointsWhereInput = {
    AND?: PointsWhereInput | PointsWhereInput[]
    OR?: PointsWhereInput[]
    NOT?: PointsWhereInput | PointsWhereInput[]
    id?: StringFilter<"Points"> | string
    user?: StringFilter<"Points"> | string
    points?: IntFilter<"Points"> | number
    league?: StringFilter<"Points"> | string
    autominer?: BoolFilter<"Points"> | boolean
    tapLimit?: IntFilter<"Points"> | number
    lastTap?: DateTimeFilter<"Points"> | Date | string
  }

  export type PointsOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    points?: SortOrder
    league?: SortOrder
    autominer?: SortOrder
    tapLimit?: SortOrder
    lastTap?: SortOrder
  }

  export type PointsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user?: string
    AND?: PointsWhereInput | PointsWhereInput[]
    OR?: PointsWhereInput[]
    NOT?: PointsWhereInput | PointsWhereInput[]
    points?: IntFilter<"Points"> | number
    league?: StringFilter<"Points"> | string
    autominer?: BoolFilter<"Points"> | boolean
    tapLimit?: IntFilter<"Points"> | number
    lastTap?: DateTimeFilter<"Points"> | Date | string
  }, "id" | "user">

  export type PointsOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    points?: SortOrder
    league?: SortOrder
    autominer?: SortOrder
    tapLimit?: SortOrder
    lastTap?: SortOrder
    _count?: PointsCountOrderByAggregateInput
    _avg?: PointsAvgOrderByAggregateInput
    _max?: PointsMaxOrderByAggregateInput
    _min?: PointsMinOrderByAggregateInput
    _sum?: PointsSumOrderByAggregateInput
  }

  export type PointsScalarWhereWithAggregatesInput = {
    AND?: PointsScalarWhereWithAggregatesInput | PointsScalarWhereWithAggregatesInput[]
    OR?: PointsScalarWhereWithAggregatesInput[]
    NOT?: PointsScalarWhereWithAggregatesInput | PointsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Points"> | string
    user?: StringWithAggregatesFilter<"Points"> | string
    points?: IntWithAggregatesFilter<"Points"> | number
    league?: StringWithAggregatesFilter<"Points"> | string
    autominer?: BoolWithAggregatesFilter<"Points"> | boolean
    tapLimit?: IntWithAggregatesFilter<"Points"> | number
    lastTap?: DateTimeWithAggregatesFilter<"Points"> | Date | string
  }

  export type BonusterWhereInput = {
    AND?: BonusterWhereInput | BonusterWhereInput[]
    OR?: BonusterWhereInput[]
    NOT?: BonusterWhereInput | BonusterWhereInput[]
    id?: StringFilter<"Bonuster"> | string
    chatId?: StringFilter<"Bonuster"> | string
    energy?: IntFilter<"Bonuster"> | number
    energyCost?: IntFilter<"Bonuster"> | number
    energylevel?: IntFilter<"Bonuster"> | number
    multiClickLevel?: IntFilter<"Bonuster"> | number
    multiClickCost?: IntFilter<"Bonuster"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BonusterOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    energy?: SortOrder
    energyCost?: SortOrder
    energylevel?: SortOrder
    multiClickLevel?: SortOrder
    multiClickCost?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BonusterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chatId?: string
    AND?: BonusterWhereInput | BonusterWhereInput[]
    OR?: BonusterWhereInput[]
    NOT?: BonusterWhereInput | BonusterWhereInput[]
    energy?: IntFilter<"Bonuster"> | number
    energyCost?: IntFilter<"Bonuster"> | number
    energylevel?: IntFilter<"Bonuster"> | number
    multiClickLevel?: IntFilter<"Bonuster"> | number
    multiClickCost?: IntFilter<"Bonuster"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "chatId">

  export type BonusterOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    energy?: SortOrder
    energyCost?: SortOrder
    energylevel?: SortOrder
    multiClickLevel?: SortOrder
    multiClickCost?: SortOrder
    _count?: BonusterCountOrderByAggregateInput
    _avg?: BonusterAvgOrderByAggregateInput
    _max?: BonusterMaxOrderByAggregateInput
    _min?: BonusterMinOrderByAggregateInput
    _sum?: BonusterSumOrderByAggregateInput
  }

  export type BonusterScalarWhereWithAggregatesInput = {
    AND?: BonusterScalarWhereWithAggregatesInput | BonusterScalarWhereWithAggregatesInput[]
    OR?: BonusterScalarWhereWithAggregatesInput[]
    NOT?: BonusterScalarWhereWithAggregatesInput | BonusterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bonuster"> | string
    chatId?: StringWithAggregatesFilter<"Bonuster"> | string
    energy?: IntWithAggregatesFilter<"Bonuster"> | number
    energyCost?: IntWithAggregatesFilter<"Bonuster"> | number
    energylevel?: IntWithAggregatesFilter<"Bonuster"> | number
    multiClickLevel?: IntWithAggregatesFilter<"Bonuster"> | number
    multiClickCost?: IntWithAggregatesFilter<"Bonuster"> | number
  }

  export type DailyBoostersWhereInput = {
    AND?: DailyBoostersWhereInput | DailyBoostersWhereInput[]
    OR?: DailyBoostersWhereInput[]
    NOT?: DailyBoostersWhereInput | DailyBoostersWhereInput[]
    id?: StringFilter<"DailyBoosters"> | string
    name?: StringFilter<"DailyBoosters"> | string
    count?: IntFilter<"DailyBoosters"> | number
    icon?: StringFilter<"DailyBoosters"> | string
  }

  export type DailyBoostersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    count?: SortOrder
    icon?: SortOrder
  }

  export type DailyBoostersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyBoostersWhereInput | DailyBoostersWhereInput[]
    OR?: DailyBoostersWhereInput[]
    NOT?: DailyBoostersWhereInput | DailyBoostersWhereInput[]
    name?: StringFilter<"DailyBoosters"> | string
    count?: IntFilter<"DailyBoosters"> | number
    icon?: StringFilter<"DailyBoosters"> | string
  }, "id">

  export type DailyBoostersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    count?: SortOrder
    icon?: SortOrder
    _count?: DailyBoostersCountOrderByAggregateInput
    _avg?: DailyBoostersAvgOrderByAggregateInput
    _max?: DailyBoostersMaxOrderByAggregateInput
    _min?: DailyBoostersMinOrderByAggregateInput
    _sum?: DailyBoostersSumOrderByAggregateInput
  }

  export type DailyBoostersScalarWhereWithAggregatesInput = {
    AND?: DailyBoostersScalarWhereWithAggregatesInput | DailyBoostersScalarWhereWithAggregatesInput[]
    OR?: DailyBoostersScalarWhereWithAggregatesInput[]
    NOT?: DailyBoostersScalarWhereWithAggregatesInput | DailyBoostersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyBoosters"> | string
    name?: StringWithAggregatesFilter<"DailyBoosters"> | string
    count?: IntWithAggregatesFilter<"DailyBoosters"> | number
    icon?: StringWithAggregatesFilter<"DailyBoosters"> | string
  }

  export type TaskCategoriesWhereInput = {
    AND?: TaskCategoriesWhereInput | TaskCategoriesWhereInput[]
    OR?: TaskCategoriesWhereInput[]
    NOT?: TaskCategoriesWhereInput | TaskCategoriesWhereInput[]
    id?: StringFilter<"TaskCategories"> | string
    name?: StringFilter<"TaskCategories"> | string
  }

  export type TaskCategoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TaskCategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskCategoriesWhereInput | TaskCategoriesWhereInput[]
    OR?: TaskCategoriesWhereInput[]
    NOT?: TaskCategoriesWhereInput | TaskCategoriesWhereInput[]
    name?: StringFilter<"TaskCategories"> | string
  }, "id">

  export type TaskCategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TaskCategoriesCountOrderByAggregateInput
    _max?: TaskCategoriesMaxOrderByAggregateInput
    _min?: TaskCategoriesMinOrderByAggregateInput
  }

  export type TaskCategoriesScalarWhereWithAggregatesInput = {
    AND?: TaskCategoriesScalarWhereWithAggregatesInput | TaskCategoriesScalarWhereWithAggregatesInput[]
    OR?: TaskCategoriesScalarWhereWithAggregatesInput[]
    NOT?: TaskCategoriesScalarWhereWithAggregatesInput | TaskCategoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskCategories"> | string
    name?: StringWithAggregatesFilter<"TaskCategories"> | string
  }

  export type TasksWhereInput = {
    AND?: TasksWhereInput | TasksWhereInput[]
    OR?: TasksWhereInput[]
    NOT?: TasksWhereInput | TasksWhereInput[]
    id?: StringFilter<"Tasks"> | string
    category?: StringFilter<"Tasks"> | string
    name?: StringFilter<"Tasks"> | string
    points?: IntFilter<"Tasks"> | number
    link?: StringFilter<"Tasks"> | string
    icon?: StringFilter<"Tasks"> | string
    user?: TasksCompletionListRelationFilter
  }

  export type TasksOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    user?: TasksCompletionOrderByRelationAggregateInput
  }

  export type TasksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TasksWhereInput | TasksWhereInput[]
    OR?: TasksWhereInput[]
    NOT?: TasksWhereInput | TasksWhereInput[]
    category?: StringFilter<"Tasks"> | string
    name?: StringFilter<"Tasks"> | string
    points?: IntFilter<"Tasks"> | number
    link?: StringFilter<"Tasks"> | string
    icon?: StringFilter<"Tasks"> | string
    user?: TasksCompletionListRelationFilter
  }, "id">

  export type TasksOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    _count?: TasksCountOrderByAggregateInput
    _avg?: TasksAvgOrderByAggregateInput
    _max?: TasksMaxOrderByAggregateInput
    _min?: TasksMinOrderByAggregateInput
    _sum?: TasksSumOrderByAggregateInput
  }

  export type TasksScalarWhereWithAggregatesInput = {
    AND?: TasksScalarWhereWithAggregatesInput | TasksScalarWhereWithAggregatesInput[]
    OR?: TasksScalarWhereWithAggregatesInput[]
    NOT?: TasksScalarWhereWithAggregatesInput | TasksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tasks"> | string
    category?: StringWithAggregatesFilter<"Tasks"> | string
    name?: StringWithAggregatesFilter<"Tasks"> | string
    points?: IntWithAggregatesFilter<"Tasks"> | number
    link?: StringWithAggregatesFilter<"Tasks"> | string
    icon?: StringWithAggregatesFilter<"Tasks"> | string
  }

  export type TasksCompletionWhereInput = {
    AND?: TasksCompletionWhereInput | TasksCompletionWhereInput[]
    OR?: TasksCompletionWhereInput[]
    NOT?: TasksCompletionWhereInput | TasksCompletionWhereInput[]
    id?: StringFilter<"TasksCompletion"> | string
    taskId?: StringFilter<"TasksCompletion"> | string
    userId?: StringFilter<"TasksCompletion"> | string
    points?: IntFilter<"TasksCompletion"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    task?: XOR<TasksRelationFilter, TasksWhereInput>
  }

  export type TasksCompletionOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    user?: UserOrderByWithRelationInput
    task?: TasksOrderByWithRelationInput
  }

  export type TasksCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TasksCompletionWhereInput | TasksCompletionWhereInput[]
    OR?: TasksCompletionWhereInput[]
    NOT?: TasksCompletionWhereInput | TasksCompletionWhereInput[]
    taskId?: StringFilter<"TasksCompletion"> | string
    userId?: StringFilter<"TasksCompletion"> | string
    points?: IntFilter<"TasksCompletion"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    task?: XOR<TasksRelationFilter, TasksWhereInput>
  }, "id">

  export type TasksCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    _count?: TasksCompletionCountOrderByAggregateInput
    _avg?: TasksCompletionAvgOrderByAggregateInput
    _max?: TasksCompletionMaxOrderByAggregateInput
    _min?: TasksCompletionMinOrderByAggregateInput
    _sum?: TasksCompletionSumOrderByAggregateInput
  }

  export type TasksCompletionScalarWhereWithAggregatesInput = {
    AND?: TasksCompletionScalarWhereWithAggregatesInput | TasksCompletionScalarWhereWithAggregatesInput[]
    OR?: TasksCompletionScalarWhereWithAggregatesInput[]
    NOT?: TasksCompletionScalarWhereWithAggregatesInput | TasksCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TasksCompletion"> | string
    taskId?: StringWithAggregatesFilter<"TasksCompletion"> | string
    userId?: StringWithAggregatesFilter<"TasksCompletion"> | string
    points?: IntWithAggregatesFilter<"TasksCompletion"> | number
  }

  export type YouTubeWhereInput = {
    AND?: YouTubeWhereInput | YouTubeWhereInput[]
    OR?: YouTubeWhereInput[]
    NOT?: YouTubeWhereInput | YouTubeWhereInput[]
    id?: StringFilter<"YouTube"> | string
    category?: StringFilter<"YouTube"> | string
    name?: StringFilter<"YouTube"> | string
    points?: IntFilter<"YouTube"> | number
    link?: StringFilter<"YouTube"> | string
    icon?: StringFilter<"YouTube"> | string
    user?: YouTubeCompletionListRelationFilter
  }

  export type YouTubeOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    user?: YouTubeCompletionOrderByRelationAggregateInput
  }

  export type YouTubeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: YouTubeWhereInput | YouTubeWhereInput[]
    OR?: YouTubeWhereInput[]
    NOT?: YouTubeWhereInput | YouTubeWhereInput[]
    category?: StringFilter<"YouTube"> | string
    name?: StringFilter<"YouTube"> | string
    points?: IntFilter<"YouTube"> | number
    link?: StringFilter<"YouTube"> | string
    icon?: StringFilter<"YouTube"> | string
    user?: YouTubeCompletionListRelationFilter
  }, "id">

  export type YouTubeOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    _count?: YouTubeCountOrderByAggregateInput
    _avg?: YouTubeAvgOrderByAggregateInput
    _max?: YouTubeMaxOrderByAggregateInput
    _min?: YouTubeMinOrderByAggregateInput
    _sum?: YouTubeSumOrderByAggregateInput
  }

  export type YouTubeScalarWhereWithAggregatesInput = {
    AND?: YouTubeScalarWhereWithAggregatesInput | YouTubeScalarWhereWithAggregatesInput[]
    OR?: YouTubeScalarWhereWithAggregatesInput[]
    NOT?: YouTubeScalarWhereWithAggregatesInput | YouTubeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"YouTube"> | string
    category?: StringWithAggregatesFilter<"YouTube"> | string
    name?: StringWithAggregatesFilter<"YouTube"> | string
    points?: IntWithAggregatesFilter<"YouTube"> | number
    link?: StringWithAggregatesFilter<"YouTube"> | string
    icon?: StringWithAggregatesFilter<"YouTube"> | string
  }

  export type YouTubeCompletionWhereInput = {
    AND?: YouTubeCompletionWhereInput | YouTubeCompletionWhereInput[]
    OR?: YouTubeCompletionWhereInput[]
    NOT?: YouTubeCompletionWhereInput | YouTubeCompletionWhereInput[]
    id?: StringFilter<"YouTubeCompletion"> | string
    taskId?: StringFilter<"YouTubeCompletion"> | string
    userId?: StringFilter<"YouTubeCompletion"> | string
    points?: IntFilter<"YouTubeCompletion"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    task?: XOR<YouTubeRelationFilter, YouTubeWhereInput>
  }

  export type YouTubeCompletionOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    user?: UserOrderByWithRelationInput
    task?: YouTubeOrderByWithRelationInput
  }

  export type YouTubeCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: YouTubeCompletionWhereInput | YouTubeCompletionWhereInput[]
    OR?: YouTubeCompletionWhereInput[]
    NOT?: YouTubeCompletionWhereInput | YouTubeCompletionWhereInput[]
    taskId?: StringFilter<"YouTubeCompletion"> | string
    userId?: StringFilter<"YouTubeCompletion"> | string
    points?: IntFilter<"YouTubeCompletion"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    task?: XOR<YouTubeRelationFilter, YouTubeWhereInput>
  }, "id">

  export type YouTubeCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    _count?: YouTubeCompletionCountOrderByAggregateInput
    _avg?: YouTubeCompletionAvgOrderByAggregateInput
    _max?: YouTubeCompletionMaxOrderByAggregateInput
    _min?: YouTubeCompletionMinOrderByAggregateInput
    _sum?: YouTubeCompletionSumOrderByAggregateInput
  }

  export type YouTubeCompletionScalarWhereWithAggregatesInput = {
    AND?: YouTubeCompletionScalarWhereWithAggregatesInput | YouTubeCompletionScalarWhereWithAggregatesInput[]
    OR?: YouTubeCompletionScalarWhereWithAggregatesInput[]
    NOT?: YouTubeCompletionScalarWhereWithAggregatesInput | YouTubeCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"YouTubeCompletion"> | string
    taskId?: StringWithAggregatesFilter<"YouTubeCompletion"> | string
    userId?: StringWithAggregatesFilter<"YouTubeCompletion"> | string
    points?: IntWithAggregatesFilter<"YouTubeCompletion"> | number
  }

  export type SkinsWhereInput = {
    AND?: SkinsWhereInput | SkinsWhereInput[]
    OR?: SkinsWhereInput[]
    NOT?: SkinsWhereInput | SkinsWhereInput[]
    id?: StringFilter<"Skins"> | string
    name?: StringFilter<"Skins"> | string
    image?: StringFilter<"Skins"> | string
    cost?: IntFilter<"Skins"> | number
    featured?: BoolFilter<"Skins"> | boolean
    league?: StringFilter<"Skins"> | string
    users?: UserSkinListRelationFilter
  }

  export type SkinsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    cost?: SortOrder
    featured?: SortOrder
    league?: SortOrder
    users?: UserSkinOrderByRelationAggregateInput
  }

  export type SkinsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkinsWhereInput | SkinsWhereInput[]
    OR?: SkinsWhereInput[]
    NOT?: SkinsWhereInput | SkinsWhereInput[]
    name?: StringFilter<"Skins"> | string
    image?: StringFilter<"Skins"> | string
    cost?: IntFilter<"Skins"> | number
    featured?: BoolFilter<"Skins"> | boolean
    league?: StringFilter<"Skins"> | string
    users?: UserSkinListRelationFilter
  }, "id">

  export type SkinsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    cost?: SortOrder
    featured?: SortOrder
    league?: SortOrder
    _count?: SkinsCountOrderByAggregateInput
    _avg?: SkinsAvgOrderByAggregateInput
    _max?: SkinsMaxOrderByAggregateInput
    _min?: SkinsMinOrderByAggregateInput
    _sum?: SkinsSumOrderByAggregateInput
  }

  export type SkinsScalarWhereWithAggregatesInput = {
    AND?: SkinsScalarWhereWithAggregatesInput | SkinsScalarWhereWithAggregatesInput[]
    OR?: SkinsScalarWhereWithAggregatesInput[]
    NOT?: SkinsScalarWhereWithAggregatesInput | SkinsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skins"> | string
    name?: StringWithAggregatesFilter<"Skins"> | string
    image?: StringWithAggregatesFilter<"Skins"> | string
    cost?: IntWithAggregatesFilter<"Skins"> | number
    featured?: BoolWithAggregatesFilter<"Skins"> | boolean
    league?: StringWithAggregatesFilter<"Skins"> | string
  }

  export type UserSkinWhereInput = {
    AND?: UserSkinWhereInput | UserSkinWhereInput[]
    OR?: UserSkinWhereInput[]
    NOT?: UserSkinWhereInput | UserSkinWhereInput[]
    id?: StringFilter<"UserSkin"> | string
    userId?: StringFilter<"UserSkin"> | string
    skinId?: StringFilter<"UserSkin"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skin?: XOR<SkinsRelationFilter, SkinsWhereInput>
  }

  export type UserSkinOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    skinId?: SortOrder
    user?: UserOrderByWithRelationInput
    skin?: SkinsOrderByWithRelationInput
  }

  export type UserSkinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSkinWhereInput | UserSkinWhereInput[]
    OR?: UserSkinWhereInput[]
    NOT?: UserSkinWhereInput | UserSkinWhereInput[]
    userId?: StringFilter<"UserSkin"> | string
    skinId?: StringFilter<"UserSkin"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skin?: XOR<SkinsRelationFilter, SkinsWhereInput>
  }, "id">

  export type UserSkinOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    skinId?: SortOrder
    _count?: UserSkinCountOrderByAggregateInput
    _max?: UserSkinMaxOrderByAggregateInput
    _min?: UserSkinMinOrderByAggregateInput
  }

  export type UserSkinScalarWhereWithAggregatesInput = {
    AND?: UserSkinScalarWhereWithAggregatesInput | UserSkinScalarWhereWithAggregatesInput[]
    OR?: UserSkinScalarWhereWithAggregatesInput[]
    NOT?: UserSkinScalarWhereWithAggregatesInput | UserSkinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSkin"> | string
    userId?: StringWithAggregatesFilter<"UserSkin"> | string
    skinId?: StringWithAggregatesFilter<"UserSkin"> | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AchievementCategoryCreateInput = {
    id?: string
    name: string
    milestones?: AchievementMilestoneCreateNestedManyWithoutCategoryInput
  }

  export type AchievementCategoryUncheckedCreateInput = {
    id?: string
    name: string
    milestones?: AchievementMilestoneUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type AchievementCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    milestones?: AchievementMilestoneUpdateManyWithoutCategoryNestedInput
  }

  export type AchievementCategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    milestones?: AchievementMilestoneUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AchievementCategoryCreateManyInput = {
    id?: string
    name: string
  }

  export type AchievementCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AchievementCategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AchievementMilestoneCreateInput = {
    id?: string
    name: string
    icon: string
    unlocked?: boolean
    category: AchievementCategoryCreateNestedOneWithoutMilestonesInput
    userAchievements?: UserAchievementCreateNestedManyWithoutMilestoneInput
  }

  export type AchievementMilestoneUncheckedCreateInput = {
    id?: string
    categoryId: string
    name: string
    icon: string
    unlocked?: boolean
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type AchievementMilestoneUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    category?: AchievementCategoryUpdateOneRequiredWithoutMilestonesNestedInput
    userAchievements?: UserAchievementUpdateManyWithoutMilestoneNestedInput
  }

  export type AchievementMilestoneUncheckedUpdateInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type AchievementMilestoneCreateManyInput = {
    id?: string
    categoryId: string
    name: string
    icon: string
    unlocked?: boolean
  }

  export type AchievementMilestoneUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementMilestoneUncheckedUpdateManyInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutAchievementsInput
    milestone: AchievementMilestoneCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    milestoneId: string
  }

  export type UserAchievementUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    milestone?: AchievementMilestoneUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    milestoneId: string
  }

  export type UserAchievementUpdateManyMutationInput = {

  }

  export type UserAchievementUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyRewardCreateInput = {
    id?: string
    day: number
    coins: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDailyRewardsInput
  }

  export type DailyRewardUncheckedCreateInput = {
    id?: string
    userId: string
    day: number
    coins: number
    createdAt?: Date | string
  }

  export type DailyRewardUpdateInput = {
    day?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyRewardsNestedInput
  }

  export type DailyRewardUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRewardCreateManyInput = {
    id?: string
    userId: string
    day: number
    coins: number
    createdAt?: Date | string
  }

  export type DailyRewardUpdateManyMutationInput = {
    day?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRewardUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardCreateInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    category: string
    discription?: string | null
    requiredCardId?: string | null
    requiredCardLevel?: number | null
    requiredCardTitle?: string | null
    users?: UserCardCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    category: string
    discription?: string | null
    requiredCardId?: string | null
    requiredCardLevel?: number | null
    requiredCardTitle?: string | null
    users?: UserCardUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardLevel?: NullableIntFieldUpdateOperationsInput | number | null
    requiredCardTitle?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserCardUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardLevel?: NullableIntFieldUpdateOperationsInput | number | null
    requiredCardTitle?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserCardUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardCreateManyInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    category: string
    discription?: string | null
    requiredCardId?: string | null
    requiredCardLevel?: number | null
    requiredCardTitle?: string | null
  }

  export type CardUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardLevel?: NullableIntFieldUpdateOperationsInput | number | null
    requiredCardTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardLevel?: NullableIntFieldUpdateOperationsInput | number | null
    requiredCardTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardCreateInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    category: string
    discription?: string | null
    user: UserCreateNestedOneWithoutUserCardInput
    card: CardCreateNestedOneWithoutUsersInput
  }

  export type UserCardUncheckedCreateInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    userId: string
    cardId: string
    category: string
    discription?: string | null
  }

  export type UserCardUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserCardNestedInput
    card?: CardUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserCardUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardCreateManyInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    userId: string
    cardId: string
    category: string
    discription?: string | null
  }

  export type UserCardUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthenticatorCreateInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
    user: UserCreateNestedOneWithoutAuthenticatorsInput
  }

  export type AuthenticatorUncheckedCreateInput = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUpdateInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAuthenticatorsNestedInput
  }

  export type AuthenticatorUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorCreateManyInput = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUpdateManyMutationInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaguesCreateInput = {
    id?: string
    name: string
    minEntry: number
    pointLimit: number
    trophy: string
    entryReward: string
  }

  export type LeaguesUncheckedCreateInput = {
    id?: string
    name: string
    minEntry: number
    pointLimit: number
    trophy: string
    entryReward: string
  }

  export type LeaguesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    minEntry?: IntFieldUpdateOperationsInput | number
    pointLimit?: IntFieldUpdateOperationsInput | number
    trophy?: StringFieldUpdateOperationsInput | string
    entryReward?: StringFieldUpdateOperationsInput | string
  }

  export type LeaguesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    minEntry?: IntFieldUpdateOperationsInput | number
    pointLimit?: IntFieldUpdateOperationsInput | number
    trophy?: StringFieldUpdateOperationsInput | string
    entryReward?: StringFieldUpdateOperationsInput | string
  }

  export type LeaguesCreateManyInput = {
    id?: string
    name: string
    minEntry: number
    pointLimit: number
    trophy: string
    entryReward: string
  }

  export type LeaguesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    minEntry?: IntFieldUpdateOperationsInput | number
    pointLimit?: IntFieldUpdateOperationsInput | number
    trophy?: StringFieldUpdateOperationsInput | string
    entryReward?: StringFieldUpdateOperationsInput | string
  }

  export type LeaguesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    minEntry?: IntFieldUpdateOperationsInput | number
    pointLimit?: IntFieldUpdateOperationsInput | number
    trophy?: StringFieldUpdateOperationsInput | string
    entryReward?: StringFieldUpdateOperationsInput | string
  }

  export type PointsCreateInput = {
    id?: string
    user: string
    points?: number
    league: string
    autominer?: boolean
    tapLimit: number
    lastTap: Date | string
  }

  export type PointsUncheckedCreateInput = {
    id?: string
    user: string
    points?: number
    league: string
    autominer?: boolean
    tapLimit: number
    lastTap: Date | string
  }

  export type PointsUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    league?: StringFieldUpdateOperationsInput | string
    autominer?: BoolFieldUpdateOperationsInput | boolean
    tapLimit?: IntFieldUpdateOperationsInput | number
    lastTap?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsUncheckedUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    league?: StringFieldUpdateOperationsInput | string
    autominer?: BoolFieldUpdateOperationsInput | boolean
    tapLimit?: IntFieldUpdateOperationsInput | number
    lastTap?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsCreateManyInput = {
    id?: string
    user: string
    points?: number
    league: string
    autominer?: boolean
    tapLimit: number
    lastTap: Date | string
  }

  export type PointsUpdateManyMutationInput = {
    user?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    league?: StringFieldUpdateOperationsInput | string
    autominer?: BoolFieldUpdateOperationsInput | boolean
    tapLimit?: IntFieldUpdateOperationsInput | number
    lastTap?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsUncheckedUpdateManyInput = {
    user?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    league?: StringFieldUpdateOperationsInput | string
    autominer?: BoolFieldUpdateOperationsInput | boolean
    tapLimit?: IntFieldUpdateOperationsInput | number
    lastTap?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusterCreateInput = {
    id?: string
    energy: number
    energyCost: number
    energylevel: number
    multiClickLevel?: number
    multiClickCost?: number
    user: UserCreateNestedOneWithoutBonusterInput
  }

  export type BonusterUncheckedCreateInput = {
    id?: string
    chatId: string
    energy: number
    energyCost: number
    energylevel: number
    multiClickLevel?: number
    multiClickCost?: number
  }

  export type BonusterUpdateInput = {
    energy?: IntFieldUpdateOperationsInput | number
    energyCost?: IntFieldUpdateOperationsInput | number
    energylevel?: IntFieldUpdateOperationsInput | number
    multiClickLevel?: IntFieldUpdateOperationsInput | number
    multiClickCost?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutBonusterNestedInput
  }

  export type BonusterUncheckedUpdateInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    energyCost?: IntFieldUpdateOperationsInput | number
    energylevel?: IntFieldUpdateOperationsInput | number
    multiClickLevel?: IntFieldUpdateOperationsInput | number
    multiClickCost?: IntFieldUpdateOperationsInput | number
  }

  export type BonusterCreateManyInput = {
    id?: string
    chatId: string
    energy: number
    energyCost: number
    energylevel: number
    multiClickLevel?: number
    multiClickCost?: number
  }

  export type BonusterUpdateManyMutationInput = {
    energy?: IntFieldUpdateOperationsInput | number
    energyCost?: IntFieldUpdateOperationsInput | number
    energylevel?: IntFieldUpdateOperationsInput | number
    multiClickLevel?: IntFieldUpdateOperationsInput | number
    multiClickCost?: IntFieldUpdateOperationsInput | number
  }

  export type BonusterUncheckedUpdateManyInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    energyCost?: IntFieldUpdateOperationsInput | number
    energylevel?: IntFieldUpdateOperationsInput | number
    multiClickLevel?: IntFieldUpdateOperationsInput | number
    multiClickCost?: IntFieldUpdateOperationsInput | number
  }

  export type DailyBoostersCreateInput = {
    id?: string
    name: string
    count: number
    icon: string
  }

  export type DailyBoostersUncheckedCreateInput = {
    id?: string
    name: string
    count: number
    icon: string
  }

  export type DailyBoostersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type DailyBoostersUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type DailyBoostersCreateManyInput = {
    id?: string
    name: string
    count: number
    icon: string
  }

  export type DailyBoostersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type DailyBoostersUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCategoriesCreateInput = {
    id?: string
    name: string
  }

  export type TaskCategoriesUncheckedCreateInput = {
    id?: string
    name: string
  }

  export type TaskCategoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCategoriesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCategoriesCreateManyInput = {
    id?: string
    name: string
  }

  export type TaskCategoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCategoriesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TasksCreateInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
    user?: TasksCompletionCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
    user?: TasksCompletionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    user?: TasksCompletionUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    user?: TasksCompletionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksCreateManyInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
  }

  export type TasksUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type TasksUncheckedUpdateManyInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type TasksCompletionCreateInput = {
    id?: string
    points: number
    user: UserCreateNestedOneWithoutUserTasksInput
    task: TasksCreateNestedOneWithoutUserInput
  }

  export type TasksCompletionUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
    points: number
  }

  export type TasksCompletionUpdateInput = {
    points?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserTasksNestedInput
    task?: TasksUpdateOneRequiredWithoutUserNestedInput
  }

  export type TasksCompletionUncheckedUpdateInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TasksCompletionCreateManyInput = {
    id?: string
    taskId: string
    userId: string
    points: number
  }

  export type TasksCompletionUpdateManyMutationInput = {
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TasksCompletionUncheckedUpdateManyInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type YouTubeCreateInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
    user?: YouTubeCompletionCreateNestedManyWithoutTaskInput
  }

  export type YouTubeUncheckedCreateInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
    user?: YouTubeCompletionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type YouTubeUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    user?: YouTubeCompletionUpdateManyWithoutTaskNestedInput
  }

  export type YouTubeUncheckedUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    user?: YouTubeCompletionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type YouTubeCreateManyInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
  }

  export type YouTubeUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type YouTubeUncheckedUpdateManyInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type YouTubeCompletionCreateInput = {
    id?: string
    points: number
    user: UserCreateNestedOneWithoutUserYouTubeInput
    task: YouTubeCreateNestedOneWithoutUserInput
  }

  export type YouTubeCompletionUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
    points: number
  }

  export type YouTubeCompletionUpdateInput = {
    points?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserYouTubeNestedInput
    task?: YouTubeUpdateOneRequiredWithoutUserNestedInput
  }

  export type YouTubeCompletionUncheckedUpdateInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type YouTubeCompletionCreateManyInput = {
    id?: string
    taskId: string
    userId: string
    points: number
  }

  export type YouTubeCompletionUpdateManyMutationInput = {
    points?: IntFieldUpdateOperationsInput | number
  }

  export type YouTubeCompletionUncheckedUpdateManyInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type SkinsCreateInput = {
    id?: string
    name: string
    image?: string
    cost: number
    featured?: boolean
    league?: string
    users?: UserSkinCreateNestedManyWithoutSkinInput
  }

  export type SkinsUncheckedCreateInput = {
    id?: string
    name: string
    image?: string
    cost: number
    featured?: boolean
    league?: string
    users?: UserSkinUncheckedCreateNestedManyWithoutSkinInput
  }

  export type SkinsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    league?: StringFieldUpdateOperationsInput | string
    users?: UserSkinUpdateManyWithoutSkinNestedInput
  }

  export type SkinsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    league?: StringFieldUpdateOperationsInput | string
    users?: UserSkinUncheckedUpdateManyWithoutSkinNestedInput
  }

  export type SkinsCreateManyInput = {
    id?: string
    name: string
    image?: string
    cost: number
    featured?: boolean
    league?: string
  }

  export type SkinsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    league?: StringFieldUpdateOperationsInput | string
  }

  export type SkinsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    league?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkinCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutSkinsInput
    skin: SkinsCreateNestedOneWithoutUsersInput
  }

  export type UserSkinUncheckedCreateInput = {
    id?: string
    userId: string
    skinId: string
  }

  export type UserSkinUpdateInput = {
    user?: UserUpdateOneRequiredWithoutSkinsNestedInput
    skin?: SkinsUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserSkinUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    skinId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkinCreateManyInput = {
    id?: string
    userId: string
    skinId: string
  }

  export type UserSkinUpdateManyMutationInput = {

  }

  export type UserSkinUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    skinId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserSkinListRelationFilter = {
    every?: UserSkinWhereInput
    some?: UserSkinWhereInput
    none?: UserSkinWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuthenticatorListRelationFilter = {
    every?: AuthenticatorWhereInput
    some?: AuthenticatorWhereInput
    none?: AuthenticatorWhereInput
  }

  export type UserCardListRelationFilter = {
    every?: UserCardWhereInput
    some?: UserCardWhereInput
    none?: UserCardWhereInput
  }

  export type BonusterListRelationFilter = {
    every?: BonusterWhereInput
    some?: BonusterWhereInput
    none?: BonusterWhereInput
  }

  export type DailyRewardListRelationFilter = {
    every?: DailyRewardWhereInput
    some?: DailyRewardWhereInput
    none?: DailyRewardWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type TasksCompletionListRelationFilter = {
    every?: TasksCompletionWhereInput
    some?: TasksCompletionWhereInput
    none?: TasksCompletionWhereInput
  }

  export type YouTubeCompletionListRelationFilter = {
    every?: YouTubeCompletionWhereInput
    some?: YouTubeCompletionWhereInput
    none?: YouTubeCompletionWhereInput
  }

  export type UserSkinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthenticatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BonusterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyRewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TasksCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YouTubeCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chatId?: SortOrder
    taps?: SortOrder
    points?: SortOrder
    profit?: SortOrder
    lastProfitDate?: SortOrder
    rechargeLimit?: SortOrder
    pointPerTap?: SortOrder
    profitPerHour?: SortOrder
    refillRate?: SortOrder
    bonus?: SortOrder
    active?: SortOrder
    skin?: SortOrder
    lastLogin?: SortOrder
    league?: SortOrder
    referralCount?: SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    taps?: SortOrder
    points?: SortOrder
    profit?: SortOrder
    lastProfitDate?: SortOrder
    rechargeLimit?: SortOrder
    pointPerTap?: SortOrder
    profitPerHour?: SortOrder
    refillRate?: SortOrder
    bonus?: SortOrder
    referralCount?: SortOrder
    loginStreak?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chatId?: SortOrder
    taps?: SortOrder
    points?: SortOrder
    profit?: SortOrder
    lastProfitDate?: SortOrder
    rechargeLimit?: SortOrder
    pointPerTap?: SortOrder
    profitPerHour?: SortOrder
    refillRate?: SortOrder
    bonus?: SortOrder
    active?: SortOrder
    skin?: SortOrder
    lastLogin?: SortOrder
    league?: SortOrder
    referralCount?: SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chatId?: SortOrder
    taps?: SortOrder
    points?: SortOrder
    profit?: SortOrder
    lastProfitDate?: SortOrder
    rechargeLimit?: SortOrder
    pointPerTap?: SortOrder
    profitPerHour?: SortOrder
    refillRate?: SortOrder
    bonus?: SortOrder
    active?: SortOrder
    skin?: SortOrder
    lastLogin?: SortOrder
    league?: SortOrder
    referralCount?: SortOrder
    loginStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    taps?: SortOrder
    points?: SortOrder
    profit?: SortOrder
    lastProfitDate?: SortOrder
    rechargeLimit?: SortOrder
    pointPerTap?: SortOrder
    profitPerHour?: SortOrder
    refillRate?: SortOrder
    bonus?: SortOrder
    referralCount?: SortOrder
    loginStreak?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AchievementMilestoneListRelationFilter = {
    every?: AchievementMilestoneWhereInput
    some?: AchievementMilestoneWhereInput
    none?: AchievementMilestoneWhereInput
  }

  export type AchievementMilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AchievementCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AchievementCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AchievementCategoryRelationFilter = {
    is?: AchievementCategoryWhereInput
    isNot?: AchievementCategoryWhereInput
  }

  export type AchievementMilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    unlocked?: SortOrder
  }

  export type AchievementMilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    unlocked?: SortOrder
  }

  export type AchievementMilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    unlocked?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AchievementMilestoneRelationFilter = {
    is?: AchievementMilestoneWhereInput
    isNot?: AchievementMilestoneWhereInput
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    milestoneId?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    milestoneId?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    milestoneId?: SortOrder
  }

  export type DailyRewardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    coins?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRewardAvgOrderByAggregateInput = {
    day?: SortOrder
    coins?: SortOrder
  }

  export type DailyRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    coins?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRewardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    coins?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRewardSumOrderByAggregateInput = {
    day?: SortOrder
    coins?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    category?: SortOrder
    discription?: SortOrder
    requiredCardId?: SortOrder
    requiredCardLevel?: SortOrder
    requiredCardTitle?: SortOrder
  }

  export type CardAvgOrderByAggregateInput = {
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    requiredCardLevel?: SortOrder
  }

  export type CardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    category?: SortOrder
    discription?: SortOrder
    requiredCardId?: SortOrder
    requiredCardLevel?: SortOrder
    requiredCardTitle?: SortOrder
  }

  export type CardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    category?: SortOrder
    discription?: SortOrder
    requiredCardId?: SortOrder
    requiredCardLevel?: SortOrder
    requiredCardTitle?: SortOrder
  }

  export type CardSumOrderByAggregateInput = {
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    requiredCardLevel?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CardRelationFilter = {
    is?: CardWhereInput
    isNot?: CardWhereInput
  }

  export type UserCardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    category?: SortOrder
    discription?: SortOrder
  }

  export type UserCardAvgOrderByAggregateInput = {
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
  }

  export type UserCardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    category?: SortOrder
    discription?: SortOrder
  }

  export type UserCardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    category?: SortOrder
    discription?: SortOrder
  }

  export type UserCardSumOrderByAggregateInput = {
    baseCost?: SortOrder
    basePPH?: SortOrder
    baseLevel?: SortOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type AuthenticatorUserIdCredentialIDCompoundUniqueInput = {
    userId: string
    credentialID: string
  }

  export type AuthenticatorCountOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type AuthenticatorMaxOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorMinOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorSumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type LeaguesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    minEntry?: SortOrder
    pointLimit?: SortOrder
    trophy?: SortOrder
    entryReward?: SortOrder
  }

  export type LeaguesAvgOrderByAggregateInput = {
    minEntry?: SortOrder
    pointLimit?: SortOrder
  }

  export type LeaguesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    minEntry?: SortOrder
    pointLimit?: SortOrder
    trophy?: SortOrder
    entryReward?: SortOrder
  }

  export type LeaguesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    minEntry?: SortOrder
    pointLimit?: SortOrder
    trophy?: SortOrder
    entryReward?: SortOrder
  }

  export type LeaguesSumOrderByAggregateInput = {
    minEntry?: SortOrder
    pointLimit?: SortOrder
  }

  export type PointsCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    points?: SortOrder
    league?: SortOrder
    autominer?: SortOrder
    tapLimit?: SortOrder
    lastTap?: SortOrder
  }

  export type PointsAvgOrderByAggregateInput = {
    points?: SortOrder
    tapLimit?: SortOrder
  }

  export type PointsMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    points?: SortOrder
    league?: SortOrder
    autominer?: SortOrder
    tapLimit?: SortOrder
    lastTap?: SortOrder
  }

  export type PointsMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    points?: SortOrder
    league?: SortOrder
    autominer?: SortOrder
    tapLimit?: SortOrder
    lastTap?: SortOrder
  }

  export type PointsSumOrderByAggregateInput = {
    points?: SortOrder
    tapLimit?: SortOrder
  }

  export type BonusterCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    energy?: SortOrder
    energyCost?: SortOrder
    energylevel?: SortOrder
    multiClickLevel?: SortOrder
    multiClickCost?: SortOrder
  }

  export type BonusterAvgOrderByAggregateInput = {
    energy?: SortOrder
    energyCost?: SortOrder
    energylevel?: SortOrder
    multiClickLevel?: SortOrder
    multiClickCost?: SortOrder
  }

  export type BonusterMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    energy?: SortOrder
    energyCost?: SortOrder
    energylevel?: SortOrder
    multiClickLevel?: SortOrder
    multiClickCost?: SortOrder
  }

  export type BonusterMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    energy?: SortOrder
    energyCost?: SortOrder
    energylevel?: SortOrder
    multiClickLevel?: SortOrder
    multiClickCost?: SortOrder
  }

  export type BonusterSumOrderByAggregateInput = {
    energy?: SortOrder
    energyCost?: SortOrder
    energylevel?: SortOrder
    multiClickLevel?: SortOrder
    multiClickCost?: SortOrder
  }

  export type DailyBoostersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    count?: SortOrder
    icon?: SortOrder
  }

  export type DailyBoostersAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type DailyBoostersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    count?: SortOrder
    icon?: SortOrder
  }

  export type DailyBoostersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    count?: SortOrder
    icon?: SortOrder
  }

  export type DailyBoostersSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type TaskCategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TaskCategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TaskCategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TasksCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
  }

  export type TasksAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type TasksMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
  }

  export type TasksMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
  }

  export type TasksSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type TasksRelationFilter = {
    is?: TasksWhereInput
    isNot?: TasksWhereInput
  }

  export type TasksCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
  }

  export type TasksCompletionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type TasksCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
  }

  export type TasksCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
  }

  export type TasksCompletionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type YouTubeCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
  }

  export type YouTubeAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type YouTubeMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
  }

  export type YouTubeMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    points?: SortOrder
    link?: SortOrder
    icon?: SortOrder
  }

  export type YouTubeSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type YouTubeRelationFilter = {
    is?: YouTubeWhereInput
    isNot?: YouTubeWhereInput
  }

  export type YouTubeCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
  }

  export type YouTubeCompletionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type YouTubeCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
  }

  export type YouTubeCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
  }

  export type YouTubeCompletionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type SkinsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    cost?: SortOrder
    featured?: SortOrder
    league?: SortOrder
  }

  export type SkinsAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type SkinsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    cost?: SortOrder
    featured?: SortOrder
    league?: SortOrder
  }

  export type SkinsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    cost?: SortOrder
    featured?: SortOrder
    league?: SortOrder
  }

  export type SkinsSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type SkinsRelationFilter = {
    is?: SkinsWhereInput
    isNot?: SkinsWhereInput
  }

  export type UserSkinCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skinId?: SortOrder
  }

  export type UserSkinMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skinId?: SortOrder
  }

  export type UserSkinMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skinId?: SortOrder
  }

  export type UserSkinCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkinCreateWithoutUserInput, UserSkinUncheckedCreateWithoutUserInput> | UserSkinCreateWithoutUserInput[] | UserSkinUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkinCreateOrConnectWithoutUserInput | UserSkinCreateOrConnectWithoutUserInput[]
    createMany?: UserSkinCreateManyUserInputEnvelope
    connect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuthenticatorCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
  }

  export type UserCardCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput> | UserCardCreateWithoutUserInput[] | UserCardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUserInput | UserCardCreateOrConnectWithoutUserInput[]
    createMany?: UserCardCreateManyUserInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type BonusterCreateNestedManyWithoutUserInput = {
    create?: XOR<BonusterCreateWithoutUserInput, BonusterUncheckedCreateWithoutUserInput> | BonusterCreateWithoutUserInput[] | BonusterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BonusterCreateOrConnectWithoutUserInput | BonusterCreateOrConnectWithoutUserInput[]
    createMany?: BonusterCreateManyUserInputEnvelope
    connect?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
  }

  export type DailyRewardCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyRewardCreateWithoutUserInput, DailyRewardUncheckedCreateWithoutUserInput> | DailyRewardCreateWithoutUserInput[] | DailyRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyRewardCreateOrConnectWithoutUserInput | DailyRewardCreateOrConnectWithoutUserInput[]
    createMany?: DailyRewardCreateManyUserInputEnvelope
    connect?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type TasksCompletionCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksCompletionCreateWithoutUserInput, TasksCompletionUncheckedCreateWithoutUserInput> | TasksCompletionCreateWithoutUserInput[] | TasksCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCompletionCreateOrConnectWithoutUserInput | TasksCompletionCreateOrConnectWithoutUserInput[]
    createMany?: TasksCompletionCreateManyUserInputEnvelope
    connect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
  }

  export type YouTubeCompletionCreateNestedManyWithoutUserInput = {
    create?: XOR<YouTubeCompletionCreateWithoutUserInput, YouTubeCompletionUncheckedCreateWithoutUserInput> | YouTubeCompletionCreateWithoutUserInput[] | YouTubeCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: YouTubeCompletionCreateOrConnectWithoutUserInput | YouTubeCompletionCreateOrConnectWithoutUserInput[]
    createMany?: YouTubeCompletionCreateManyUserInputEnvelope
    connect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
  }

  export type UserSkinUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkinCreateWithoutUserInput, UserSkinUncheckedCreateWithoutUserInput> | UserSkinCreateWithoutUserInput[] | UserSkinUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkinCreateOrConnectWithoutUserInput | UserSkinCreateOrConnectWithoutUserInput[]
    createMany?: UserSkinCreateManyUserInputEnvelope
    connect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuthenticatorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
  }

  export type UserCardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput> | UserCardCreateWithoutUserInput[] | UserCardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUserInput | UserCardCreateOrConnectWithoutUserInput[]
    createMany?: UserCardCreateManyUserInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type BonusterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BonusterCreateWithoutUserInput, BonusterUncheckedCreateWithoutUserInput> | BonusterCreateWithoutUserInput[] | BonusterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BonusterCreateOrConnectWithoutUserInput | BonusterCreateOrConnectWithoutUserInput[]
    createMany?: BonusterCreateManyUserInputEnvelope
    connect?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
  }

  export type DailyRewardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyRewardCreateWithoutUserInput, DailyRewardUncheckedCreateWithoutUserInput> | DailyRewardCreateWithoutUserInput[] | DailyRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyRewardCreateOrConnectWithoutUserInput | DailyRewardCreateOrConnectWithoutUserInput[]
    createMany?: DailyRewardCreateManyUserInputEnvelope
    connect?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type TasksCompletionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksCompletionCreateWithoutUserInput, TasksCompletionUncheckedCreateWithoutUserInput> | TasksCompletionCreateWithoutUserInput[] | TasksCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCompletionCreateOrConnectWithoutUserInput | TasksCompletionCreateOrConnectWithoutUserInput[]
    createMany?: TasksCompletionCreateManyUserInputEnvelope
    connect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
  }

  export type YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<YouTubeCompletionCreateWithoutUserInput, YouTubeCompletionUncheckedCreateWithoutUserInput> | YouTubeCompletionCreateWithoutUserInput[] | YouTubeCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: YouTubeCompletionCreateOrConnectWithoutUserInput | YouTubeCompletionCreateOrConnectWithoutUserInput[]
    createMany?: YouTubeCompletionCreateManyUserInputEnvelope
    connect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserSkinUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkinCreateWithoutUserInput, UserSkinUncheckedCreateWithoutUserInput> | UserSkinCreateWithoutUserInput[] | UserSkinUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkinCreateOrConnectWithoutUserInput | UserSkinCreateOrConnectWithoutUserInput[]
    upsert?: UserSkinUpsertWithWhereUniqueWithoutUserInput | UserSkinUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkinCreateManyUserInputEnvelope
    set?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    disconnect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    delete?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    connect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    update?: UserSkinUpdateWithWhereUniqueWithoutUserInput | UserSkinUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkinUpdateManyWithWhereWithoutUserInput | UserSkinUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkinScalarWhereInput | UserSkinScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuthenticatorUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    upsert?: AuthenticatorUpsertWithWhereUniqueWithoutUserInput | AuthenticatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    set?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    disconnect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    delete?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    update?: AuthenticatorUpdateWithWhereUniqueWithoutUserInput | AuthenticatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthenticatorUpdateManyWithWhereWithoutUserInput | AuthenticatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
  }

  export type UserCardUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput> | UserCardCreateWithoutUserInput[] | UserCardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUserInput | UserCardCreateOrConnectWithoutUserInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutUserInput | UserCardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCardCreateManyUserInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutUserInput | UserCardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutUserInput | UserCardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type BonusterUpdateManyWithoutUserNestedInput = {
    create?: XOR<BonusterCreateWithoutUserInput, BonusterUncheckedCreateWithoutUserInput> | BonusterCreateWithoutUserInput[] | BonusterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BonusterCreateOrConnectWithoutUserInput | BonusterCreateOrConnectWithoutUserInput[]
    upsert?: BonusterUpsertWithWhereUniqueWithoutUserInput | BonusterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BonusterCreateManyUserInputEnvelope
    set?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
    disconnect?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
    delete?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
    connect?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
    update?: BonusterUpdateWithWhereUniqueWithoutUserInput | BonusterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BonusterUpdateManyWithWhereWithoutUserInput | BonusterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BonusterScalarWhereInput | BonusterScalarWhereInput[]
  }

  export type DailyRewardUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyRewardCreateWithoutUserInput, DailyRewardUncheckedCreateWithoutUserInput> | DailyRewardCreateWithoutUserInput[] | DailyRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyRewardCreateOrConnectWithoutUserInput | DailyRewardCreateOrConnectWithoutUserInput[]
    upsert?: DailyRewardUpsertWithWhereUniqueWithoutUserInput | DailyRewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyRewardCreateManyUserInputEnvelope
    set?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
    disconnect?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
    delete?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
    connect?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
    update?: DailyRewardUpdateWithWhereUniqueWithoutUserInput | DailyRewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyRewardUpdateManyWithWhereWithoutUserInput | DailyRewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyRewardScalarWhereInput | DailyRewardScalarWhereInput[]
  }

  export type UserUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferredByInput | UserUpsertWithWhereUniqueWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferredByInput | UserUpdateWithWhereUniqueWithoutReferredByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferredByInput | UserUpdateManyWithWhereWithoutReferredByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type TasksCompletionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksCompletionCreateWithoutUserInput, TasksCompletionUncheckedCreateWithoutUserInput> | TasksCompletionCreateWithoutUserInput[] | TasksCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCompletionCreateOrConnectWithoutUserInput | TasksCompletionCreateOrConnectWithoutUserInput[]
    upsert?: TasksCompletionUpsertWithWhereUniqueWithoutUserInput | TasksCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksCompletionCreateManyUserInputEnvelope
    set?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    disconnect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    delete?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    connect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    update?: TasksCompletionUpdateWithWhereUniqueWithoutUserInput | TasksCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksCompletionUpdateManyWithWhereWithoutUserInput | TasksCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksCompletionScalarWhereInput | TasksCompletionScalarWhereInput[]
  }

  export type YouTubeCompletionUpdateManyWithoutUserNestedInput = {
    create?: XOR<YouTubeCompletionCreateWithoutUserInput, YouTubeCompletionUncheckedCreateWithoutUserInput> | YouTubeCompletionCreateWithoutUserInput[] | YouTubeCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: YouTubeCompletionCreateOrConnectWithoutUserInput | YouTubeCompletionCreateOrConnectWithoutUserInput[]
    upsert?: YouTubeCompletionUpsertWithWhereUniqueWithoutUserInput | YouTubeCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: YouTubeCompletionCreateManyUserInputEnvelope
    set?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    disconnect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    delete?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    connect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    update?: YouTubeCompletionUpdateWithWhereUniqueWithoutUserInput | YouTubeCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: YouTubeCompletionUpdateManyWithWhereWithoutUserInput | YouTubeCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: YouTubeCompletionScalarWhereInput | YouTubeCompletionScalarWhereInput[]
  }

  export type UserSkinUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkinCreateWithoutUserInput, UserSkinUncheckedCreateWithoutUserInput> | UserSkinCreateWithoutUserInput[] | UserSkinUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkinCreateOrConnectWithoutUserInput | UserSkinCreateOrConnectWithoutUserInput[]
    upsert?: UserSkinUpsertWithWhereUniqueWithoutUserInput | UserSkinUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkinCreateManyUserInputEnvelope
    set?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    disconnect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    delete?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    connect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    update?: UserSkinUpdateWithWhereUniqueWithoutUserInput | UserSkinUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkinUpdateManyWithWhereWithoutUserInput | UserSkinUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkinScalarWhereInput | UserSkinScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuthenticatorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    upsert?: AuthenticatorUpsertWithWhereUniqueWithoutUserInput | AuthenticatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    set?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    disconnect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    delete?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    update?: AuthenticatorUpdateWithWhereUniqueWithoutUserInput | AuthenticatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthenticatorUpdateManyWithWhereWithoutUserInput | AuthenticatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
  }

  export type UserCardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput> | UserCardCreateWithoutUserInput[] | UserCardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUserInput | UserCardCreateOrConnectWithoutUserInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutUserInput | UserCardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCardCreateManyUserInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutUserInput | UserCardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutUserInput | UserCardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type BonusterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BonusterCreateWithoutUserInput, BonusterUncheckedCreateWithoutUserInput> | BonusterCreateWithoutUserInput[] | BonusterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BonusterCreateOrConnectWithoutUserInput | BonusterCreateOrConnectWithoutUserInput[]
    upsert?: BonusterUpsertWithWhereUniqueWithoutUserInput | BonusterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BonusterCreateManyUserInputEnvelope
    set?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
    disconnect?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
    delete?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
    connect?: BonusterWhereUniqueInput | BonusterWhereUniqueInput[]
    update?: BonusterUpdateWithWhereUniqueWithoutUserInput | BonusterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BonusterUpdateManyWithWhereWithoutUserInput | BonusterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BonusterScalarWhereInput | BonusterScalarWhereInput[]
  }

  export type DailyRewardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyRewardCreateWithoutUserInput, DailyRewardUncheckedCreateWithoutUserInput> | DailyRewardCreateWithoutUserInput[] | DailyRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyRewardCreateOrConnectWithoutUserInput | DailyRewardCreateOrConnectWithoutUserInput[]
    upsert?: DailyRewardUpsertWithWhereUniqueWithoutUserInput | DailyRewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyRewardCreateManyUserInputEnvelope
    set?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
    disconnect?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
    delete?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
    connect?: DailyRewardWhereUniqueInput | DailyRewardWhereUniqueInput[]
    update?: DailyRewardUpdateWithWhereUniqueWithoutUserInput | DailyRewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyRewardUpdateManyWithWhereWithoutUserInput | DailyRewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyRewardScalarWhereInput | DailyRewardScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferredByInput | UserUpsertWithWhereUniqueWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferredByInput | UserUpdateWithWhereUniqueWithoutReferredByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferredByInput | UserUpdateManyWithWhereWithoutReferredByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type TasksCompletionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksCompletionCreateWithoutUserInput, TasksCompletionUncheckedCreateWithoutUserInput> | TasksCompletionCreateWithoutUserInput[] | TasksCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCompletionCreateOrConnectWithoutUserInput | TasksCompletionCreateOrConnectWithoutUserInput[]
    upsert?: TasksCompletionUpsertWithWhereUniqueWithoutUserInput | TasksCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksCompletionCreateManyUserInputEnvelope
    set?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    disconnect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    delete?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    connect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    update?: TasksCompletionUpdateWithWhereUniqueWithoutUserInput | TasksCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksCompletionUpdateManyWithWhereWithoutUserInput | TasksCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksCompletionScalarWhereInput | TasksCompletionScalarWhereInput[]
  }

  export type YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<YouTubeCompletionCreateWithoutUserInput, YouTubeCompletionUncheckedCreateWithoutUserInput> | YouTubeCompletionCreateWithoutUserInput[] | YouTubeCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: YouTubeCompletionCreateOrConnectWithoutUserInput | YouTubeCompletionCreateOrConnectWithoutUserInput[]
    upsert?: YouTubeCompletionUpsertWithWhereUniqueWithoutUserInput | YouTubeCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: YouTubeCompletionCreateManyUserInputEnvelope
    set?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    disconnect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    delete?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    connect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    update?: YouTubeCompletionUpdateWithWhereUniqueWithoutUserInput | YouTubeCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: YouTubeCompletionUpdateManyWithWhereWithoutUserInput | YouTubeCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: YouTubeCompletionScalarWhereInput | YouTubeCompletionScalarWhereInput[]
  }

  export type AchievementMilestoneCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AchievementMilestoneCreateWithoutCategoryInput, AchievementMilestoneUncheckedCreateWithoutCategoryInput> | AchievementMilestoneCreateWithoutCategoryInput[] | AchievementMilestoneUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AchievementMilestoneCreateOrConnectWithoutCategoryInput | AchievementMilestoneCreateOrConnectWithoutCategoryInput[]
    createMany?: AchievementMilestoneCreateManyCategoryInputEnvelope
    connect?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
  }

  export type AchievementMilestoneUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AchievementMilestoneCreateWithoutCategoryInput, AchievementMilestoneUncheckedCreateWithoutCategoryInput> | AchievementMilestoneCreateWithoutCategoryInput[] | AchievementMilestoneUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AchievementMilestoneCreateOrConnectWithoutCategoryInput | AchievementMilestoneCreateOrConnectWithoutCategoryInput[]
    createMany?: AchievementMilestoneCreateManyCategoryInputEnvelope
    connect?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
  }

  export type AchievementMilestoneUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AchievementMilestoneCreateWithoutCategoryInput, AchievementMilestoneUncheckedCreateWithoutCategoryInput> | AchievementMilestoneCreateWithoutCategoryInput[] | AchievementMilestoneUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AchievementMilestoneCreateOrConnectWithoutCategoryInput | AchievementMilestoneCreateOrConnectWithoutCategoryInput[]
    upsert?: AchievementMilestoneUpsertWithWhereUniqueWithoutCategoryInput | AchievementMilestoneUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AchievementMilestoneCreateManyCategoryInputEnvelope
    set?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
    disconnect?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
    delete?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
    connect?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
    update?: AchievementMilestoneUpdateWithWhereUniqueWithoutCategoryInput | AchievementMilestoneUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AchievementMilestoneUpdateManyWithWhereWithoutCategoryInput | AchievementMilestoneUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AchievementMilestoneScalarWhereInput | AchievementMilestoneScalarWhereInput[]
  }

  export type AchievementMilestoneUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AchievementMilestoneCreateWithoutCategoryInput, AchievementMilestoneUncheckedCreateWithoutCategoryInput> | AchievementMilestoneCreateWithoutCategoryInput[] | AchievementMilestoneUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AchievementMilestoneCreateOrConnectWithoutCategoryInput | AchievementMilestoneCreateOrConnectWithoutCategoryInput[]
    upsert?: AchievementMilestoneUpsertWithWhereUniqueWithoutCategoryInput | AchievementMilestoneUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AchievementMilestoneCreateManyCategoryInputEnvelope
    set?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
    disconnect?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
    delete?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
    connect?: AchievementMilestoneWhereUniqueInput | AchievementMilestoneWhereUniqueInput[]
    update?: AchievementMilestoneUpdateWithWhereUniqueWithoutCategoryInput | AchievementMilestoneUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AchievementMilestoneUpdateManyWithWhereWithoutCategoryInput | AchievementMilestoneUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AchievementMilestoneScalarWhereInput | AchievementMilestoneScalarWhereInput[]
  }

  export type AchievementCategoryCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<AchievementCategoryCreateWithoutMilestonesInput, AchievementCategoryUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: AchievementCategoryCreateOrConnectWithoutMilestonesInput
    connect?: AchievementCategoryWhereUniqueInput
  }

  export type UserAchievementCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<UserAchievementCreateWithoutMilestoneInput, UserAchievementUncheckedCreateWithoutMilestoneInput> | UserAchievementCreateWithoutMilestoneInput[] | UserAchievementUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutMilestoneInput | UserAchievementCreateOrConnectWithoutMilestoneInput[]
    createMany?: UserAchievementCreateManyMilestoneInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<UserAchievementCreateWithoutMilestoneInput, UserAchievementUncheckedCreateWithoutMilestoneInput> | UserAchievementCreateWithoutMilestoneInput[] | UserAchievementUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutMilestoneInput | UserAchievementCreateOrConnectWithoutMilestoneInput[]
    createMany?: UserAchievementCreateManyMilestoneInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type AchievementCategoryUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<AchievementCategoryCreateWithoutMilestonesInput, AchievementCategoryUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: AchievementCategoryCreateOrConnectWithoutMilestonesInput
    upsert?: AchievementCategoryUpsertWithoutMilestonesInput
    connect?: AchievementCategoryWhereUniqueInput
    update?: XOR<XOR<AchievementCategoryUpdateToOneWithWhereWithoutMilestonesInput, AchievementCategoryUpdateWithoutMilestonesInput>, AchievementCategoryUncheckedUpdateWithoutMilestonesInput>
  }

  export type UserAchievementUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<UserAchievementCreateWithoutMilestoneInput, UserAchievementUncheckedCreateWithoutMilestoneInput> | UserAchievementCreateWithoutMilestoneInput[] | UserAchievementUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutMilestoneInput | UserAchievementCreateOrConnectWithoutMilestoneInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutMilestoneInput | UserAchievementUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: UserAchievementCreateManyMilestoneInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutMilestoneInput | UserAchievementUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutMilestoneInput | UserAchievementUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<UserAchievementCreateWithoutMilestoneInput, UserAchievementUncheckedCreateWithoutMilestoneInput> | UserAchievementCreateWithoutMilestoneInput[] | UserAchievementUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutMilestoneInput | UserAchievementCreateOrConnectWithoutMilestoneInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutMilestoneInput | UserAchievementUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: UserAchievementCreateManyMilestoneInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutMilestoneInput | UserAchievementUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutMilestoneInput | UserAchievementUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementMilestoneCreateNestedOneWithoutUserAchievementsInput = {
    create?: XOR<AchievementMilestoneCreateWithoutUserAchievementsInput, AchievementMilestoneUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementMilestoneCreateOrConnectWithoutUserAchievementsInput
    connect?: AchievementMilestoneWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementMilestoneUpdateOneRequiredWithoutUserAchievementsNestedInput = {
    create?: XOR<AchievementMilestoneCreateWithoutUserAchievementsInput, AchievementMilestoneUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementMilestoneCreateOrConnectWithoutUserAchievementsInput
    upsert?: AchievementMilestoneUpsertWithoutUserAchievementsInput
    connect?: AchievementMilestoneWhereUniqueInput
    update?: XOR<XOR<AchievementMilestoneUpdateToOneWithWhereWithoutUserAchievementsInput, AchievementMilestoneUpdateWithoutUserAchievementsInput>, AchievementMilestoneUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type UserCreateNestedOneWithoutDailyRewardsInput = {
    create?: XOR<UserCreateWithoutDailyRewardsInput, UserUncheckedCreateWithoutDailyRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyRewardsNestedInput = {
    create?: XOR<UserCreateWithoutDailyRewardsInput, UserUncheckedCreateWithoutDailyRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyRewardsInput
    upsert?: UserUpsertWithoutDailyRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyRewardsInput, UserUpdateWithoutDailyRewardsInput>, UserUncheckedUpdateWithoutDailyRewardsInput>
  }

  export type UserCardCreateNestedManyWithoutCardInput = {
    create?: XOR<UserCardCreateWithoutCardInput, UserCardUncheckedCreateWithoutCardInput> | UserCardCreateWithoutCardInput[] | UserCardUncheckedCreateWithoutCardInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutCardInput | UserCardCreateOrConnectWithoutCardInput[]
    createMany?: UserCardCreateManyCardInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type UserCardUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<UserCardCreateWithoutCardInput, UserCardUncheckedCreateWithoutCardInput> | UserCardCreateWithoutCardInput[] | UserCardUncheckedCreateWithoutCardInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutCardInput | UserCardCreateOrConnectWithoutCardInput[]
    createMany?: UserCardCreateManyCardInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCardUpdateManyWithoutCardNestedInput = {
    create?: XOR<UserCardCreateWithoutCardInput, UserCardUncheckedCreateWithoutCardInput> | UserCardCreateWithoutCardInput[] | UserCardUncheckedCreateWithoutCardInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutCardInput | UserCardCreateOrConnectWithoutCardInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutCardInput | UserCardUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: UserCardCreateManyCardInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutCardInput | UserCardUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutCardInput | UserCardUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type UserCardUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<UserCardCreateWithoutCardInput, UserCardUncheckedCreateWithoutCardInput> | UserCardCreateWithoutCardInput[] | UserCardUncheckedCreateWithoutCardInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutCardInput | UserCardCreateOrConnectWithoutCardInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutCardInput | UserCardUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: UserCardCreateManyCardInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutCardInput | UserCardUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutCardInput | UserCardUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserCardInput = {
    create?: XOR<UserCreateWithoutUserCardInput, UserUncheckedCreateWithoutUserCardInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCardInput
    connect?: UserWhereUniqueInput
  }

  export type CardCreateNestedOneWithoutUsersInput = {
    create?: XOR<CardCreateWithoutUsersInput, CardUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CardCreateOrConnectWithoutUsersInput
    connect?: CardWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserCardNestedInput = {
    create?: XOR<UserCreateWithoutUserCardInput, UserUncheckedCreateWithoutUserCardInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCardInput
    upsert?: UserUpsertWithoutUserCardInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCardInput, UserUpdateWithoutUserCardInput>, UserUncheckedUpdateWithoutUserCardInput>
  }

  export type CardUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CardCreateWithoutUsersInput, CardUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CardCreateOrConnectWithoutUsersInput
    upsert?: CardUpsertWithoutUsersInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutUsersInput, CardUpdateWithoutUsersInput>, CardUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAuthenticatorsInput = {
    create?: XOR<UserCreateWithoutAuthenticatorsInput, UserUncheckedCreateWithoutAuthenticatorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthenticatorsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthenticatorsNestedInput = {
    create?: XOR<UserCreateWithoutAuthenticatorsInput, UserUncheckedCreateWithoutAuthenticatorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthenticatorsInput
    upsert?: UserUpsertWithoutAuthenticatorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthenticatorsInput, UserUpdateWithoutAuthenticatorsInput>, UserUncheckedUpdateWithoutAuthenticatorsInput>
  }

  export type UserCreateNestedOneWithoutBonusterInput = {
    create?: XOR<UserCreateWithoutBonusterInput, UserUncheckedCreateWithoutBonusterInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusterInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBonusterNestedInput = {
    create?: XOR<UserCreateWithoutBonusterInput, UserUncheckedCreateWithoutBonusterInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusterInput
    upsert?: UserUpsertWithoutBonusterInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBonusterInput, UserUpdateWithoutBonusterInput>, UserUncheckedUpdateWithoutBonusterInput>
  }

  export type TasksCompletionCreateNestedManyWithoutTaskInput = {
    create?: XOR<TasksCompletionCreateWithoutTaskInput, TasksCompletionUncheckedCreateWithoutTaskInput> | TasksCompletionCreateWithoutTaskInput[] | TasksCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksCompletionCreateOrConnectWithoutTaskInput | TasksCompletionCreateOrConnectWithoutTaskInput[]
    createMany?: TasksCompletionCreateManyTaskInputEnvelope
    connect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
  }

  export type TasksCompletionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TasksCompletionCreateWithoutTaskInput, TasksCompletionUncheckedCreateWithoutTaskInput> | TasksCompletionCreateWithoutTaskInput[] | TasksCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksCompletionCreateOrConnectWithoutTaskInput | TasksCompletionCreateOrConnectWithoutTaskInput[]
    createMany?: TasksCompletionCreateManyTaskInputEnvelope
    connect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
  }

  export type TasksCompletionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TasksCompletionCreateWithoutTaskInput, TasksCompletionUncheckedCreateWithoutTaskInput> | TasksCompletionCreateWithoutTaskInput[] | TasksCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksCompletionCreateOrConnectWithoutTaskInput | TasksCompletionCreateOrConnectWithoutTaskInput[]
    upsert?: TasksCompletionUpsertWithWhereUniqueWithoutTaskInput | TasksCompletionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TasksCompletionCreateManyTaskInputEnvelope
    set?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    disconnect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    delete?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    connect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    update?: TasksCompletionUpdateWithWhereUniqueWithoutTaskInput | TasksCompletionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TasksCompletionUpdateManyWithWhereWithoutTaskInput | TasksCompletionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TasksCompletionScalarWhereInput | TasksCompletionScalarWhereInput[]
  }

  export type TasksCompletionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TasksCompletionCreateWithoutTaskInput, TasksCompletionUncheckedCreateWithoutTaskInput> | TasksCompletionCreateWithoutTaskInput[] | TasksCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksCompletionCreateOrConnectWithoutTaskInput | TasksCompletionCreateOrConnectWithoutTaskInput[]
    upsert?: TasksCompletionUpsertWithWhereUniqueWithoutTaskInput | TasksCompletionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TasksCompletionCreateManyTaskInputEnvelope
    set?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    disconnect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    delete?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    connect?: TasksCompletionWhereUniqueInput | TasksCompletionWhereUniqueInput[]
    update?: TasksCompletionUpdateWithWhereUniqueWithoutTaskInput | TasksCompletionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TasksCompletionUpdateManyWithWhereWithoutTaskInput | TasksCompletionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TasksCompletionScalarWhereInput | TasksCompletionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserTasksInput = {
    create?: XOR<UserCreateWithoutUserTasksInput, UserUncheckedCreateWithoutUserTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTasksInput
    connect?: UserWhereUniqueInput
  }

  export type TasksCreateNestedOneWithoutUserInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput>
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput
    connect?: TasksWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserTasksNestedInput = {
    create?: XOR<UserCreateWithoutUserTasksInput, UserUncheckedCreateWithoutUserTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTasksInput
    upsert?: UserUpsertWithoutUserTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserTasksInput, UserUpdateWithoutUserTasksInput>, UserUncheckedUpdateWithoutUserTasksInput>
  }

  export type TasksUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput>
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput
    upsert?: TasksUpsertWithoutUserInput
    connect?: TasksWhereUniqueInput
    update?: XOR<XOR<TasksUpdateToOneWithWhereWithoutUserInput, TasksUpdateWithoutUserInput>, TasksUncheckedUpdateWithoutUserInput>
  }

  export type YouTubeCompletionCreateNestedManyWithoutTaskInput = {
    create?: XOR<YouTubeCompletionCreateWithoutTaskInput, YouTubeCompletionUncheckedCreateWithoutTaskInput> | YouTubeCompletionCreateWithoutTaskInput[] | YouTubeCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: YouTubeCompletionCreateOrConnectWithoutTaskInput | YouTubeCompletionCreateOrConnectWithoutTaskInput[]
    createMany?: YouTubeCompletionCreateManyTaskInputEnvelope
    connect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
  }

  export type YouTubeCompletionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<YouTubeCompletionCreateWithoutTaskInput, YouTubeCompletionUncheckedCreateWithoutTaskInput> | YouTubeCompletionCreateWithoutTaskInput[] | YouTubeCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: YouTubeCompletionCreateOrConnectWithoutTaskInput | YouTubeCompletionCreateOrConnectWithoutTaskInput[]
    createMany?: YouTubeCompletionCreateManyTaskInputEnvelope
    connect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
  }

  export type YouTubeCompletionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<YouTubeCompletionCreateWithoutTaskInput, YouTubeCompletionUncheckedCreateWithoutTaskInput> | YouTubeCompletionCreateWithoutTaskInput[] | YouTubeCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: YouTubeCompletionCreateOrConnectWithoutTaskInput | YouTubeCompletionCreateOrConnectWithoutTaskInput[]
    upsert?: YouTubeCompletionUpsertWithWhereUniqueWithoutTaskInput | YouTubeCompletionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: YouTubeCompletionCreateManyTaskInputEnvelope
    set?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    disconnect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    delete?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    connect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    update?: YouTubeCompletionUpdateWithWhereUniqueWithoutTaskInput | YouTubeCompletionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: YouTubeCompletionUpdateManyWithWhereWithoutTaskInput | YouTubeCompletionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: YouTubeCompletionScalarWhereInput | YouTubeCompletionScalarWhereInput[]
  }

  export type YouTubeCompletionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<YouTubeCompletionCreateWithoutTaskInput, YouTubeCompletionUncheckedCreateWithoutTaskInput> | YouTubeCompletionCreateWithoutTaskInput[] | YouTubeCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: YouTubeCompletionCreateOrConnectWithoutTaskInput | YouTubeCompletionCreateOrConnectWithoutTaskInput[]
    upsert?: YouTubeCompletionUpsertWithWhereUniqueWithoutTaskInput | YouTubeCompletionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: YouTubeCompletionCreateManyTaskInputEnvelope
    set?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    disconnect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    delete?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    connect?: YouTubeCompletionWhereUniqueInput | YouTubeCompletionWhereUniqueInput[]
    update?: YouTubeCompletionUpdateWithWhereUniqueWithoutTaskInput | YouTubeCompletionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: YouTubeCompletionUpdateManyWithWhereWithoutTaskInput | YouTubeCompletionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: YouTubeCompletionScalarWhereInput | YouTubeCompletionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserYouTubeInput = {
    create?: XOR<UserCreateWithoutUserYouTubeInput, UserUncheckedCreateWithoutUserYouTubeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserYouTubeInput
    connect?: UserWhereUniqueInput
  }

  export type YouTubeCreateNestedOneWithoutUserInput = {
    create?: XOR<YouTubeCreateWithoutUserInput, YouTubeUncheckedCreateWithoutUserInput>
    connectOrCreate?: YouTubeCreateOrConnectWithoutUserInput
    connect?: YouTubeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserYouTubeNestedInput = {
    create?: XOR<UserCreateWithoutUserYouTubeInput, UserUncheckedCreateWithoutUserYouTubeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserYouTubeInput
    upsert?: UserUpsertWithoutUserYouTubeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserYouTubeInput, UserUpdateWithoutUserYouTubeInput>, UserUncheckedUpdateWithoutUserYouTubeInput>
  }

  export type YouTubeUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<YouTubeCreateWithoutUserInput, YouTubeUncheckedCreateWithoutUserInput>
    connectOrCreate?: YouTubeCreateOrConnectWithoutUserInput
    upsert?: YouTubeUpsertWithoutUserInput
    connect?: YouTubeWhereUniqueInput
    update?: XOR<XOR<YouTubeUpdateToOneWithWhereWithoutUserInput, YouTubeUpdateWithoutUserInput>, YouTubeUncheckedUpdateWithoutUserInput>
  }

  export type UserSkinCreateNestedManyWithoutSkinInput = {
    create?: XOR<UserSkinCreateWithoutSkinInput, UserSkinUncheckedCreateWithoutSkinInput> | UserSkinCreateWithoutSkinInput[] | UserSkinUncheckedCreateWithoutSkinInput[]
    connectOrCreate?: UserSkinCreateOrConnectWithoutSkinInput | UserSkinCreateOrConnectWithoutSkinInput[]
    createMany?: UserSkinCreateManySkinInputEnvelope
    connect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
  }

  export type UserSkinUncheckedCreateNestedManyWithoutSkinInput = {
    create?: XOR<UserSkinCreateWithoutSkinInput, UserSkinUncheckedCreateWithoutSkinInput> | UserSkinCreateWithoutSkinInput[] | UserSkinUncheckedCreateWithoutSkinInput[]
    connectOrCreate?: UserSkinCreateOrConnectWithoutSkinInput | UserSkinCreateOrConnectWithoutSkinInput[]
    createMany?: UserSkinCreateManySkinInputEnvelope
    connect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
  }

  export type UserSkinUpdateManyWithoutSkinNestedInput = {
    create?: XOR<UserSkinCreateWithoutSkinInput, UserSkinUncheckedCreateWithoutSkinInput> | UserSkinCreateWithoutSkinInput[] | UserSkinUncheckedCreateWithoutSkinInput[]
    connectOrCreate?: UserSkinCreateOrConnectWithoutSkinInput | UserSkinCreateOrConnectWithoutSkinInput[]
    upsert?: UserSkinUpsertWithWhereUniqueWithoutSkinInput | UserSkinUpsertWithWhereUniqueWithoutSkinInput[]
    createMany?: UserSkinCreateManySkinInputEnvelope
    set?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    disconnect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    delete?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    connect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    update?: UserSkinUpdateWithWhereUniqueWithoutSkinInput | UserSkinUpdateWithWhereUniqueWithoutSkinInput[]
    updateMany?: UserSkinUpdateManyWithWhereWithoutSkinInput | UserSkinUpdateManyWithWhereWithoutSkinInput[]
    deleteMany?: UserSkinScalarWhereInput | UserSkinScalarWhereInput[]
  }

  export type UserSkinUncheckedUpdateManyWithoutSkinNestedInput = {
    create?: XOR<UserSkinCreateWithoutSkinInput, UserSkinUncheckedCreateWithoutSkinInput> | UserSkinCreateWithoutSkinInput[] | UserSkinUncheckedCreateWithoutSkinInput[]
    connectOrCreate?: UserSkinCreateOrConnectWithoutSkinInput | UserSkinCreateOrConnectWithoutSkinInput[]
    upsert?: UserSkinUpsertWithWhereUniqueWithoutSkinInput | UserSkinUpsertWithWhereUniqueWithoutSkinInput[]
    createMany?: UserSkinCreateManySkinInputEnvelope
    set?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    disconnect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    delete?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    connect?: UserSkinWhereUniqueInput | UserSkinWhereUniqueInput[]
    update?: UserSkinUpdateWithWhereUniqueWithoutSkinInput | UserSkinUpdateWithWhereUniqueWithoutSkinInput[]
    updateMany?: UserSkinUpdateManyWithWhereWithoutSkinInput | UserSkinUpdateManyWithWhereWithoutSkinInput[]
    deleteMany?: UserSkinScalarWhereInput | UserSkinScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSkinsInput = {
    create?: XOR<UserCreateWithoutSkinsInput, UserUncheckedCreateWithoutSkinsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkinsInput
    connect?: UserWhereUniqueInput
  }

  export type SkinsCreateNestedOneWithoutUsersInput = {
    create?: XOR<SkinsCreateWithoutUsersInput, SkinsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SkinsCreateOrConnectWithoutUsersInput
    connect?: SkinsWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSkinsNestedInput = {
    create?: XOR<UserCreateWithoutSkinsInput, UserUncheckedCreateWithoutSkinsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkinsInput
    upsert?: UserUpsertWithoutSkinsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSkinsInput, UserUpdateWithoutSkinsInput>, UserUncheckedUpdateWithoutSkinsInput>
  }

  export type SkinsUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SkinsCreateWithoutUsersInput, SkinsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SkinsCreateOrConnectWithoutUsersInput
    upsert?: SkinsUpsertWithoutUsersInput
    connect?: SkinsWhereUniqueInput
    update?: XOR<XOR<SkinsUpdateToOneWithWhereWithoutUsersInput, SkinsUpdateWithoutUsersInput>, SkinsUncheckedUpdateWithoutUsersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserSkinCreateWithoutUserInput = {
    id?: string
    skin: SkinsCreateNestedOneWithoutUsersInput
  }

  export type UserSkinUncheckedCreateWithoutUserInput = {
    id?: string
    skinId: string
  }

  export type UserSkinCreateOrConnectWithoutUserInput = {
    where: UserSkinWhereUniqueInput
    create: XOR<UserSkinCreateWithoutUserInput, UserSkinUncheckedCreateWithoutUserInput>
  }

  export type UserSkinCreateManyUserInputEnvelope = {
    data: UserSkinCreateManyUserInput | UserSkinCreateManyUserInput[]
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type AuthenticatorCreateWithoutUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUncheckedCreateWithoutUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorCreateOrConnectWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    create: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput>
  }

  export type AuthenticatorCreateManyUserInputEnvelope = {
    data: AuthenticatorCreateManyUserInput | AuthenticatorCreateManyUserInput[]
  }

  export type UserCardCreateWithoutUserInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    category: string
    discription?: string | null
    card: CardCreateNestedOneWithoutUsersInput
  }

  export type UserCardUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    cardId: string
    category: string
    discription?: string | null
  }

  export type UserCardCreateOrConnectWithoutUserInput = {
    where: UserCardWhereUniqueInput
    create: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput>
  }

  export type UserCardCreateManyUserInputEnvelope = {
    data: UserCardCreateManyUserInput | UserCardCreateManyUserInput[]
  }

  export type BonusterCreateWithoutUserInput = {
    id?: string
    energy: number
    energyCost: number
    energylevel: number
    multiClickLevel?: number
    multiClickCost?: number
  }

  export type BonusterUncheckedCreateWithoutUserInput = {
    id?: string
    energy: number
    energyCost: number
    energylevel: number
    multiClickLevel?: number
    multiClickCost?: number
  }

  export type BonusterCreateOrConnectWithoutUserInput = {
    where: BonusterWhereUniqueInput
    create: XOR<BonusterCreateWithoutUserInput, BonusterUncheckedCreateWithoutUserInput>
  }

  export type BonusterCreateManyUserInputEnvelope = {
    data: BonusterCreateManyUserInput | BonusterCreateManyUserInput[]
  }

  export type DailyRewardCreateWithoutUserInput = {
    id?: string
    day: number
    coins: number
    createdAt?: Date | string
  }

  export type DailyRewardUncheckedCreateWithoutUserInput = {
    id?: string
    day: number
    coins: number
    createdAt?: Date | string
  }

  export type DailyRewardCreateOrConnectWithoutUserInput = {
    where: DailyRewardWhereUniqueInput
    create: XOR<DailyRewardCreateWithoutUserInput, DailyRewardUncheckedCreateWithoutUserInput>
  }

  export type DailyRewardCreateManyUserInputEnvelope = {
    data: DailyRewardCreateManyUserInput | DailyRewardCreateManyUserInput[]
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredByInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredByInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserCreateManyReferredByInputEnvelope = {
    data: UserCreateManyReferredByInput | UserCreateManyReferredByInput[]
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    milestone: AchievementMilestoneCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    milestoneId: string
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
  }

  export type TasksCompletionCreateWithoutUserInput = {
    id?: string
    points: number
    task: TasksCreateNestedOneWithoutUserInput
  }

  export type TasksCompletionUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    points: number
  }

  export type TasksCompletionCreateOrConnectWithoutUserInput = {
    where: TasksCompletionWhereUniqueInput
    create: XOR<TasksCompletionCreateWithoutUserInput, TasksCompletionUncheckedCreateWithoutUserInput>
  }

  export type TasksCompletionCreateManyUserInputEnvelope = {
    data: TasksCompletionCreateManyUserInput | TasksCompletionCreateManyUserInput[]
  }

  export type YouTubeCompletionCreateWithoutUserInput = {
    id?: string
    points: number
    task: YouTubeCreateNestedOneWithoutUserInput
  }

  export type YouTubeCompletionUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    points: number
  }

  export type YouTubeCompletionCreateOrConnectWithoutUserInput = {
    where: YouTubeCompletionWhereUniqueInput
    create: XOR<YouTubeCompletionCreateWithoutUserInput, YouTubeCompletionUncheckedCreateWithoutUserInput>
  }

  export type YouTubeCompletionCreateManyUserInputEnvelope = {
    data: YouTubeCompletionCreateManyUserInput | YouTubeCompletionCreateManyUserInput[]
  }

  export type UserSkinUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSkinWhereUniqueInput
    update: XOR<UserSkinUpdateWithoutUserInput, UserSkinUncheckedUpdateWithoutUserInput>
    create: XOR<UserSkinCreateWithoutUserInput, UserSkinUncheckedCreateWithoutUserInput>
  }

  export type UserSkinUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSkinWhereUniqueInput
    data: XOR<UserSkinUpdateWithoutUserInput, UserSkinUncheckedUpdateWithoutUserInput>
  }

  export type UserSkinUpdateManyWithWhereWithoutUserInput = {
    where: UserSkinScalarWhereInput
    data: XOR<UserSkinUpdateManyMutationInput, UserSkinUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSkinScalarWhereInput = {
    AND?: UserSkinScalarWhereInput | UserSkinScalarWhereInput[]
    OR?: UserSkinScalarWhereInput[]
    NOT?: UserSkinScalarWhereInput | UserSkinScalarWhereInput[]
    id?: StringFilter<"UserSkin"> | string
    userId?: StringFilter<"UserSkin"> | string
    skinId?: StringFilter<"UserSkin"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuthenticatorUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    update: XOR<AuthenticatorUpdateWithoutUserInput, AuthenticatorUncheckedUpdateWithoutUserInput>
    create: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput>
  }

  export type AuthenticatorUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    data: XOR<AuthenticatorUpdateWithoutUserInput, AuthenticatorUncheckedUpdateWithoutUserInput>
  }

  export type AuthenticatorUpdateManyWithWhereWithoutUserInput = {
    where: AuthenticatorScalarWhereInput
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthenticatorScalarWhereInput = {
    AND?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
    OR?: AuthenticatorScalarWhereInput[]
    NOT?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
    credentialID?: StringFilter<"Authenticator"> | string
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
  }

  export type UserCardUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCardWhereUniqueInput
    update: XOR<UserCardUpdateWithoutUserInput, UserCardUncheckedUpdateWithoutUserInput>
    create: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput>
  }

  export type UserCardUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCardWhereUniqueInput
    data: XOR<UserCardUpdateWithoutUserInput, UserCardUncheckedUpdateWithoutUserInput>
  }

  export type UserCardUpdateManyWithWhereWithoutUserInput = {
    where: UserCardScalarWhereInput
    data: XOR<UserCardUpdateManyMutationInput, UserCardUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCardScalarWhereInput = {
    AND?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
    OR?: UserCardScalarWhereInput[]
    NOT?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
    id?: StringFilter<"UserCard"> | string
    title?: StringFilter<"UserCard"> | string
    image?: StringFilter<"UserCard"> | string
    baseCost?: FloatFilter<"UserCard"> | number
    basePPH?: FloatFilter<"UserCard"> | number
    baseLevel?: IntFilter<"UserCard"> | number
    userId?: StringFilter<"UserCard"> | string
    cardId?: StringFilter<"UserCard"> | string
    category?: StringFilter<"UserCard"> | string
    discription?: StringNullableFilter<"UserCard"> | string | null
  }

  export type BonusterUpsertWithWhereUniqueWithoutUserInput = {
    where: BonusterWhereUniqueInput
    update: XOR<BonusterUpdateWithoutUserInput, BonusterUncheckedUpdateWithoutUserInput>
    create: XOR<BonusterCreateWithoutUserInput, BonusterUncheckedCreateWithoutUserInput>
  }

  export type BonusterUpdateWithWhereUniqueWithoutUserInput = {
    where: BonusterWhereUniqueInput
    data: XOR<BonusterUpdateWithoutUserInput, BonusterUncheckedUpdateWithoutUserInput>
  }

  export type BonusterUpdateManyWithWhereWithoutUserInput = {
    where: BonusterScalarWhereInput
    data: XOR<BonusterUpdateManyMutationInput, BonusterUncheckedUpdateManyWithoutUserInput>
  }

  export type BonusterScalarWhereInput = {
    AND?: BonusterScalarWhereInput | BonusterScalarWhereInput[]
    OR?: BonusterScalarWhereInput[]
    NOT?: BonusterScalarWhereInput | BonusterScalarWhereInput[]
    id?: StringFilter<"Bonuster"> | string
    chatId?: StringFilter<"Bonuster"> | string
    energy?: IntFilter<"Bonuster"> | number
    energyCost?: IntFilter<"Bonuster"> | number
    energylevel?: IntFilter<"Bonuster"> | number
    multiClickLevel?: IntFilter<"Bonuster"> | number
    multiClickCost?: IntFilter<"Bonuster"> | number
  }

  export type DailyRewardUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyRewardWhereUniqueInput
    update: XOR<DailyRewardUpdateWithoutUserInput, DailyRewardUncheckedUpdateWithoutUserInput>
    create: XOR<DailyRewardCreateWithoutUserInput, DailyRewardUncheckedCreateWithoutUserInput>
  }

  export type DailyRewardUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyRewardWhereUniqueInput
    data: XOR<DailyRewardUpdateWithoutUserInput, DailyRewardUncheckedUpdateWithoutUserInput>
  }

  export type DailyRewardUpdateManyWithWhereWithoutUserInput = {
    where: DailyRewardScalarWhereInput
    data: XOR<DailyRewardUpdateManyMutationInput, DailyRewardUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyRewardScalarWhereInput = {
    AND?: DailyRewardScalarWhereInput | DailyRewardScalarWhereInput[]
    OR?: DailyRewardScalarWhereInput[]
    NOT?: DailyRewardScalarWhereInput | DailyRewardScalarWhereInput[]
    id?: StringFilter<"DailyReward"> | string
    userId?: StringFilter<"DailyReward"> | string
    day?: IntFilter<"DailyReward"> | number
    coins?: IntFilter<"DailyReward"> | number
    createdAt?: DateTimeFilter<"DailyReward"> | Date | string
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserUpdateManyWithWhereWithoutReferredByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferredByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    chatId?: StringFilter<"User"> | string
    taps?: IntFilter<"User"> | number
    points?: IntFilter<"User"> | number
    profit?: IntFilter<"User"> | number
    lastProfitDate?: IntNullableFilter<"User"> | number | null
    rechargeLimit?: IntFilter<"User"> | number
    pointPerTap?: IntFilter<"User"> | number
    profitPerHour?: IntFilter<"User"> | number
    refillRate?: IntFilter<"User"> | number
    bonus?: IntFilter<"User"> | number
    active?: BoolFilter<"User"> | boolean
    skin?: StringFilter<"User"> | string
    lastLogin?: DateTimeFilter<"User"> | Date | string
    league?: StringNullableFilter<"User"> | string | null
    referralCount?: IntFilter<"User"> | number
    loginStreak?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: StringNullableFilter<"User"> | string | null
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    milestoneId?: StringFilter<"UserAchievement"> | string
  }

  export type TasksCompletionUpsertWithWhereUniqueWithoutUserInput = {
    where: TasksCompletionWhereUniqueInput
    update: XOR<TasksCompletionUpdateWithoutUserInput, TasksCompletionUncheckedUpdateWithoutUserInput>
    create: XOR<TasksCompletionCreateWithoutUserInput, TasksCompletionUncheckedCreateWithoutUserInput>
  }

  export type TasksCompletionUpdateWithWhereUniqueWithoutUserInput = {
    where: TasksCompletionWhereUniqueInput
    data: XOR<TasksCompletionUpdateWithoutUserInput, TasksCompletionUncheckedUpdateWithoutUserInput>
  }

  export type TasksCompletionUpdateManyWithWhereWithoutUserInput = {
    where: TasksCompletionScalarWhereInput
    data: XOR<TasksCompletionUpdateManyMutationInput, TasksCompletionUncheckedUpdateManyWithoutUserInput>
  }

  export type TasksCompletionScalarWhereInput = {
    AND?: TasksCompletionScalarWhereInput | TasksCompletionScalarWhereInput[]
    OR?: TasksCompletionScalarWhereInput[]
    NOT?: TasksCompletionScalarWhereInput | TasksCompletionScalarWhereInput[]
    id?: StringFilter<"TasksCompletion"> | string
    taskId?: StringFilter<"TasksCompletion"> | string
    userId?: StringFilter<"TasksCompletion"> | string
    points?: IntFilter<"TasksCompletion"> | number
  }

  export type YouTubeCompletionUpsertWithWhereUniqueWithoutUserInput = {
    where: YouTubeCompletionWhereUniqueInput
    update: XOR<YouTubeCompletionUpdateWithoutUserInput, YouTubeCompletionUncheckedUpdateWithoutUserInput>
    create: XOR<YouTubeCompletionCreateWithoutUserInput, YouTubeCompletionUncheckedCreateWithoutUserInput>
  }

  export type YouTubeCompletionUpdateWithWhereUniqueWithoutUserInput = {
    where: YouTubeCompletionWhereUniqueInput
    data: XOR<YouTubeCompletionUpdateWithoutUserInput, YouTubeCompletionUncheckedUpdateWithoutUserInput>
  }

  export type YouTubeCompletionUpdateManyWithWhereWithoutUserInput = {
    where: YouTubeCompletionScalarWhereInput
    data: XOR<YouTubeCompletionUpdateManyMutationInput, YouTubeCompletionUncheckedUpdateManyWithoutUserInput>
  }

  export type YouTubeCompletionScalarWhereInput = {
    AND?: YouTubeCompletionScalarWhereInput | YouTubeCompletionScalarWhereInput[]
    OR?: YouTubeCompletionScalarWhereInput[]
    NOT?: YouTubeCompletionScalarWhereInput | YouTubeCompletionScalarWhereInput[]
    id?: StringFilter<"YouTubeCompletion"> | string
    taskId?: StringFilter<"YouTubeCompletion"> | string
    userId?: StringFilter<"YouTubeCompletion"> | string
    points?: IntFilter<"YouTubeCompletion"> | number
  }

  export type AchievementMilestoneCreateWithoutCategoryInput = {
    id?: string
    name: string
    icon: string
    unlocked?: boolean
    userAchievements?: UserAchievementCreateNestedManyWithoutMilestoneInput
  }

  export type AchievementMilestoneUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    icon: string
    unlocked?: boolean
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type AchievementMilestoneCreateOrConnectWithoutCategoryInput = {
    where: AchievementMilestoneWhereUniqueInput
    create: XOR<AchievementMilestoneCreateWithoutCategoryInput, AchievementMilestoneUncheckedCreateWithoutCategoryInput>
  }

  export type AchievementMilestoneCreateManyCategoryInputEnvelope = {
    data: AchievementMilestoneCreateManyCategoryInput | AchievementMilestoneCreateManyCategoryInput[]
  }

  export type AchievementMilestoneUpsertWithWhereUniqueWithoutCategoryInput = {
    where: AchievementMilestoneWhereUniqueInput
    update: XOR<AchievementMilestoneUpdateWithoutCategoryInput, AchievementMilestoneUncheckedUpdateWithoutCategoryInput>
    create: XOR<AchievementMilestoneCreateWithoutCategoryInput, AchievementMilestoneUncheckedCreateWithoutCategoryInput>
  }

  export type AchievementMilestoneUpdateWithWhereUniqueWithoutCategoryInput = {
    where: AchievementMilestoneWhereUniqueInput
    data: XOR<AchievementMilestoneUpdateWithoutCategoryInput, AchievementMilestoneUncheckedUpdateWithoutCategoryInput>
  }

  export type AchievementMilestoneUpdateManyWithWhereWithoutCategoryInput = {
    where: AchievementMilestoneScalarWhereInput
    data: XOR<AchievementMilestoneUpdateManyMutationInput, AchievementMilestoneUncheckedUpdateManyWithoutCategoryInput>
  }

  export type AchievementMilestoneScalarWhereInput = {
    AND?: AchievementMilestoneScalarWhereInput | AchievementMilestoneScalarWhereInput[]
    OR?: AchievementMilestoneScalarWhereInput[]
    NOT?: AchievementMilestoneScalarWhereInput | AchievementMilestoneScalarWhereInput[]
    id?: StringFilter<"AchievementMilestone"> | string
    categoryId?: StringFilter<"AchievementMilestone"> | string
    name?: StringFilter<"AchievementMilestone"> | string
    icon?: StringFilter<"AchievementMilestone"> | string
    unlocked?: BoolFilter<"AchievementMilestone"> | boolean
  }

  export type AchievementCategoryCreateWithoutMilestonesInput = {
    id?: string
    name: string
  }

  export type AchievementCategoryUncheckedCreateWithoutMilestonesInput = {
    id?: string
    name: string
  }

  export type AchievementCategoryCreateOrConnectWithoutMilestonesInput = {
    where: AchievementCategoryWhereUniqueInput
    create: XOR<AchievementCategoryCreateWithoutMilestonesInput, AchievementCategoryUncheckedCreateWithoutMilestonesInput>
  }

  export type UserAchievementCreateWithoutMilestoneInput = {
    id?: string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutMilestoneInput = {
    id?: string
    userId: string
  }

  export type UserAchievementCreateOrConnectWithoutMilestoneInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutMilestoneInput, UserAchievementUncheckedCreateWithoutMilestoneInput>
  }

  export type UserAchievementCreateManyMilestoneInputEnvelope = {
    data: UserAchievementCreateManyMilestoneInput | UserAchievementCreateManyMilestoneInput[]
  }

  export type AchievementCategoryUpsertWithoutMilestonesInput = {
    update: XOR<AchievementCategoryUpdateWithoutMilestonesInput, AchievementCategoryUncheckedUpdateWithoutMilestonesInput>
    create: XOR<AchievementCategoryCreateWithoutMilestonesInput, AchievementCategoryUncheckedCreateWithoutMilestonesInput>
    where?: AchievementCategoryWhereInput
  }

  export type AchievementCategoryUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: AchievementCategoryWhereInput
    data: XOR<AchievementCategoryUpdateWithoutMilestonesInput, AchievementCategoryUncheckedUpdateWithoutMilestonesInput>
  }

  export type AchievementCategoryUpdateWithoutMilestonesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AchievementCategoryUncheckedUpdateWithoutMilestonesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutMilestoneInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutMilestoneInput, UserAchievementUncheckedUpdateWithoutMilestoneInput>
    create: XOR<UserAchievementCreateWithoutMilestoneInput, UserAchievementUncheckedCreateWithoutMilestoneInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutMilestoneInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutMilestoneInput, UserAchievementUncheckedUpdateWithoutMilestoneInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutMilestoneInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutMilestoneInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementMilestoneCreateWithoutUserAchievementsInput = {
    id?: string
    name: string
    icon: string
    unlocked?: boolean
    category: AchievementCategoryCreateNestedOneWithoutMilestonesInput
  }

  export type AchievementMilestoneUncheckedCreateWithoutUserAchievementsInput = {
    id?: string
    categoryId: string
    name: string
    icon: string
    unlocked?: boolean
  }

  export type AchievementMilestoneCreateOrConnectWithoutUserAchievementsInput = {
    where: AchievementMilestoneWhereUniqueInput
    create: XOR<AchievementMilestoneCreateWithoutUserAchievementsInput, AchievementMilestoneUncheckedCreateWithoutUserAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementMilestoneUpsertWithoutUserAchievementsInput = {
    update: XOR<AchievementMilestoneUpdateWithoutUserAchievementsInput, AchievementMilestoneUncheckedUpdateWithoutUserAchievementsInput>
    create: XOR<AchievementMilestoneCreateWithoutUserAchievementsInput, AchievementMilestoneUncheckedCreateWithoutUserAchievementsInput>
    where?: AchievementMilestoneWhereInput
  }

  export type AchievementMilestoneUpdateToOneWithWhereWithoutUserAchievementsInput = {
    where?: AchievementMilestoneWhereInput
    data: XOR<AchievementMilestoneUpdateWithoutUserAchievementsInput, AchievementMilestoneUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type AchievementMilestoneUpdateWithoutUserAchievementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    category?: AchievementCategoryUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type AchievementMilestoneUncheckedUpdateWithoutUserAchievementsInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutDailyRewardsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyRewardsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyRewardsInput, UserUncheckedCreateWithoutDailyRewardsInput>
  }

  export type UserUpsertWithoutDailyRewardsInput = {
    update: XOR<UserUpdateWithoutDailyRewardsInput, UserUncheckedUpdateWithoutDailyRewardsInput>
    create: XOR<UserCreateWithoutDailyRewardsInput, UserUncheckedCreateWithoutDailyRewardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyRewardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyRewardsInput, UserUncheckedUpdateWithoutDailyRewardsInput>
  }

  export type UserUpdateWithoutDailyRewardsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyRewardsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCardCreateWithoutCardInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    category: string
    discription?: string | null
    user: UserCreateNestedOneWithoutUserCardInput
  }

  export type UserCardUncheckedCreateWithoutCardInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    userId: string
    category: string
    discription?: string | null
  }

  export type UserCardCreateOrConnectWithoutCardInput = {
    where: UserCardWhereUniqueInput
    create: XOR<UserCardCreateWithoutCardInput, UserCardUncheckedCreateWithoutCardInput>
  }

  export type UserCardCreateManyCardInputEnvelope = {
    data: UserCardCreateManyCardInput | UserCardCreateManyCardInput[]
  }

  export type UserCardUpsertWithWhereUniqueWithoutCardInput = {
    where: UserCardWhereUniqueInput
    update: XOR<UserCardUpdateWithoutCardInput, UserCardUncheckedUpdateWithoutCardInput>
    create: XOR<UserCardCreateWithoutCardInput, UserCardUncheckedCreateWithoutCardInput>
  }

  export type UserCardUpdateWithWhereUniqueWithoutCardInput = {
    where: UserCardWhereUniqueInput
    data: XOR<UserCardUpdateWithoutCardInput, UserCardUncheckedUpdateWithoutCardInput>
  }

  export type UserCardUpdateManyWithWhereWithoutCardInput = {
    where: UserCardScalarWhereInput
    data: XOR<UserCardUpdateManyMutationInput, UserCardUncheckedUpdateManyWithoutCardInput>
  }

  export type UserCreateWithoutUserCardInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCardInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCardInput, UserUncheckedCreateWithoutUserCardInput>
  }

  export type CardCreateWithoutUsersInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    category: string
    discription?: string | null
    requiredCardId?: string | null
    requiredCardLevel?: number | null
    requiredCardTitle?: string | null
  }

  export type CardUncheckedCreateWithoutUsersInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    category: string
    discription?: string | null
    requiredCardId?: string | null
    requiredCardLevel?: number | null
    requiredCardTitle?: string | null
  }

  export type CardCreateOrConnectWithoutUsersInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutUsersInput, CardUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutUserCardInput = {
    update: XOR<UserUpdateWithoutUserCardInput, UserUncheckedUpdateWithoutUserCardInput>
    create: XOR<UserCreateWithoutUserCardInput, UserUncheckedCreateWithoutUserCardInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCardInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCardInput, UserUncheckedUpdateWithoutUserCardInput>
  }

  export type UserUpdateWithoutUserCardInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCardInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CardUpsertWithoutUsersInput = {
    update: XOR<CardUpdateWithoutUsersInput, CardUncheckedUpdateWithoutUsersInput>
    create: XOR<CardCreateWithoutUsersInput, CardUncheckedCreateWithoutUsersInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutUsersInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutUsersInput, CardUncheckedUpdateWithoutUsersInput>
  }

  export type CardUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardLevel?: NullableIntFieldUpdateOperationsInput | number | null
    requiredCardTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardUncheckedUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredCardLevel?: NullableIntFieldUpdateOperationsInput | number | null
    requiredCardTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuthenticatorsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthenticatorsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthenticatorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthenticatorsInput, UserUncheckedCreateWithoutAuthenticatorsInput>
  }

  export type UserUpsertWithoutAuthenticatorsInput = {
    update: XOR<UserUpdateWithoutAuthenticatorsInput, UserUncheckedUpdateWithoutAuthenticatorsInput>
    create: XOR<UserCreateWithoutAuthenticatorsInput, UserUncheckedCreateWithoutAuthenticatorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthenticatorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthenticatorsInput, UserUncheckedUpdateWithoutAuthenticatorsInput>
  }

  export type UserUpdateWithoutAuthenticatorsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthenticatorsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBonusterInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBonusterInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBonusterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBonusterInput, UserUncheckedCreateWithoutBonusterInput>
  }

  export type UserUpsertWithoutBonusterInput = {
    update: XOR<UserUpdateWithoutBonusterInput, UserUncheckedUpdateWithoutBonusterInput>
    create: XOR<UserCreateWithoutBonusterInput, UserUncheckedCreateWithoutBonusterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBonusterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBonusterInput, UserUncheckedUpdateWithoutBonusterInput>
  }

  export type UserUpdateWithoutBonusterInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBonusterInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TasksCompletionCreateWithoutTaskInput = {
    id?: string
    points: number
    user: UserCreateNestedOneWithoutUserTasksInput
  }

  export type TasksCompletionUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    points: number
  }

  export type TasksCompletionCreateOrConnectWithoutTaskInput = {
    where: TasksCompletionWhereUniqueInput
    create: XOR<TasksCompletionCreateWithoutTaskInput, TasksCompletionUncheckedCreateWithoutTaskInput>
  }

  export type TasksCompletionCreateManyTaskInputEnvelope = {
    data: TasksCompletionCreateManyTaskInput | TasksCompletionCreateManyTaskInput[]
  }

  export type TasksCompletionUpsertWithWhereUniqueWithoutTaskInput = {
    where: TasksCompletionWhereUniqueInput
    update: XOR<TasksCompletionUpdateWithoutTaskInput, TasksCompletionUncheckedUpdateWithoutTaskInput>
    create: XOR<TasksCompletionCreateWithoutTaskInput, TasksCompletionUncheckedCreateWithoutTaskInput>
  }

  export type TasksCompletionUpdateWithWhereUniqueWithoutTaskInput = {
    where: TasksCompletionWhereUniqueInput
    data: XOR<TasksCompletionUpdateWithoutTaskInput, TasksCompletionUncheckedUpdateWithoutTaskInput>
  }

  export type TasksCompletionUpdateManyWithWhereWithoutTaskInput = {
    where: TasksCompletionScalarWhereInput
    data: XOR<TasksCompletionUpdateManyMutationInput, TasksCompletionUncheckedUpdateManyWithoutTaskInput>
  }

  export type UserCreateWithoutUserTasksInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserTasksInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserTasksInput, UserUncheckedCreateWithoutUserTasksInput>
  }

  export type TasksCreateWithoutUserInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
  }

  export type TasksUncheckedCreateWithoutUserInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
  }

  export type TasksCreateOrConnectWithoutUserInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput>
  }

  export type UserUpsertWithoutUserTasksInput = {
    update: XOR<UserUpdateWithoutUserTasksInput, UserUncheckedUpdateWithoutUserTasksInput>
    create: XOR<UserCreateWithoutUserTasksInput, UserUncheckedCreateWithoutUserTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserTasksInput, UserUncheckedUpdateWithoutUserTasksInput>
  }

  export type UserUpdateWithoutUserTasksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserTasksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TasksUpsertWithoutUserInput = {
    update: XOR<TasksUpdateWithoutUserInput, TasksUncheckedUpdateWithoutUserInput>
    create: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput>
    where?: TasksWhereInput
  }

  export type TasksUpdateToOneWithWhereWithoutUserInput = {
    where?: TasksWhereInput
    data: XOR<TasksUpdateWithoutUserInput, TasksUncheckedUpdateWithoutUserInput>
  }

  export type TasksUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type TasksUncheckedUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type YouTubeCompletionCreateWithoutTaskInput = {
    id?: string
    points: number
    user: UserCreateNestedOneWithoutUserYouTubeInput
  }

  export type YouTubeCompletionUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    points: number
  }

  export type YouTubeCompletionCreateOrConnectWithoutTaskInput = {
    where: YouTubeCompletionWhereUniqueInput
    create: XOR<YouTubeCompletionCreateWithoutTaskInput, YouTubeCompletionUncheckedCreateWithoutTaskInput>
  }

  export type YouTubeCompletionCreateManyTaskInputEnvelope = {
    data: YouTubeCompletionCreateManyTaskInput | YouTubeCompletionCreateManyTaskInput[]
  }

  export type YouTubeCompletionUpsertWithWhereUniqueWithoutTaskInput = {
    where: YouTubeCompletionWhereUniqueInput
    update: XOR<YouTubeCompletionUpdateWithoutTaskInput, YouTubeCompletionUncheckedUpdateWithoutTaskInput>
    create: XOR<YouTubeCompletionCreateWithoutTaskInput, YouTubeCompletionUncheckedCreateWithoutTaskInput>
  }

  export type YouTubeCompletionUpdateWithWhereUniqueWithoutTaskInput = {
    where: YouTubeCompletionWhereUniqueInput
    data: XOR<YouTubeCompletionUpdateWithoutTaskInput, YouTubeCompletionUncheckedUpdateWithoutTaskInput>
  }

  export type YouTubeCompletionUpdateManyWithWhereWithoutTaskInput = {
    where: YouTubeCompletionScalarWhereInput
    data: XOR<YouTubeCompletionUpdateManyMutationInput, YouTubeCompletionUncheckedUpdateManyWithoutTaskInput>
  }

  export type UserCreateWithoutUserYouTubeInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skins?: UserSkinCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserYouTubeInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    skins?: UserSkinUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserYouTubeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserYouTubeInput, UserUncheckedCreateWithoutUserYouTubeInput>
  }

  export type YouTubeCreateWithoutUserInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
  }

  export type YouTubeUncheckedCreateWithoutUserInput = {
    id?: string
    category: string
    name: string
    points: number
    link: string
    icon: string
  }

  export type YouTubeCreateOrConnectWithoutUserInput = {
    where: YouTubeWhereUniqueInput
    create: XOR<YouTubeCreateWithoutUserInput, YouTubeUncheckedCreateWithoutUserInput>
  }

  export type UserUpsertWithoutUserYouTubeInput = {
    update: XOR<UserUpdateWithoutUserYouTubeInput, UserUncheckedUpdateWithoutUserYouTubeInput>
    create: XOR<UserCreateWithoutUserYouTubeInput, UserUncheckedCreateWithoutUserYouTubeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserYouTubeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserYouTubeInput, UserUncheckedUpdateWithoutUserYouTubeInput>
  }

  export type UserUpdateWithoutUserYouTubeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserYouTubeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YouTubeUpsertWithoutUserInput = {
    update: XOR<YouTubeUpdateWithoutUserInput, YouTubeUncheckedUpdateWithoutUserInput>
    create: XOR<YouTubeCreateWithoutUserInput, YouTubeUncheckedCreateWithoutUserInput>
    where?: YouTubeWhereInput
  }

  export type YouTubeUpdateToOneWithWhereWithoutUserInput = {
    where?: YouTubeWhereInput
    data: XOR<YouTubeUpdateWithoutUserInput, YouTubeUncheckedUpdateWithoutUserInput>
  }

  export type YouTubeUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type YouTubeUncheckedUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkinCreateWithoutSkinInput = {
    id?: string
    user: UserCreateNestedOneWithoutSkinsInput
  }

  export type UserSkinUncheckedCreateWithoutSkinInput = {
    id?: string
    userId: string
  }

  export type UserSkinCreateOrConnectWithoutSkinInput = {
    where: UserSkinWhereUniqueInput
    create: XOR<UserSkinCreateWithoutSkinInput, UserSkinUncheckedCreateWithoutSkinInput>
  }

  export type UserSkinCreateManySkinInputEnvelope = {
    data: UserSkinCreateManySkinInput | UserSkinCreateManySkinInput[]
  }

  export type UserSkinUpsertWithWhereUniqueWithoutSkinInput = {
    where: UserSkinWhereUniqueInput
    update: XOR<UserSkinUpdateWithoutSkinInput, UserSkinUncheckedUpdateWithoutSkinInput>
    create: XOR<UserSkinCreateWithoutSkinInput, UserSkinUncheckedCreateWithoutSkinInput>
  }

  export type UserSkinUpdateWithWhereUniqueWithoutSkinInput = {
    where: UserSkinWhereUniqueInput
    data: XOR<UserSkinUpdateWithoutSkinInput, UserSkinUncheckedUpdateWithoutSkinInput>
  }

  export type UserSkinUpdateManyWithWhereWithoutSkinInput = {
    where: UserSkinScalarWhereInput
    data: XOR<UserSkinUpdateManyMutationInput, UserSkinUncheckedUpdateManyWithoutSkinInput>
  }

  export type UserCreateWithoutSkinsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorCreateNestedManyWithoutUserInput
    userCard?: UserCardCreateNestedManyWithoutUserInput
    Bonuster?: BonusterCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSkinsInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    authenticators?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
    userCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    Bonuster?: BonusterUncheckedCreateNestedManyWithoutUserInput
    dailyRewards?: DailyRewardUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userTasks?: TasksCompletionUncheckedCreateNestedManyWithoutUserInput
    userYouTube?: YouTubeCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSkinsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSkinsInput, UserUncheckedCreateWithoutSkinsInput>
  }

  export type SkinsCreateWithoutUsersInput = {
    id?: string
    name: string
    image?: string
    cost: number
    featured?: boolean
    league?: string
  }

  export type SkinsUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    image?: string
    cost: number
    featured?: boolean
    league?: string
  }

  export type SkinsCreateOrConnectWithoutUsersInput = {
    where: SkinsWhereUniqueInput
    create: XOR<SkinsCreateWithoutUsersInput, SkinsUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutSkinsInput = {
    update: XOR<UserUpdateWithoutSkinsInput, UserUncheckedUpdateWithoutSkinsInput>
    create: XOR<UserCreateWithoutSkinsInput, UserUncheckedCreateWithoutSkinsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSkinsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSkinsInput, UserUncheckedUpdateWithoutSkinsInput>
  }

  export type UserUpdateWithoutSkinsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSkinsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SkinsUpsertWithoutUsersInput = {
    update: XOR<SkinsUpdateWithoutUsersInput, SkinsUncheckedUpdateWithoutUsersInput>
    create: XOR<SkinsCreateWithoutUsersInput, SkinsUncheckedCreateWithoutUsersInput>
    where?: SkinsWhereInput
  }

  export type SkinsUpdateToOneWithWhereWithoutUsersInput = {
    where?: SkinsWhereInput
    data: XOR<SkinsUpdateWithoutUsersInput, SkinsUncheckedUpdateWithoutUsersInput>
  }

  export type SkinsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    league?: StringFieldUpdateOperationsInput | string
  }

  export type SkinsUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    league?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkinCreateManyUserInput = {
    id?: string
    skinId: string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthenticatorCreateManyUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type UserCardCreateManyUserInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    cardId: string
    category: string
    discription?: string | null
  }

  export type BonusterCreateManyUserInput = {
    id?: string
    energy: number
    energyCost: number
    energylevel: number
    multiClickLevel?: number
    multiClickCost?: number
  }

  export type DailyRewardCreateManyUserInput = {
    id?: string
    day: number
    coins: number
    createdAt?: Date | string
  }

  export type UserCreateManyReferredByInput = {
    id?: string
    name?: string | null
    chatId: string
    taps?: number
    points?: number
    profit?: number
    lastProfitDate?: number | null
    rechargeLimit?: number
    pointPerTap?: number
    profitPerHour?: number
    refillRate?: number
    bonus?: number
    active?: boolean
    skin?: string
    lastLogin?: Date | string
    league?: string | null
    referralCount?: number
    loginStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    milestoneId: string
  }

  export type TasksCompletionCreateManyUserInput = {
    id?: string
    taskId: string
    points: number
  }

  export type YouTubeCompletionCreateManyUserInput = {
    id?: string
    taskId: string
    points: number
  }

  export type UserSkinUpdateWithoutUserInput = {
    skin?: SkinsUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserSkinUncheckedUpdateWithoutUserInput = {
    skinId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkinUncheckedUpdateManyWithoutUserInput = {
    skinId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthenticatorUpdateWithoutUserInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateWithoutUserInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateManyWithoutUserInput = {
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    card?: CardUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserCardUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    cardId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardUncheckedUpdateManyWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    cardId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BonusterUpdateWithoutUserInput = {
    energy?: IntFieldUpdateOperationsInput | number
    energyCost?: IntFieldUpdateOperationsInput | number
    energylevel?: IntFieldUpdateOperationsInput | number
    multiClickLevel?: IntFieldUpdateOperationsInput | number
    multiClickCost?: IntFieldUpdateOperationsInput | number
  }

  export type BonusterUncheckedUpdateWithoutUserInput = {
    energy?: IntFieldUpdateOperationsInput | number
    energyCost?: IntFieldUpdateOperationsInput | number
    energylevel?: IntFieldUpdateOperationsInput | number
    multiClickLevel?: IntFieldUpdateOperationsInput | number
    multiClickCost?: IntFieldUpdateOperationsInput | number
  }

  export type BonusterUncheckedUpdateManyWithoutUserInput = {
    energy?: IntFieldUpdateOperationsInput | number
    energyCost?: IntFieldUpdateOperationsInput | number
    energylevel?: IntFieldUpdateOperationsInput | number
    multiClickLevel?: IntFieldUpdateOperationsInput | number
    multiClickCost?: IntFieldUpdateOperationsInput | number
  }

  export type DailyRewardUpdateWithoutUserInput = {
    day?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRewardUncheckedUpdateWithoutUserInput = {
    day?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRewardUncheckedUpdateManyWithoutUserInput = {
    day?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutReferredByInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUpdateManyWithoutUserNestedInput
    userCard?: UserCardUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUpdateManyWithoutUserNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skins?: UserSkinUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    authenticators?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
    userCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    Bonuster?: BonusterUncheckedUpdateManyWithoutUserNestedInput
    dailyRewards?: DailyRewardUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userTasks?: TasksCompletionUncheckedUpdateManyWithoutUserNestedInput
    userYouTube?: YouTubeCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferredByInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
    taps?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    lastProfitDate?: NullableIntFieldUpdateOperationsInput | number | null
    rechargeLimit?: IntFieldUpdateOperationsInput | number
    pointPerTap?: IntFieldUpdateOperationsInput | number
    profitPerHour?: IntFieldUpdateOperationsInput | number
    refillRate?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    skin?: StringFieldUpdateOperationsInput | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    milestone?: AchievementMilestoneUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    milestoneId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    milestoneId?: StringFieldUpdateOperationsInput | string
  }

  export type TasksCompletionUpdateWithoutUserInput = {
    points?: IntFieldUpdateOperationsInput | number
    task?: TasksUpdateOneRequiredWithoutUserNestedInput
  }

  export type TasksCompletionUncheckedUpdateWithoutUserInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TasksCompletionUncheckedUpdateManyWithoutUserInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type YouTubeCompletionUpdateWithoutUserInput = {
    points?: IntFieldUpdateOperationsInput | number
    task?: YouTubeUpdateOneRequiredWithoutUserNestedInput
  }

  export type YouTubeCompletionUncheckedUpdateWithoutUserInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type YouTubeCompletionUncheckedUpdateManyWithoutUserInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementMilestoneCreateManyCategoryInput = {
    id?: string
    name: string
    icon: string
    unlocked?: boolean
  }

  export type AchievementMilestoneUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    userAchievements?: UserAchievementUpdateManyWithoutMilestoneNestedInput
  }

  export type AchievementMilestoneUncheckedUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type AchievementMilestoneUncheckedUpdateManyWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    unlocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementCreateManyMilestoneInput = {
    id?: string
    userId: string
  }

  export type UserAchievementUpdateWithoutMilestoneInput = {
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutMilestoneInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutMilestoneInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCardCreateManyCardInput = {
    id?: string
    title: string
    image: string
    baseCost: number
    basePPH: number
    baseLevel?: number
    userId: string
    category: string
    discription?: string | null
  }

  export type UserCardUpdateWithoutCardInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserCardNestedInput
  }

  export type UserCardUncheckedUpdateWithoutCardInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardUncheckedUpdateManyWithoutCardInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    basePPH?: FloatFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TasksCompletionCreateManyTaskInput = {
    id?: string
    userId: string
    points: number
  }

  export type TasksCompletionUpdateWithoutTaskInput = {
    points?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserTasksNestedInput
  }

  export type TasksCompletionUncheckedUpdateWithoutTaskInput = {
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TasksCompletionUncheckedUpdateManyWithoutTaskInput = {
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type YouTubeCompletionCreateManyTaskInput = {
    id?: string
    userId: string
    points: number
  }

  export type YouTubeCompletionUpdateWithoutTaskInput = {
    points?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserYouTubeNestedInput
  }

  export type YouTubeCompletionUncheckedUpdateWithoutTaskInput = {
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type YouTubeCompletionUncheckedUpdateManyWithoutTaskInput = {
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type UserSkinCreateManySkinInput = {
    id?: string
    userId: string
  }

  export type UserSkinUpdateWithoutSkinInput = {
    user?: UserUpdateOneRequiredWithoutSkinsNestedInput
  }

  export type UserSkinUncheckedUpdateWithoutSkinInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkinUncheckedUpdateManyWithoutSkinInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementCategoryCountOutputTypeDefaultArgs instead
     */
    export type AchievementCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementMilestoneCountOutputTypeDefaultArgs instead
     */
    export type AchievementMilestoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementMilestoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CardCountOutputTypeDefaultArgs instead
     */
    export type CardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TasksCountOutputTypeDefaultArgs instead
     */
    export type TasksCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TasksCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use YouTubeCountOutputTypeDefaultArgs instead
     */
    export type YouTubeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = YouTubeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkinsCountOutputTypeDefaultArgs instead
     */
    export type SkinsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkinsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementCategoryDefaultArgs instead
     */
    export type AchievementCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementMilestoneDefaultArgs instead
     */
    export type AchievementMilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementMilestoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAchievementDefaultArgs instead
     */
    export type UserAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyRewardDefaultArgs instead
     */
    export type DailyRewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyRewardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CardDefaultArgs instead
     */
    export type CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCardDefaultArgs instead
     */
    export type UserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthenticatorDefaultArgs instead
     */
    export type AuthenticatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthenticatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaguesDefaultArgs instead
     */
    export type LeaguesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaguesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PointsDefaultArgs instead
     */
    export type PointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PointsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BonusterDefaultArgs instead
     */
    export type BonusterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BonusterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyBoostersDefaultArgs instead
     */
    export type DailyBoostersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyBoostersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCategoriesDefaultArgs instead
     */
    export type TaskCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TasksDefaultArgs instead
     */
    export type TasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TasksDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TasksCompletionDefaultArgs instead
     */
    export type TasksCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TasksCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use YouTubeDefaultArgs instead
     */
    export type YouTubeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = YouTubeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use YouTubeCompletionDefaultArgs instead
     */
    export type YouTubeCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = YouTubeCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkinsDefaultArgs instead
     */
    export type SkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkinsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSkinDefaultArgs instead
     */
    export type UserSkinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSkinDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}